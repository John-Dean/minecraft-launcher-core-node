var xg=Object.defineProperty,yg=Object.defineProperties;var _g=Object.getOwnPropertyDescriptors;var Nu=Object.getOwnPropertySymbols;var vg=Object.prototype.hasOwnProperty,Mg=Object.prototype.propertyIsEnumerable;var Bu=(i,t,e)=>t in i?xg(i,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):i[t]=e,Ou=(i,t)=>{for(var e in t||(t={}))vg.call(t,e)&&Bu(i,e,t[e]);if(Nu)for(var e of Nu(t))Mg.call(t,e)&&Bu(i,e,t[e]);return i},Uu=(i,t)=>yg(i,_g(t));/**
 * @license
 * Copyright 2010-2021 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const Hu="127",cn={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2},hn={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},bg=0,Gu=1,wg=2,ku=1,Sg=2,Cs=3,Ba=0,ye=1,Oa=2,Vu=1,Ps=0,Ds=1,Wu=2,$u=3,Xu=4,Eg=5,hr=100,Ag=101,Tg=102,qu=103,Yu=104,Lg=200,Rg=201,Cg=202,Pg=203,ju=204,Zu=205,Dg=206,Fg=207,Ig=208,zg=209,Ng=210,Bg=0,Og=1,Ug=2,Gl=3,Hg=4,Gg=5,kg=6,Vg=7,Ua=0,Wg=1,$g=2,Fs=0,Xg=1,qg=2,Yg=3,jg=4,Zg=5,Ju=300,kl=301,Vl=302,Qu=303,Ku=304,Wl=306,$l=307,Xl=1e3,Xe=1001,ql=1002,Ge=1003,td=1004,ed=1005,be=1006,Jg=1007,Ha=1008,Yl=1009,Qg=1010,Kg=1011,Ga=1012,tx=1013,ka=1014,un=1015,Va=1016,ex=1017,ix=1018,nx=1019,Is=1020,rx=1021,Wn=1022,hi=1023,sx=1024,ax=1025,ur=1026,zs=1027,ox=1028,lx=1029,cx=1030,hx=1031,ux=1032,dx=1033,id=33776,nd=33777,rd=33778,sd=33779,ad=35840,od=35841,ld=35842,cd=35843,fx=36196,hd=37492,ud=37496,px=37808,mx=37809,gx=37810,xx=37811,yx=37812,_x=37813,vx=37814,Mx=37815,bx=37816,wx=37817,Sx=37818,Ex=37819,Ax=37820,Tx=37821,Lx=36492,Rx=37840,Cx=37841,Px=37842,Dx=37843,Fx=37844,Ix=37845,zx=37846,Nx=37847,Bx=37848,Ox=37849,Ux=37850,Hx=37851,Gx=37852,kx=37853,Vx=2200,Wx=2201,$x=2202,Wa=2300,$a=2301,jl=2302,dr=2400,fr=2401,Xa=2402,Zl=2500,dd=2501,Xx=0,Ns=3e3,fd=3001,qx=3007,Yx=3002,jx=3003,Zx=3004,Jx=3005,Qx=3006,Kx=3200,t0=3201,pr=0,e0=1,Jl=7680,i0=519,Bs=35044,Os=35048,pd="300 es";function Ti(){}Object.assign(Ti.prototype,{addEventListener:function(i,t){this._listeners===void 0&&(this._listeners={});const e=this._listeners;e[i]===void 0&&(e[i]=[]),e[i].indexOf(t)===-1&&e[i].push(t)},hasEventListener:function(i,t){if(this._listeners===void 0)return!1;const e=this._listeners;return e[i]!==void 0&&e[i].indexOf(t)!==-1},removeEventListener:function(i,t){if(this._listeners===void 0)return;const n=this._listeners[i];if(n!==void 0){const r=n.indexOf(t);r!==-1&&n.splice(r,1)}},dispatchEvent:function(i){if(this._listeners===void 0)return;const e=this._listeners[i.type];if(e!==void 0){i.target=this;const n=e.slice(0);for(let r=0,s=n.length;r<s;r++)n[r].call(this,i);i.target=null}}});const we=[];for(let i=0;i<256;i++)we[i]=(i<16?"0":"")+i.toString(16);let qa=1234567;const Ot={DEG2RAD:Math.PI/180,RAD2DEG:180/Math.PI,generateUUID:function(){const i=Math.random()*4294967295|0,t=Math.random()*4294967295|0,e=Math.random()*4294967295|0,n=Math.random()*4294967295|0;return(we[i&255]+we[i>>8&255]+we[i>>16&255]+we[i>>24&255]+"-"+we[t&255]+we[t>>8&255]+"-"+we[t>>16&15|64]+we[t>>24&255]+"-"+we[e&63|128]+we[e>>8&255]+"-"+we[e>>16&255]+we[e>>24&255]+we[n&255]+we[n>>8&255]+we[n>>16&255]+we[n>>24&255]).toUpperCase()},clamp:function(i,t,e){return Math.max(t,Math.min(e,i))},euclideanModulo:function(i,t){return(i%t+t)%t},mapLinear:function(i,t,e,n,r){return n+(i-t)*(r-n)/(e-t)},inverseLerp:function(i,t,e){return i!==t?(e-i)/(t-i):0},lerp:function(i,t,e){return(1-e)*i+e*t},damp:function(i,t,e,n){return Ot.lerp(i,t,1-Math.exp(-e*n))},pingpong:function(i,t=1){return t-Math.abs(Ot.euclideanModulo(i,t*2)-t)},smoothstep:function(i,t,e){return i<=t?0:i>=e?1:(i=(i-t)/(e-t),i*i*(3-2*i))},smootherstep:function(i,t,e){return i<=t?0:i>=e?1:(i=(i-t)/(e-t),i*i*i*(i*(i*6-15)+10))},randInt:function(i,t){return i+Math.floor(Math.random()*(t-i+1))},randFloat:function(i,t){return i+Math.random()*(t-i)},randFloatSpread:function(i){return i*(.5-Math.random())},seededRandom:function(i){return i!==void 0&&(qa=i%2147483647),qa=qa*16807%2147483647,(qa-1)/2147483646},degToRad:function(i){return i*Ot.DEG2RAD},radToDeg:function(i){return i*Ot.RAD2DEG},isPowerOfTwo:function(i){return(i&i-1)==0&&i!==0},ceilPowerOfTwo:function(i){return Math.pow(2,Math.ceil(Math.log(i)/Math.LN2))},floorPowerOfTwo:function(i){return Math.pow(2,Math.floor(Math.log(i)/Math.LN2))},setQuaternionFromProperEuler:function(i,t,e,n,r){const s=Math.cos,a=Math.sin,o=s(e/2),l=a(e/2),c=s((t+n)/2),h=a((t+n)/2),u=s((t-n)/2),d=a((t-n)/2),f=s((n-t)/2),p=a((n-t)/2);switch(r){case"XYX":i.set(o*h,l*u,l*d,o*c);break;case"YZY":i.set(l*d,o*h,l*u,o*c);break;case"ZXZ":i.set(l*u,l*d,o*h,o*c);break;case"XZX":i.set(o*h,l*p,l*f,o*c);break;case"YXY":i.set(l*f,o*h,l*p,o*c);break;case"ZYZ":i.set(l*p,l*f,o*h,o*c);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+r)}}};class lt{constructor(t=0,e=0){this.x=t,this.y=e}get width(){return this.x}set width(t){this.x=t}get height(){return this.y}set height(t){this.y=t}set(t,e){return this.x=t,this.y=e,this}setScalar(t){return this.x=t,this.y=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y)}copy(t){return this.x=t.x,this.y=t.y,this}add(t,e){return e!==void 0?(console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this)}addScalar(t){return this.x+=t,this.y+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this}sub(t,e){return e!==void 0?(console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this)}subScalar(t){return this.x-=t,this.y-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this}multiply(t){return this.x*=t.x,this.y*=t.y,this}multiplyScalar(t){return this.x*=t,this.y*=t,this}divide(t){return this.x/=t.x,this.y/=t.y,this}divideScalar(t){return this.multiplyScalar(1/t)}applyMatrix3(t){const e=this.x,n=this.y,r=t.elements;return this.x=r[0]*e+r[3]*n+r[6],this.y=r[1]*e+r[4]*n+r[7],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,n=this.y-t.y;return e*e+n*n}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this}equals(t){return t.x===this.x&&t.y===this.y}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t}fromBufferAttribute(t,e,n){return n!==void 0&&console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this}rotateAround(t,e){const n=Math.cos(e),r=Math.sin(e),s=this.x-t.x,a=this.y-t.y;return this.x=s*n-a*r+t.x,this.y=s*r+a*n+t.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}}lt.prototype.isVector2=!0;class Se{constructor(){this.elements=[1,0,0,0,1,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")}set(t,e,n,r,s,a,o,l,c){const h=this.elements;return h[0]=t,h[1]=r,h[2]=o,h[3]=e,h[4]=s,h[5]=l,h[6]=n,h[7]=a,h[8]=c,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(t){const e=this.elements,n=t.elements;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],this}extractBasis(t,e,n){return t.setFromMatrix3Column(this,0),e.setFromMatrix3Column(this,1),n.setFromMatrix3Column(this,2),this}setFromMatrix4(t){const e=t.elements;return this.set(e[0],e[4],e[8],e[1],e[5],e[9],e[2],e[6],e[10]),this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const n=t.elements,r=e.elements,s=this.elements,a=n[0],o=n[3],l=n[6],c=n[1],h=n[4],u=n[7],d=n[2],f=n[5],p=n[8],x=r[0],y=r[3],g=r[6],m=r[1],E=r[4],w=r[7],S=r[2],_=r[5],T=r[8];return s[0]=a*x+o*m+l*S,s[3]=a*y+o*E+l*_,s[6]=a*g+o*w+l*T,s[1]=c*x+h*m+u*S,s[4]=c*y+h*E+u*_,s[7]=c*g+h*w+u*T,s[2]=d*x+f*m+p*S,s[5]=d*y+f*E+p*_,s[8]=d*g+f*w+p*T,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[3]*=t,e[6]*=t,e[1]*=t,e[4]*=t,e[7]*=t,e[2]*=t,e[5]*=t,e[8]*=t,this}determinant(){const t=this.elements,e=t[0],n=t[1],r=t[2],s=t[3],a=t[4],o=t[5],l=t[6],c=t[7],h=t[8];return e*a*h-e*o*c-n*s*h+n*o*l+r*s*c-r*a*l}invert(){const t=this.elements,e=t[0],n=t[1],r=t[2],s=t[3],a=t[4],o=t[5],l=t[6],c=t[7],h=t[8],u=h*a-o*c,d=o*l-h*s,f=c*s-a*l,p=e*u+n*d+r*f;if(p===0)return this.set(0,0,0,0,0,0,0,0,0);const x=1/p;return t[0]=u*x,t[1]=(r*c-h*n)*x,t[2]=(o*n-r*a)*x,t[3]=d*x,t[4]=(h*e-r*l)*x,t[5]=(r*s-o*e)*x,t[6]=f*x,t[7]=(n*l-c*e)*x,t[8]=(a*e-n*s)*x,this}transpose(){let t;const e=this.elements;return t=e[1],e[1]=e[3],e[3]=t,t=e[2],e[2]=e[6],e[6]=t,t=e[5],e[5]=e[7],e[7]=t,this}getNormalMatrix(t){return this.setFromMatrix4(t).invert().transpose()}transposeIntoArray(t){const e=this.elements;return t[0]=e[0],t[1]=e[3],t[2]=e[6],t[3]=e[1],t[4]=e[4],t[5]=e[7],t[6]=e[2],t[7]=e[5],t[8]=e[8],this}setUvTransform(t,e,n,r,s,a,o){const l=Math.cos(s),c=Math.sin(s);return this.set(n*l,n*c,-n*(l*a+c*o)+a+t,-r*c,r*l,-r*(-c*a+l*o)+o+e,0,0,1),this}scale(t,e){const n=this.elements;return n[0]*=t,n[3]*=t,n[6]*=t,n[1]*=e,n[4]*=e,n[7]*=e,this}rotate(t){const e=Math.cos(t),n=Math.sin(t),r=this.elements,s=r[0],a=r[3],o=r[6],l=r[1],c=r[4],h=r[7];return r[0]=e*s+n*l,r[3]=e*a+n*c,r[6]=e*o+n*h,r[1]=-n*s+e*l,r[4]=-n*a+e*c,r[7]=-n*o+e*h,this}translate(t,e){const n=this.elements;return n[0]+=t*n[2],n[3]+=t*n[5],n[6]+=t*n[8],n[1]+=e*n[2],n[4]+=e*n[5],n[7]+=e*n[8],this}equals(t){const e=this.elements,n=t.elements;for(let r=0;r<9;r++)if(e[r]!==n[r])return!1;return!0}fromArray(t,e=0){for(let n=0;n<9;n++)this.elements[n]=t[n+e];return this}toArray(t=[],e=0){const n=this.elements;return t[e]=n[0],t[e+1]=n[1],t[e+2]=n[2],t[e+3]=n[3],t[e+4]=n[4],t[e+5]=n[5],t[e+6]=n[6],t[e+7]=n[7],t[e+8]=n[8],t}clone(){return new this.constructor().fromArray(this.elements)}}Se.prototype.isMatrix3=!0;let mr;const gr={getDataURL:function(i){if(/^data:/i.test(i.src)||typeof HTMLCanvasElement=="undefined")return i.src;let t;if(i instanceof HTMLCanvasElement)t=i;else{mr===void 0&&(mr=document.createElementNS("http://www.w3.org/1999/xhtml","canvas")),mr.width=i.width,mr.height=i.height;const e=mr.getContext("2d");i instanceof ImageData?e.putImageData(i,0,0):e.drawImage(i,0,0,i.width,i.height),t=mr}return t.width>2048||t.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",i),t.toDataURL("image/jpeg",.6)):t.toDataURL("image/png")}};let n0=0;class Ee extends Ti{constructor(t=Ee.DEFAULT_IMAGE,e=Ee.DEFAULT_MAPPING,n=Xe,r=Xe,s=be,a=Ha,o=hi,l=Yl,c=1,h=Ns){super();Object.defineProperty(this,"id",{value:n0++}),this.uuid=Ot.generateUUID(),this.name="",this.image=t,this.mipmaps=[],this.mapping=e,this.wrapS=n,this.wrapT=r,this.magFilter=s,this.minFilter=a,this.anisotropy=c,this.format=o,this.internalFormat=null,this.type=l,this.offset=new lt(0,0),this.repeat=new lt(1,1),this.center=new lt(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new Se,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.encoding=h,this.version=0,this.onUpdate=null}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(t){return this.name=t.name,this.image=t.image,this.mipmaps=t.mipmaps.slice(0),this.mapping=t.mapping,this.wrapS=t.wrapS,this.wrapT=t.wrapT,this.magFilter=t.magFilter,this.minFilter=t.minFilter,this.anisotropy=t.anisotropy,this.format=t.format,this.internalFormat=t.internalFormat,this.type=t.type,this.offset.copy(t.offset),this.repeat.copy(t.repeat),this.center.copy(t.center),this.rotation=t.rotation,this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrix.copy(t.matrix),this.generateMipmaps=t.generateMipmaps,this.premultiplyAlpha=t.premultiplyAlpha,this.flipY=t.flipY,this.unpackAlignment=t.unpackAlignment,this.encoding=t.encoding,this}toJSON(t){const e=t===void 0||typeof t=="string";if(!e&&t.textures[this.uuid]!==void 0)return t.textures[this.uuid];const n={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};if(this.image!==void 0){const r=this.image;if(r.uuid===void 0&&(r.uuid=Ot.generateUUID()),!e&&t.images[r.uuid]===void 0){let s;if(Array.isArray(r)){s=[];for(let a=0,o=r.length;a<o;a++)r[a].isDataTexture?s.push(Ql(r[a].image)):s.push(Ql(r[a]))}else s=Ql(r);t.images[r.uuid]={uuid:r.uuid,url:s}}n.image=r.uuid}return e||(t.textures[this.uuid]=n),n}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(t){if(this.mapping!==Ju)return t;if(t.applyMatrix3(this.matrix),t.x<0||t.x>1)switch(this.wrapS){case Xl:t.x=t.x-Math.floor(t.x);break;case Xe:t.x=t.x<0?0:1;break;case ql:Math.abs(Math.floor(t.x)%2)===1?t.x=Math.ceil(t.x)-t.x:t.x=t.x-Math.floor(t.x);break}if(t.y<0||t.y>1)switch(this.wrapT){case Xl:t.y=t.y-Math.floor(t.y);break;case Xe:t.y=t.y<0?0:1;break;case ql:Math.abs(Math.floor(t.y)%2)===1?t.y=Math.ceil(t.y)-t.y:t.y=t.y-Math.floor(t.y);break}return this.flipY&&(t.y=1-t.y),t}set needsUpdate(t){t===!0&&this.version++}}Ee.DEFAULT_IMAGE=void 0;Ee.DEFAULT_MAPPING=Ju;Ee.prototype.isTexture=!0;function Ql(i){return typeof HTMLImageElement!="undefined"&&i instanceof HTMLImageElement||typeof HTMLCanvasElement!="undefined"&&i instanceof HTMLCanvasElement||typeof ImageBitmap!="undefined"&&i instanceof ImageBitmap?gr.getDataURL(i):i.data?{data:Array.prototype.slice.call(i.data),width:i.width,height:i.height,type:i.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}class Yt{constructor(t=0,e=0,n=0,r=1){this.x=t,this.y=e,this.z=n,this.w=r}get width(){return this.z}set width(t){this.z=t}get height(){return this.w}set height(t){this.w=t}set(t,e,n,r){return this.x=t,this.y=e,this.z=n,this.w=r,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this.w=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setW(t){return this.w=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;case 3:this.w=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=t.w!==void 0?t.w:1,this}add(t,e){return e!==void 0?(console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this.z+=t.z,this.w+=t.w,this)}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this.w+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this.w=t.w+e.w,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this.w+=t.w*e,this}sub(t,e){return e!==void 0?(console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this.z-=t.z,this.w-=t.w,this)}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this.w-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this.w=t.w-e.w,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this.w*=t.w,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this.w*=t,this}applyMatrix4(t){const e=this.x,n=this.y,r=this.z,s=this.w,a=t.elements;return this.x=a[0]*e+a[4]*n+a[8]*r+a[12]*s,this.y=a[1]*e+a[5]*n+a[9]*r+a[13]*s,this.z=a[2]*e+a[6]*n+a[10]*r+a[14]*s,this.w=a[3]*e+a[7]*n+a[11]*r+a[15]*s,this}divideScalar(t){return this.multiplyScalar(1/t)}setAxisAngleFromQuaternion(t){this.w=2*Math.acos(t.w);const e=Math.sqrt(1-t.w*t.w);return e<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=t.x/e,this.y=t.y/e,this.z=t.z/e),this}setAxisAngleFromRotationMatrix(t){let e,n,r,s;const a=.01,o=.1,l=t.elements,c=l[0],h=l[4],u=l[8],d=l[1],f=l[5],p=l[9],x=l[2],y=l[6],g=l[10];if(Math.abs(h-d)<a&&Math.abs(u-x)<a&&Math.abs(p-y)<a){if(Math.abs(h+d)<o&&Math.abs(u+x)<o&&Math.abs(p+y)<o&&Math.abs(c+f+g-3)<o)return this.set(1,0,0,0),this;e=Math.PI;const E=(c+1)/2,w=(f+1)/2,S=(g+1)/2,_=(h+d)/4,T=(u+x)/4,B=(p+y)/4;return E>w&&E>S?E<a?(n=0,r=.707106781,s=.707106781):(n=Math.sqrt(E),r=_/n,s=T/n):w>S?w<a?(n=.707106781,r=0,s=.707106781):(r=Math.sqrt(w),n=_/r,s=B/r):S<a?(n=.707106781,r=.707106781,s=0):(s=Math.sqrt(S),n=T/s,r=B/s),this.set(n,r,s,e),this}let m=Math.sqrt((y-p)*(y-p)+(u-x)*(u-x)+(d-h)*(d-h));return Math.abs(m)<.001&&(m=1),this.x=(y-p)/m,this.y=(u-x)/m,this.z=(d-h)/m,this.w=Math.acos((c+f+g-1)/2),this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this.w=Math.min(this.w,t.w),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this.w=Math.max(this.w,t.w),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this.w=Math.max(t.w,Math.min(e.w,this.w)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this.w=Math.max(t,Math.min(e,this.w)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this.w+=(t.w-this.w)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this.z=t.z+(e.z-t.z)*n,this.w=t.w+(e.w-t.w)*n,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z&&t.w===this.w}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this.w=t[e+3],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t[e+3]=this.w,t}fromBufferAttribute(t,e,n){return n!==void 0&&console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this.w=t.getW(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}}Yt.prototype.isVector4=!0;class $n extends Ti{constructor(t,e,n){super();this.width=t,this.height=e,this.depth=1,this.scissor=new Yt(0,0,t,e),this.scissorTest=!1,this.viewport=new Yt(0,0,t,e),n=n||{},this.texture=new Ee(void 0,n.mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.encoding),this.texture.image={},this.texture.image.width=t,this.texture.image.height=e,this.texture.image.depth=1,this.texture.generateMipmaps=n.generateMipmaps!==void 0?n.generateMipmaps:!1,this.texture.minFilter=n.minFilter!==void 0?n.minFilter:be,this.depthBuffer=n.depthBuffer!==void 0?n.depthBuffer:!0,this.stencilBuffer=n.stencilBuffer!==void 0?n.stencilBuffer:!1,this.depthTexture=n.depthTexture!==void 0?n.depthTexture:null}setTexture(t){t.image={width:this.width,height:this.height,depth:this.depth},this.texture=t}setSize(t,e,n=1){(this.width!==t||this.height!==e||this.depth!==n)&&(this.width=t,this.height=e,this.depth=n,this.texture.image.width=t,this.texture.image.height=e,this.texture.image.depth=n,this.dispose()),this.viewport.set(0,0,t,e),this.scissor.set(0,0,t,e)}clone(){return new this.constructor().copy(this)}copy(t){return this.width=t.width,this.height=t.height,this.depth=t.depth,this.viewport.copy(t.viewport),this.texture=t.texture.clone(),this.depthBuffer=t.depthBuffer,this.stencilBuffer=t.stencilBuffer,this.depthTexture=t.depthTexture,this}dispose(){this.dispatchEvent({type:"dispose"})}}$n.prototype.isWebGLRenderTarget=!0;class r0 extends $n{constructor(t,e,n){super(t,e,n);this.samples=4}copy(t){return super.copy.call(this,t),this.samples=t.samples,this}}r0.prototype.isWebGLMultisampleRenderTarget=!0;class Ae{constructor(t=0,e=0,n=0,r=1){this._x=t,this._y=e,this._z=n,this._w=r}static slerp(t,e,n,r){return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."),n.slerpQuaternions(t,e,r)}static slerpFlat(t,e,n,r,s,a,o){let l=n[r+0],c=n[r+1],h=n[r+2],u=n[r+3];const d=s[a+0],f=s[a+1],p=s[a+2],x=s[a+3];if(o===0){t[e+0]=l,t[e+1]=c,t[e+2]=h,t[e+3]=u;return}if(o===1){t[e+0]=d,t[e+1]=f,t[e+2]=p,t[e+3]=x;return}if(u!==x||l!==d||c!==f||h!==p){let y=1-o;const g=l*d+c*f+h*p+u*x,m=g>=0?1:-1,E=1-g*g;if(E>Number.EPSILON){const S=Math.sqrt(E),_=Math.atan2(S,g*m);y=Math.sin(y*_)/S,o=Math.sin(o*_)/S}const w=o*m;if(l=l*y+d*w,c=c*y+f*w,h=h*y+p*w,u=u*y+x*w,y===1-o){const S=1/Math.sqrt(l*l+c*c+h*h+u*u);l*=S,c*=S,h*=S,u*=S}}t[e]=l,t[e+1]=c,t[e+2]=h,t[e+3]=u}static multiplyQuaternionsFlat(t,e,n,r,s,a){const o=n[r],l=n[r+1],c=n[r+2],h=n[r+3],u=s[a],d=s[a+1],f=s[a+2],p=s[a+3];return t[e]=o*p+h*u+l*f-c*d,t[e+1]=l*p+h*d+c*u-o*f,t[e+2]=c*p+h*f+o*d-l*u,t[e+3]=h*p-o*u-l*d-c*f,t}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get w(){return this._w}set w(t){this._w=t,this._onChangeCallback()}set(t,e,n,r){return this._x=t,this._y=e,this._z=n,this._w=r,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(t){return this._x=t.x,this._y=t.y,this._z=t.z,this._w=t.w,this._onChangeCallback(),this}setFromEuler(t,e){if(!(t&&t.isEuler))throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");const n=t._x,r=t._y,s=t._z,a=t._order,o=Math.cos,l=Math.sin,c=o(n/2),h=o(r/2),u=o(s/2),d=l(n/2),f=l(r/2),p=l(s/2);switch(a){case"XYZ":this._x=d*h*u+c*f*p,this._y=c*f*u-d*h*p,this._z=c*h*p+d*f*u,this._w=c*h*u-d*f*p;break;case"YXZ":this._x=d*h*u+c*f*p,this._y=c*f*u-d*h*p,this._z=c*h*p-d*f*u,this._w=c*h*u+d*f*p;break;case"ZXY":this._x=d*h*u-c*f*p,this._y=c*f*u+d*h*p,this._z=c*h*p+d*f*u,this._w=c*h*u-d*f*p;break;case"ZYX":this._x=d*h*u-c*f*p,this._y=c*f*u+d*h*p,this._z=c*h*p-d*f*u,this._w=c*h*u+d*f*p;break;case"YZX":this._x=d*h*u+c*f*p,this._y=c*f*u+d*h*p,this._z=c*h*p-d*f*u,this._w=c*h*u-d*f*p;break;case"XZY":this._x=d*h*u-c*f*p,this._y=c*f*u-d*h*p,this._z=c*h*p+d*f*u,this._w=c*h*u+d*f*p;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+a)}return e!==!1&&this._onChangeCallback(),this}setFromAxisAngle(t,e){const n=e/2,r=Math.sin(n);return this._x=t.x*r,this._y=t.y*r,this._z=t.z*r,this._w=Math.cos(n),this._onChangeCallback(),this}setFromRotationMatrix(t){const e=t.elements,n=e[0],r=e[4],s=e[8],a=e[1],o=e[5],l=e[9],c=e[2],h=e[6],u=e[10],d=n+o+u;if(d>0){const f=.5/Math.sqrt(d+1);this._w=.25/f,this._x=(h-l)*f,this._y=(s-c)*f,this._z=(a-r)*f}else if(n>o&&n>u){const f=2*Math.sqrt(1+n-o-u);this._w=(h-l)/f,this._x=.25*f,this._y=(r+a)/f,this._z=(s+c)/f}else if(o>u){const f=2*Math.sqrt(1+o-n-u);this._w=(s-c)/f,this._x=(r+a)/f,this._y=.25*f,this._z=(l+h)/f}else{const f=2*Math.sqrt(1+u-n-o);this._w=(a-r)/f,this._x=(s+c)/f,this._y=(l+h)/f,this._z=.25*f}return this._onChangeCallback(),this}setFromUnitVectors(t,e){let n=t.dot(e)+1;return n<Number.EPSILON?(n=0,Math.abs(t.x)>Math.abs(t.z)?(this._x=-t.y,this._y=t.x,this._z=0,this._w=n):(this._x=0,this._y=-t.z,this._z=t.y,this._w=n)):(this._x=t.y*e.z-t.z*e.y,this._y=t.z*e.x-t.x*e.z,this._z=t.x*e.y-t.y*e.x,this._w=n),this.normalize()}angleTo(t){return 2*Math.acos(Math.abs(Ot.clamp(this.dot(t),-1,1)))}rotateTowards(t,e){const n=this.angleTo(t);if(n===0)return this;const r=Math.min(1,e/n);return this.slerp(t,r),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(t){return this._x*t._x+this._y*t._y+this._z*t._z+this._w*t._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let t=this.length();return t===0?(this._x=0,this._y=0,this._z=0,this._w=1):(t=1/t,this._x=this._x*t,this._y=this._y*t,this._z=this._z*t,this._w=this._w*t),this._onChangeCallback(),this}multiply(t,e){return e!==void 0?(console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),this.multiplyQuaternions(t,e)):this.multiplyQuaternions(this,t)}premultiply(t){return this.multiplyQuaternions(t,this)}multiplyQuaternions(t,e){const n=t._x,r=t._y,s=t._z,a=t._w,o=e._x,l=e._y,c=e._z,h=e._w;return this._x=n*h+a*o+r*c-s*l,this._y=r*h+a*l+s*o-n*c,this._z=s*h+a*c+n*l-r*o,this._w=a*h-n*o-r*l-s*c,this._onChangeCallback(),this}slerp(t,e){if(e===0)return this;if(e===1)return this.copy(t);const n=this._x,r=this._y,s=this._z,a=this._w;let o=a*t._w+n*t._x+r*t._y+s*t._z;if(o<0?(this._w=-t._w,this._x=-t._x,this._y=-t._y,this._z=-t._z,o=-o):this.copy(t),o>=1)return this._w=a,this._x=n,this._y=r,this._z=s,this;const l=1-o*o;if(l<=Number.EPSILON){const f=1-e;return this._w=f*a+e*this._w,this._x=f*n+e*this._x,this._y=f*r+e*this._y,this._z=f*s+e*this._z,this.normalize(),this._onChangeCallback(),this}const c=Math.sqrt(l),h=Math.atan2(c,o),u=Math.sin((1-e)*h)/c,d=Math.sin(e*h)/c;return this._w=a*u+this._w*d,this._x=n*u+this._x*d,this._y=r*u+this._y*d,this._z=s*u+this._z*d,this._onChangeCallback(),this}slerpQuaternions(t,e,n){this.copy(t).slerp(e,n)}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._w===this._w}fromArray(t,e=0){return this._x=t[e],this._y=t[e+1],this._z=t[e+2],this._w=t[e+3],this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._w,t}fromBufferAttribute(t,e){return this._x=t.getX(e),this._y=t.getY(e),this._z=t.getZ(e),this._w=t.getW(e),this}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}}Ae.prototype.isQuaternion=!0;class U{constructor(t=0,e=0,n=0){this.x=t,this.y=e,this.z=n}set(t,e,n){return n===void 0&&(n=this.z),this.x=t,this.y=e,this.z=n,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}add(t,e){return e!==void 0?(console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this.z+=t.z,this)}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this}sub(t,e){return e!==void 0?(console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this.z-=t.z,this)}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this}multiply(t,e){return e!==void 0?(console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(t,e)):(this.x*=t.x,this.y*=t.y,this.z*=t.z,this)}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}multiplyVectors(t,e){return this.x=t.x*e.x,this.y=t.y*e.y,this.z=t.z*e.z,this}applyEuler(t){return t&&t.isEuler||console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),this.applyQuaternion(md.setFromEuler(t))}applyAxisAngle(t,e){return this.applyQuaternion(md.setFromAxisAngle(t,e))}applyMatrix3(t){const e=this.x,n=this.y,r=this.z,s=t.elements;return this.x=s[0]*e+s[3]*n+s[6]*r,this.y=s[1]*e+s[4]*n+s[7]*r,this.z=s[2]*e+s[5]*n+s[8]*r,this}applyNormalMatrix(t){return this.applyMatrix3(t).normalize()}applyMatrix4(t){const e=this.x,n=this.y,r=this.z,s=t.elements,a=1/(s[3]*e+s[7]*n+s[11]*r+s[15]);return this.x=(s[0]*e+s[4]*n+s[8]*r+s[12])*a,this.y=(s[1]*e+s[5]*n+s[9]*r+s[13])*a,this.z=(s[2]*e+s[6]*n+s[10]*r+s[14])*a,this}applyQuaternion(t){const e=this.x,n=this.y,r=this.z,s=t.x,a=t.y,o=t.z,l=t.w,c=l*e+a*r-o*n,h=l*n+o*e-s*r,u=l*r+s*n-a*e,d=-s*e-a*n-o*r;return this.x=c*l+d*-s+h*-o-u*-a,this.y=h*l+d*-a+u*-s-c*-o,this.z=u*l+d*-o+c*-a-h*-s,this}project(t){return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)}unproject(t){return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)}transformDirection(t){const e=this.x,n=this.y,r=this.z,s=t.elements;return this.x=s[0]*e+s[4]*n+s[8]*r,this.y=s[1]*e+s[5]*n+s[9]*r,this.z=s[2]*e+s[6]*n+s[10]*r,this.normalize()}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this}divideScalar(t){return this.multiplyScalar(1/t)}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this.z=t.z+(e.z-t.z)*n,this}cross(t,e){return e!==void 0?(console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(t,e)):this.crossVectors(this,t)}crossVectors(t,e){const n=t.x,r=t.y,s=t.z,a=e.x,o=e.y,l=e.z;return this.x=r*l-s*o,this.y=s*a-n*l,this.z=n*o-r*a,this}projectOnVector(t){const e=t.lengthSq();if(e===0)return this.set(0,0,0);const n=t.dot(this)/e;return this.copy(t).multiplyScalar(n)}projectOnPlane(t){return Kl.copy(this).projectOnVector(t),this.sub(Kl)}reflect(t){return this.sub(Kl.copy(t).multiplyScalar(2*this.dot(t)))}angleTo(t){const e=Math.sqrt(this.lengthSq()*t.lengthSq());if(e===0)return Math.PI/2;const n=this.dot(t)/e;return Math.acos(Ot.clamp(n,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,n=this.y-t.y,r=this.z-t.z;return e*e+n*n+r*r}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)+Math.abs(this.z-t.z)}setFromSpherical(t){return this.setFromSphericalCoords(t.radius,t.phi,t.theta)}setFromSphericalCoords(t,e,n){const r=Math.sin(e)*t;return this.x=r*Math.sin(n),this.y=Math.cos(e)*t,this.z=r*Math.cos(n),this}setFromCylindrical(t){return this.setFromCylindricalCoords(t.radius,t.theta,t.y)}setFromCylindricalCoords(t,e,n){return this.x=t*Math.sin(e),this.y=n,this.z=t*Math.cos(e),this}setFromMatrixPosition(t){const e=t.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this}setFromMatrixScale(t){const e=this.setFromMatrixColumn(t,0).length(),n=this.setFromMatrixColumn(t,1).length(),r=this.setFromMatrixColumn(t,2).length();return this.x=e,this.y=n,this.z=r,this}setFromMatrixColumn(t,e){return this.fromArray(t.elements,e*4)}setFromMatrix3Column(t,e){return this.fromArray(t.elements,e*3)}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t}fromBufferAttribute(t,e,n){return n!==void 0&&console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}}U.prototype.isVector3=!0;const Kl=new U,md=new Ae;class ii{constructor(t=new U(1/0,1/0,1/0),e=new U(-1/0,-1/0,-1/0)){this.min=t,this.max=e}set(t,e){return this.min.copy(t),this.max.copy(e),this}setFromArray(t){let e=1/0,n=1/0,r=1/0,s=-1/0,a=-1/0,o=-1/0;for(let l=0,c=t.length;l<c;l+=3){const h=t[l],u=t[l+1],d=t[l+2];h<e&&(e=h),u<n&&(n=u),d<r&&(r=d),h>s&&(s=h),u>a&&(a=u),d>o&&(o=d)}return this.min.set(e,n,r),this.max.set(s,a,o),this}setFromBufferAttribute(t){let e=1/0,n=1/0,r=1/0,s=-1/0,a=-1/0,o=-1/0;for(let l=0,c=t.count;l<c;l++){const h=t.getX(l),u=t.getY(l),d=t.getZ(l);h<e&&(e=h),u<n&&(n=u),d<r&&(r=d),h>s&&(s=h),u>a&&(a=u),d>o&&(o=d)}return this.min.set(e,n,r),this.max.set(s,a,o),this}setFromPoints(t){this.makeEmpty();for(let e=0,n=t.length;e<n;e++)this.expandByPoint(t[e]);return this}setFromCenterAndSize(t,e){const n=Us.copy(e).multiplyScalar(.5);return this.min.copy(t).sub(n),this.max.copy(t).add(n),this}setFromObject(t){return this.makeEmpty(),this.expandByObject(t)}clone(){return new this.constructor().copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(t){return t===void 0&&(console.warn("THREE.Box3: .getCenter() target is now required"),t=new U),this.isEmpty()?t.set(0,0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return t===void 0&&(console.warn("THREE.Box3: .getSize() target is now required"),t=new U),this.isEmpty()?t.set(0,0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}expandByObject(t){t.updateWorldMatrix(!1,!1);const e=t.geometry;e!==void 0&&(e.boundingBox===null&&e.computeBoundingBox(),tc.copy(e.boundingBox),tc.applyMatrix4(t.matrixWorld),this.union(tc));const n=t.children;for(let r=0,s=n.length;r<s;r++)this.expandByObject(n[r]);return this}containsPoint(t){return!(t.x<this.min.x||t.x>this.max.x||t.y<this.min.y||t.y>this.max.y||t.z<this.min.z||t.z>this.max.z)}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y&&this.min.z<=t.min.z&&t.max.z<=this.max.z}getParameter(t,e){return e===void 0&&(console.warn("THREE.Box3: .getParameter() target is now required"),e=new U),e.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y),(t.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(t){return!(t.max.x<this.min.x||t.min.x>this.max.x||t.max.y<this.min.y||t.min.y>this.max.y||t.max.z<this.min.z||t.min.z>this.max.z)}intersectsSphere(t){return this.clampPoint(t.center,Us),Us.distanceToSquared(t.center)<=t.radius*t.radius}intersectsPlane(t){let e,n;return t.normal.x>0?(e=t.normal.x*this.min.x,n=t.normal.x*this.max.x):(e=t.normal.x*this.max.x,n=t.normal.x*this.min.x),t.normal.y>0?(e+=t.normal.y*this.min.y,n+=t.normal.y*this.max.y):(e+=t.normal.y*this.max.y,n+=t.normal.y*this.min.y),t.normal.z>0?(e+=t.normal.z*this.min.z,n+=t.normal.z*this.max.z):(e+=t.normal.z*this.max.z,n+=t.normal.z*this.min.z),e<=-t.constant&&n>=-t.constant}intersectsTriangle(t){if(this.isEmpty())return!1;this.getCenter(Hs),Ya.subVectors(this.max,Hs),xr.subVectors(t.a,Hs),yr.subVectors(t.b,Hs),_r.subVectors(t.c,Hs),dn.subVectors(yr,xr),fn.subVectors(_r,yr),Xn.subVectors(xr,_r);let e=[0,-dn.z,dn.y,0,-fn.z,fn.y,0,-Xn.z,Xn.y,dn.z,0,-dn.x,fn.z,0,-fn.x,Xn.z,0,-Xn.x,-dn.y,dn.x,0,-fn.y,fn.x,0,-Xn.y,Xn.x,0];return!ec(e,xr,yr,_r,Ya)||(e=[1,0,0,0,1,0,0,0,1],!ec(e,xr,yr,_r,Ya))?!1:(ja.crossVectors(dn,fn),e=[ja.x,ja.y,ja.z],ec(e,xr,yr,_r,Ya))}clampPoint(t,e){return e===void 0&&(console.warn("THREE.Box3: .clampPoint() target is now required"),e=new U),e.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return Us.copy(t).clamp(this.min,this.max).sub(t).length()}getBoundingSphere(t){return t===void 0&&console.error("THREE.Box3: .getBoundingSphere() target is now required"),this.getCenter(t.center),t.radius=this.getSize(Us).length()*.5,t}intersect(t){return this.min.max(t.min),this.max.min(t.max),this.isEmpty()&&this.makeEmpty(),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}applyMatrix4(t){return this.isEmpty()?this:(Hi[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(t),Hi[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(t),Hi[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(t),Hi[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(t),Hi[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(t),Hi[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(t),Hi[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(t),Hi[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(t),this.setFromPoints(Hi),this)}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}}ii.prototype.isBox3=!0;const Hi=[new U,new U,new U,new U,new U,new U,new U,new U],Us=new U,tc=new ii,xr=new U,yr=new U,_r=new U,dn=new U,fn=new U,Xn=new U,Hs=new U,Ya=new U,ja=new U,qn=new U;function ec(i,t,e,n,r){for(let s=0,a=i.length-3;s<=a;s+=3){qn.fromArray(i,s);const o=r.x*Math.abs(qn.x)+r.y*Math.abs(qn.y)+r.z*Math.abs(qn.z),l=t.dot(qn),c=e.dot(qn),h=n.dot(qn);if(Math.max(-Math.max(l,c,h),Math.min(l,c,h))>o)return!1}return!0}const s0=new ii,gd=new U,ic=new U,nc=new U;class vr{constructor(t=new U,e=-1){this.center=t,this.radius=e}set(t,e){return this.center.copy(t),this.radius=e,this}setFromPoints(t,e){const n=this.center;e!==void 0?n.copy(e):s0.setFromPoints(t).getCenter(n);let r=0;for(let s=0,a=t.length;s<a;s++)r=Math.max(r,n.distanceToSquared(t[s]));return this.radius=Math.sqrt(r),this}copy(t){return this.center.copy(t.center),this.radius=t.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(t){return t.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(t){return t.distanceTo(this.center)-this.radius}intersectsSphere(t){const e=this.radius+t.radius;return t.center.distanceToSquared(this.center)<=e*e}intersectsBox(t){return t.intersectsSphere(this)}intersectsPlane(t){return Math.abs(t.distanceToPoint(this.center))<=this.radius}clampPoint(t,e){const n=this.center.distanceToSquared(t);return e===void 0&&(console.warn("THREE.Sphere: .clampPoint() target is now required"),e=new U),e.copy(t),n>this.radius*this.radius&&(e.sub(this.center).normalize(),e.multiplyScalar(this.radius).add(this.center)),e}getBoundingBox(t){return t===void 0&&(console.warn("THREE.Sphere: .getBoundingBox() target is now required"),t=new ii),this.isEmpty()?(t.makeEmpty(),t):(t.set(this.center,this.center),t.expandByScalar(this.radius),t)}applyMatrix4(t){return this.center.applyMatrix4(t),this.radius=this.radius*t.getMaxScaleOnAxis(),this}translate(t){return this.center.add(t),this}expandByPoint(t){nc.subVectors(t,this.center);const e=nc.lengthSq();if(e>this.radius*this.radius){const n=Math.sqrt(e),r=(n-this.radius)*.5;this.center.add(nc.multiplyScalar(r/n)),this.radius+=r}return this}union(t){return ic.subVectors(t.center,this.center).normalize().multiplyScalar(t.radius),this.expandByPoint(gd.copy(t.center).add(ic)),this.expandByPoint(gd.copy(t.center).sub(ic)),this}equals(t){return t.center.equals(this.center)&&t.radius===this.radius}clone(){return new this.constructor().copy(this)}}const Gi=new U,rc=new U,Za=new U,pn=new U,sc=new U,Ja=new U,ac=new U;class Yn{constructor(t=new U,e=new U(0,0,-1)){this.origin=t,this.direction=e}set(t,e){return this.origin.copy(t),this.direction.copy(e),this}copy(t){return this.origin.copy(t.origin),this.direction.copy(t.direction),this}at(t,e){return e===void 0&&(console.warn("THREE.Ray: .at() target is now required"),e=new U),e.copy(this.direction).multiplyScalar(t).add(this.origin)}lookAt(t){return this.direction.copy(t).sub(this.origin).normalize(),this}recast(t){return this.origin.copy(this.at(t,Gi)),this}closestPointToPoint(t,e){e===void 0&&(console.warn("THREE.Ray: .closestPointToPoint() target is now required"),e=new U),e.subVectors(t,this.origin);const n=e.dot(this.direction);return n<0?e.copy(this.origin):e.copy(this.direction).multiplyScalar(n).add(this.origin)}distanceToPoint(t){return Math.sqrt(this.distanceSqToPoint(t))}distanceSqToPoint(t){const e=Gi.subVectors(t,this.origin).dot(this.direction);return e<0?this.origin.distanceToSquared(t):(Gi.copy(this.direction).multiplyScalar(e).add(this.origin),Gi.distanceToSquared(t))}distanceSqToSegment(t,e,n,r){rc.copy(t).add(e).multiplyScalar(.5),Za.copy(e).sub(t).normalize(),pn.copy(this.origin).sub(rc);const s=t.distanceTo(e)*.5,a=-this.direction.dot(Za),o=pn.dot(this.direction),l=-pn.dot(Za),c=pn.lengthSq(),h=Math.abs(1-a*a);let u,d,f,p;if(h>0)if(u=a*l-o,d=a*o-l,p=s*h,u>=0)if(d>=-p)if(d<=p){const x=1/h;u*=x,d*=x,f=u*(u+a*d+2*o)+d*(a*u+d+2*l)+c}else d=s,u=Math.max(0,-(a*d+o)),f=-u*u+d*(d+2*l)+c;else d=-s,u=Math.max(0,-(a*d+o)),f=-u*u+d*(d+2*l)+c;else d<=-p?(u=Math.max(0,-(-a*s+o)),d=u>0?-s:Math.min(Math.max(-s,-l),s),f=-u*u+d*(d+2*l)+c):d<=p?(u=0,d=Math.min(Math.max(-s,-l),s),f=d*(d+2*l)+c):(u=Math.max(0,-(a*s+o)),d=u>0?s:Math.min(Math.max(-s,-l),s),f=-u*u+d*(d+2*l)+c);else d=a>0?-s:s,u=Math.max(0,-(a*d+o)),f=-u*u+d*(d+2*l)+c;return n&&n.copy(this.direction).multiplyScalar(u).add(this.origin),r&&r.copy(Za).multiplyScalar(d).add(rc),f}intersectSphere(t,e){Gi.subVectors(t.center,this.origin);const n=Gi.dot(this.direction),r=Gi.dot(Gi)-n*n,s=t.radius*t.radius;if(r>s)return null;const a=Math.sqrt(s-r),o=n-a,l=n+a;return o<0&&l<0?null:o<0?this.at(l,e):this.at(o,e)}intersectsSphere(t){return this.distanceSqToPoint(t.center)<=t.radius*t.radius}distanceToPlane(t){const e=t.normal.dot(this.direction);if(e===0)return t.distanceToPoint(this.origin)===0?0:null;const n=-(this.origin.dot(t.normal)+t.constant)/e;return n>=0?n:null}intersectPlane(t,e){const n=this.distanceToPlane(t);return n===null?null:this.at(n,e)}intersectsPlane(t){const e=t.distanceToPoint(this.origin);return e===0||t.normal.dot(this.direction)*e<0}intersectBox(t,e){let n,r,s,a,o,l;const c=1/this.direction.x,h=1/this.direction.y,u=1/this.direction.z,d=this.origin;return c>=0?(n=(t.min.x-d.x)*c,r=(t.max.x-d.x)*c):(n=(t.max.x-d.x)*c,r=(t.min.x-d.x)*c),h>=0?(s=(t.min.y-d.y)*h,a=(t.max.y-d.y)*h):(s=(t.max.y-d.y)*h,a=(t.min.y-d.y)*h),n>a||s>r||((s>n||n!==n)&&(n=s),(a<r||r!==r)&&(r=a),u>=0?(o=(t.min.z-d.z)*u,l=(t.max.z-d.z)*u):(o=(t.max.z-d.z)*u,l=(t.min.z-d.z)*u),n>l||o>r)||((o>n||n!==n)&&(n=o),(l<r||r!==r)&&(r=l),r<0)?null:this.at(n>=0?n:r,e)}intersectsBox(t){return this.intersectBox(t,Gi)!==null}intersectTriangle(t,e,n,r,s){sc.subVectors(e,t),Ja.subVectors(n,t),ac.crossVectors(sc,Ja);let a=this.direction.dot(ac),o;if(a>0){if(r)return null;o=1}else if(a<0)o=-1,a=-a;else return null;pn.subVectors(this.origin,t);const l=o*this.direction.dot(Ja.crossVectors(pn,Ja));if(l<0)return null;const c=o*this.direction.dot(sc.cross(pn));if(c<0||l+c>a)return null;const h=-o*pn.dot(ac);return h<0?null:this.at(h/a,s)}applyMatrix4(t){return this.origin.applyMatrix4(t),this.direction.transformDirection(t),this}equals(t){return t.origin.equals(this.origin)&&t.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class It{constructor(){this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")}set(t,e,n,r,s,a,o,l,c,h,u,d,f,p,x,y){const g=this.elements;return g[0]=t,g[4]=e,g[8]=n,g[12]=r,g[1]=s,g[5]=a,g[9]=o,g[13]=l,g[2]=c,g[6]=h,g[10]=u,g[14]=d,g[3]=f,g[7]=p,g[11]=x,g[15]=y,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new It().fromArray(this.elements)}copy(t){const e=this.elements,n=t.elements;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],e[9]=n[9],e[10]=n[10],e[11]=n[11],e[12]=n[12],e[13]=n[13],e[14]=n[14],e[15]=n[15],this}copyPosition(t){const e=this.elements,n=t.elements;return e[12]=n[12],e[13]=n[13],e[14]=n[14],this}setFromMatrix3(t){const e=t.elements;return this.set(e[0],e[3],e[6],0,e[1],e[4],e[7],0,e[2],e[5],e[8],0,0,0,0,1),this}extractBasis(t,e,n){return t.setFromMatrixColumn(this,0),e.setFromMatrixColumn(this,1),n.setFromMatrixColumn(this,2),this}makeBasis(t,e,n){return this.set(t.x,e.x,n.x,0,t.y,e.y,n.y,0,t.z,e.z,n.z,0,0,0,0,1),this}extractRotation(t){const e=this.elements,n=t.elements,r=1/Mr.setFromMatrixColumn(t,0).length(),s=1/Mr.setFromMatrixColumn(t,1).length(),a=1/Mr.setFromMatrixColumn(t,2).length();return e[0]=n[0]*r,e[1]=n[1]*r,e[2]=n[2]*r,e[3]=0,e[4]=n[4]*s,e[5]=n[5]*s,e[6]=n[6]*s,e[7]=0,e[8]=n[8]*a,e[9]=n[9]*a,e[10]=n[10]*a,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromEuler(t){t&&t.isEuler||console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");const e=this.elements,n=t.x,r=t.y,s=t.z,a=Math.cos(n),o=Math.sin(n),l=Math.cos(r),c=Math.sin(r),h=Math.cos(s),u=Math.sin(s);if(t.order==="XYZ"){const d=a*h,f=a*u,p=o*h,x=o*u;e[0]=l*h,e[4]=-l*u,e[8]=c,e[1]=f+p*c,e[5]=d-x*c,e[9]=-o*l,e[2]=x-d*c,e[6]=p+f*c,e[10]=a*l}else if(t.order==="YXZ"){const d=l*h,f=l*u,p=c*h,x=c*u;e[0]=d+x*o,e[4]=p*o-f,e[8]=a*c,e[1]=a*u,e[5]=a*h,e[9]=-o,e[2]=f*o-p,e[6]=x+d*o,e[10]=a*l}else if(t.order==="ZXY"){const d=l*h,f=l*u,p=c*h,x=c*u;e[0]=d-x*o,e[4]=-a*u,e[8]=p+f*o,e[1]=f+p*o,e[5]=a*h,e[9]=x-d*o,e[2]=-a*c,e[6]=o,e[10]=a*l}else if(t.order==="ZYX"){const d=a*h,f=a*u,p=o*h,x=o*u;e[0]=l*h,e[4]=p*c-f,e[8]=d*c+x,e[1]=l*u,e[5]=x*c+d,e[9]=f*c-p,e[2]=-c,e[6]=o*l,e[10]=a*l}else if(t.order==="YZX"){const d=a*l,f=a*c,p=o*l,x=o*c;e[0]=l*h,e[4]=x-d*u,e[8]=p*u+f,e[1]=u,e[5]=a*h,e[9]=-o*h,e[2]=-c*h,e[6]=f*u+p,e[10]=d-x*u}else if(t.order==="XZY"){const d=a*l,f=a*c,p=o*l,x=o*c;e[0]=l*h,e[4]=-u,e[8]=c*h,e[1]=d*u+x,e[5]=a*h,e[9]=f*u-p,e[2]=p*u-f,e[6]=o*h,e[10]=x*u+d}return e[3]=0,e[7]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromQuaternion(t){return this.compose(a0,t,o0)}lookAt(t,e,n){const r=this.elements;return qe.subVectors(t,e),qe.lengthSq()===0&&(qe.z=1),qe.normalize(),mn.crossVectors(n,qe),mn.lengthSq()===0&&(Math.abs(n.z)===1?qe.x+=1e-4:qe.z+=1e-4,qe.normalize(),mn.crossVectors(n,qe)),mn.normalize(),Qa.crossVectors(qe,mn),r[0]=mn.x,r[4]=Qa.x,r[8]=qe.x,r[1]=mn.y,r[5]=Qa.y,r[9]=qe.y,r[2]=mn.z,r[6]=Qa.z,r[10]=qe.z,this}multiply(t,e){return e!==void 0?(console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),this.multiplyMatrices(t,e)):this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const n=t.elements,r=e.elements,s=this.elements,a=n[0],o=n[4],l=n[8],c=n[12],h=n[1],u=n[5],d=n[9],f=n[13],p=n[2],x=n[6],y=n[10],g=n[14],m=n[3],E=n[7],w=n[11],S=n[15],_=r[0],T=r[4],B=r[8],N=r[12],G=r[1],D=r[5],V=r[9],R=r[13],L=r[2],P=r[6],F=r[10],W=r[14],j=r[3],Y=r[7],Q=r[11],K=r[15];return s[0]=a*_+o*G+l*L+c*j,s[4]=a*T+o*D+l*P+c*Y,s[8]=a*B+o*V+l*F+c*Q,s[12]=a*N+o*R+l*W+c*K,s[1]=h*_+u*G+d*L+f*j,s[5]=h*T+u*D+d*P+f*Y,s[9]=h*B+u*V+d*F+f*Q,s[13]=h*N+u*R+d*W+f*K,s[2]=p*_+x*G+y*L+g*j,s[6]=p*T+x*D+y*P+g*Y,s[10]=p*B+x*V+y*F+g*Q,s[14]=p*N+x*R+y*W+g*K,s[3]=m*_+E*G+w*L+S*j,s[7]=m*T+E*D+w*P+S*Y,s[11]=m*B+E*V+w*F+S*Q,s[15]=m*N+E*R+w*W+S*K,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[4]*=t,e[8]*=t,e[12]*=t,e[1]*=t,e[5]*=t,e[9]*=t,e[13]*=t,e[2]*=t,e[6]*=t,e[10]*=t,e[14]*=t,e[3]*=t,e[7]*=t,e[11]*=t,e[15]*=t,this}determinant(){const t=this.elements,e=t[0],n=t[4],r=t[8],s=t[12],a=t[1],o=t[5],l=t[9],c=t[13],h=t[2],u=t[6],d=t[10],f=t[14],p=t[3],x=t[7],y=t[11],g=t[15];return p*(+s*l*u-r*c*u-s*o*d+n*c*d+r*o*f-n*l*f)+x*(+e*l*f-e*c*d+s*a*d-r*a*f+r*c*h-s*l*h)+y*(+e*c*u-e*o*f-s*a*u+n*a*f+s*o*h-n*c*h)+g*(-r*o*h-e*l*u+e*o*d+r*a*u-n*a*d+n*l*h)}transpose(){const t=this.elements;let e;return e=t[1],t[1]=t[4],t[4]=e,e=t[2],t[2]=t[8],t[8]=e,e=t[6],t[6]=t[9],t[9]=e,e=t[3],t[3]=t[12],t[12]=e,e=t[7],t[7]=t[13],t[13]=e,e=t[11],t[11]=t[14],t[14]=e,this}setPosition(t,e,n){const r=this.elements;return t.isVector3?(r[12]=t.x,r[13]=t.y,r[14]=t.z):(r[12]=t,r[13]=e,r[14]=n),this}invert(){const t=this.elements,e=t[0],n=t[1],r=t[2],s=t[3],a=t[4],o=t[5],l=t[6],c=t[7],h=t[8],u=t[9],d=t[10],f=t[11],p=t[12],x=t[13],y=t[14],g=t[15],m=u*y*c-x*d*c+x*l*f-o*y*f-u*l*g+o*d*g,E=p*d*c-h*y*c-p*l*f+a*y*f+h*l*g-a*d*g,w=h*x*c-p*u*c+p*o*f-a*x*f-h*o*g+a*u*g,S=p*u*l-h*x*l-p*o*d+a*x*d+h*o*y-a*u*y,_=e*m+n*E+r*w+s*S;if(_===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const T=1/_;return t[0]=m*T,t[1]=(x*d*s-u*y*s-x*r*f+n*y*f+u*r*g-n*d*g)*T,t[2]=(o*y*s-x*l*s+x*r*c-n*y*c-o*r*g+n*l*g)*T,t[3]=(u*l*s-o*d*s-u*r*c+n*d*c+o*r*f-n*l*f)*T,t[4]=E*T,t[5]=(h*y*s-p*d*s+p*r*f-e*y*f-h*r*g+e*d*g)*T,t[6]=(p*l*s-a*y*s-p*r*c+e*y*c+a*r*g-e*l*g)*T,t[7]=(a*d*s-h*l*s+h*r*c-e*d*c-a*r*f+e*l*f)*T,t[8]=w*T,t[9]=(p*u*s-h*x*s-p*n*f+e*x*f+h*n*g-e*u*g)*T,t[10]=(a*x*s-p*o*s+p*n*c-e*x*c-a*n*g+e*o*g)*T,t[11]=(h*o*s-a*u*s-h*n*c+e*u*c+a*n*f-e*o*f)*T,t[12]=S*T,t[13]=(h*x*r-p*u*r+p*n*d-e*x*d-h*n*y+e*u*y)*T,t[14]=(p*o*r-a*x*r-p*n*l+e*x*l+a*n*y-e*o*y)*T,t[15]=(a*u*r-h*o*r+h*n*l-e*u*l-a*n*d+e*o*d)*T,this}scale(t){const e=this.elements,n=t.x,r=t.y,s=t.z;return e[0]*=n,e[4]*=r,e[8]*=s,e[1]*=n,e[5]*=r,e[9]*=s,e[2]*=n,e[6]*=r,e[10]*=s,e[3]*=n,e[7]*=r,e[11]*=s,this}getMaxScaleOnAxis(){const t=this.elements,e=t[0]*t[0]+t[1]*t[1]+t[2]*t[2],n=t[4]*t[4]+t[5]*t[5]+t[6]*t[6],r=t[8]*t[8]+t[9]*t[9]+t[10]*t[10];return Math.sqrt(Math.max(e,n,r))}makeTranslation(t,e,n){return this.set(1,0,0,t,0,1,0,e,0,0,1,n,0,0,0,1),this}makeRotationX(t){const e=Math.cos(t),n=Math.sin(t);return this.set(1,0,0,0,0,e,-n,0,0,n,e,0,0,0,0,1),this}makeRotationY(t){const e=Math.cos(t),n=Math.sin(t);return this.set(e,0,n,0,0,1,0,0,-n,0,e,0,0,0,0,1),this}makeRotationZ(t){const e=Math.cos(t),n=Math.sin(t);return this.set(e,-n,0,0,n,e,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(t,e){const n=Math.cos(e),r=Math.sin(e),s=1-n,a=t.x,o=t.y,l=t.z,c=s*a,h=s*o;return this.set(c*a+n,c*o-r*l,c*l+r*o,0,c*o+r*l,h*o+n,h*l-r*a,0,c*l-r*o,h*l+r*a,s*l*l+n,0,0,0,0,1),this}makeScale(t,e,n){return this.set(t,0,0,0,0,e,0,0,0,0,n,0,0,0,0,1),this}makeShear(t,e,n){return this.set(1,e,n,0,t,1,n,0,t,e,1,0,0,0,0,1),this}compose(t,e,n){const r=this.elements,s=e._x,a=e._y,o=e._z,l=e._w,c=s+s,h=a+a,u=o+o,d=s*c,f=s*h,p=s*u,x=a*h,y=a*u,g=o*u,m=l*c,E=l*h,w=l*u,S=n.x,_=n.y,T=n.z;return r[0]=(1-(x+g))*S,r[1]=(f+w)*S,r[2]=(p-E)*S,r[3]=0,r[4]=(f-w)*_,r[5]=(1-(d+g))*_,r[6]=(y+m)*_,r[7]=0,r[8]=(p+E)*T,r[9]=(y-m)*T,r[10]=(1-(d+x))*T,r[11]=0,r[12]=t.x,r[13]=t.y,r[14]=t.z,r[15]=1,this}decompose(t,e,n){const r=this.elements;let s=Mr.set(r[0],r[1],r[2]).length();const a=Mr.set(r[4],r[5],r[6]).length(),o=Mr.set(r[8],r[9],r[10]).length();this.determinant()<0&&(s=-s),t.x=r[12],t.y=r[13],t.z=r[14],ui.copy(this);const c=1/s,h=1/a,u=1/o;return ui.elements[0]*=c,ui.elements[1]*=c,ui.elements[2]*=c,ui.elements[4]*=h,ui.elements[5]*=h,ui.elements[6]*=h,ui.elements[8]*=u,ui.elements[9]*=u,ui.elements[10]*=u,e.setFromRotationMatrix(ui),n.x=s,n.y=a,n.z=o,this}makePerspective(t,e,n,r,s,a){a===void 0&&console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");const o=this.elements,l=2*s/(e-t),c=2*s/(n-r),h=(e+t)/(e-t),u=(n+r)/(n-r),d=-(a+s)/(a-s),f=-2*a*s/(a-s);return o[0]=l,o[4]=0,o[8]=h,o[12]=0,o[1]=0,o[5]=c,o[9]=u,o[13]=0,o[2]=0,o[6]=0,o[10]=d,o[14]=f,o[3]=0,o[7]=0,o[11]=-1,o[15]=0,this}makeOrthographic(t,e,n,r,s,a){const o=this.elements,l=1/(e-t),c=1/(n-r),h=1/(a-s),u=(e+t)*l,d=(n+r)*c,f=(a+s)*h;return o[0]=2*l,o[4]=0,o[8]=0,o[12]=-u,o[1]=0,o[5]=2*c,o[9]=0,o[13]=-d,o[2]=0,o[6]=0,o[10]=-2*h,o[14]=-f,o[3]=0,o[7]=0,o[11]=0,o[15]=1,this}equals(t){const e=this.elements,n=t.elements;for(let r=0;r<16;r++)if(e[r]!==n[r])return!1;return!0}fromArray(t,e=0){for(let n=0;n<16;n++)this.elements[n]=t[n+e];return this}toArray(t=[],e=0){const n=this.elements;return t[e]=n[0],t[e+1]=n[1],t[e+2]=n[2],t[e+3]=n[3],t[e+4]=n[4],t[e+5]=n[5],t[e+6]=n[6],t[e+7]=n[7],t[e+8]=n[8],t[e+9]=n[9],t[e+10]=n[10],t[e+11]=n[11],t[e+12]=n[12],t[e+13]=n[13],t[e+14]=n[14],t[e+15]=n[15],t}}It.prototype.isMatrix4=!0;const Mr=new U,ui=new It,a0=new U(0,0,0),o0=new U(1,1,1),mn=new U,Qa=new U,qe=new U,xd=new It,yd=new Ae;class br{constructor(t=0,e=0,n=0,r=br.DefaultOrder){this._x=t,this._y=e,this._z=n,this._order=r}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get order(){return this._order}set order(t){this._order=t,this._onChangeCallback()}set(t,e,n,r){return this._x=t,this._y=e,this._z=n,this._order=r||this._order,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(t){return this._x=t._x,this._y=t._y,this._z=t._z,this._order=t._order,this._onChangeCallback(),this}setFromRotationMatrix(t,e,n){const r=Ot.clamp,s=t.elements,a=s[0],o=s[4],l=s[8],c=s[1],h=s[5],u=s[9],d=s[2],f=s[6],p=s[10];switch(e=e||this._order,e){case"XYZ":this._y=Math.asin(r(l,-1,1)),Math.abs(l)<.9999999?(this._x=Math.atan2(-u,p),this._z=Math.atan2(-o,a)):(this._x=Math.atan2(f,h),this._z=0);break;case"YXZ":this._x=Math.asin(-r(u,-1,1)),Math.abs(u)<.9999999?(this._y=Math.atan2(l,p),this._z=Math.atan2(c,h)):(this._y=Math.atan2(-d,a),this._z=0);break;case"ZXY":this._x=Math.asin(r(f,-1,1)),Math.abs(f)<.9999999?(this._y=Math.atan2(-d,p),this._z=Math.atan2(-o,h)):(this._y=0,this._z=Math.atan2(c,a));break;case"ZYX":this._y=Math.asin(-r(d,-1,1)),Math.abs(d)<.9999999?(this._x=Math.atan2(f,p),this._z=Math.atan2(c,a)):(this._x=0,this._z=Math.atan2(-o,h));break;case"YZX":this._z=Math.asin(r(c,-1,1)),Math.abs(c)<.9999999?(this._x=Math.atan2(-u,h),this._y=Math.atan2(-d,a)):(this._x=0,this._y=Math.atan2(l,p));break;case"XZY":this._z=Math.asin(-r(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(f,h),this._y=Math.atan2(l,a)):(this._x=Math.atan2(-u,p),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+e)}return this._order=e,n!==!1&&this._onChangeCallback(),this}setFromQuaternion(t,e,n){return xd.makeRotationFromQuaternion(t),this.setFromRotationMatrix(xd,e,n)}setFromVector3(t,e){return this.set(t.x,t.y,t.z,e||this._order)}reorder(t){return yd.setFromEuler(this),this.setFromQuaternion(yd,t)}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._order===this._order}fromArray(t){return this._x=t[0],this._y=t[1],this._z=t[2],t[3]!==void 0&&(this._order=t[3]),this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._order,t}toVector3(t){return t?t.set(this._x,this._y,this._z):new U(this._x,this._y,this._z)}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}}br.prototype.isEuler=!0;br.DefaultOrder="XYZ";br.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"];class _d{constructor(){this.mask=1|0}set(t){this.mask=1<<t|0}enable(t){this.mask|=1<<t|0}enableAll(){this.mask=4294967295|0}toggle(t){this.mask^=1<<t|0}disable(t){this.mask&=~(1<<t|0)}disableAll(){this.mask=0}test(t){return(this.mask&t.mask)!=0}}let l0=0;const vd=new U,wr=new Ae,ki=new It,Ka=new U,Gs=new U,c0=new U,h0=new Ae,Md=new U(1,0,0),bd=new U(0,1,0),wd=new U(0,0,1),u0={type:"added"},Sd={type:"removed"};function Bt(){Object.defineProperty(this,"id",{value:l0++}),this.uuid=Ot.generateUUID(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=Bt.DefaultUp.clone();const i=new U,t=new br,e=new Ae,n=new U(1,1,1);function r(){e.setFromEuler(t,!1)}function s(){t.setFromQuaternion(e,void 0,!1)}t._onChange(r),e._onChange(s),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:i},rotation:{configurable:!0,enumerable:!0,value:t},quaternion:{configurable:!0,enumerable:!0,value:e},scale:{configurable:!0,enumerable:!0,value:n},modelViewMatrix:{value:new It},normalMatrix:{value:new Se}}),this.matrix=new It,this.matrixWorld=new It,this.matrixAutoUpdate=Bt.DefaultMatrixAutoUpdate,this.matrixWorldNeedsUpdate=!1,this.layers=new _d,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}Bt.DefaultUp=new U(0,1,0);Bt.DefaultMatrixAutoUpdate=!0;Bt.prototype=Object.assign(Object.create(Ti.prototype),{constructor:Bt,isObject3D:!0,onBeforeRender:function(){},onAfterRender:function(){},applyMatrix4:function(i){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(i),this.matrix.decompose(this.position,this.quaternion,this.scale)},applyQuaternion:function(i){return this.quaternion.premultiply(i),this},setRotationFromAxisAngle:function(i,t){this.quaternion.setFromAxisAngle(i,t)},setRotationFromEuler:function(i){this.quaternion.setFromEuler(i,!0)},setRotationFromMatrix:function(i){this.quaternion.setFromRotationMatrix(i)},setRotationFromQuaternion:function(i){this.quaternion.copy(i)},rotateOnAxis:function(i,t){return wr.setFromAxisAngle(i,t),this.quaternion.multiply(wr),this},rotateOnWorldAxis:function(i,t){return wr.setFromAxisAngle(i,t),this.quaternion.premultiply(wr),this},rotateX:function(i){return this.rotateOnAxis(Md,i)},rotateY:function(i){return this.rotateOnAxis(bd,i)},rotateZ:function(i){return this.rotateOnAxis(wd,i)},translateOnAxis:function(i,t){return vd.copy(i).applyQuaternion(this.quaternion),this.position.add(vd.multiplyScalar(t)),this},translateX:function(i){return this.translateOnAxis(Md,i)},translateY:function(i){return this.translateOnAxis(bd,i)},translateZ:function(i){return this.translateOnAxis(wd,i)},localToWorld:function(i){return i.applyMatrix4(this.matrixWorld)},worldToLocal:function(i){return i.applyMatrix4(ki.copy(this.matrixWorld).invert())},lookAt:function(i,t,e){i.isVector3?Ka.copy(i):Ka.set(i,t,e);const n=this.parent;this.updateWorldMatrix(!0,!1),Gs.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?ki.lookAt(Gs,Ka,this.up):ki.lookAt(Ka,Gs,this.up),this.quaternion.setFromRotationMatrix(ki),n&&(ki.extractRotation(n.matrixWorld),wr.setFromRotationMatrix(ki),this.quaternion.premultiply(wr.invert()))},add:function(i){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.add(arguments[t]);return this}return i===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",i),this):(i&&i.isObject3D?(i.parent!==null&&i.parent.remove(i),i.parent=this,this.children.push(i),i.dispatchEvent(u0)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",i),this)},remove:function(i){if(arguments.length>1){for(let e=0;e<arguments.length;e++)this.remove(arguments[e]);return this}const t=this.children.indexOf(i);return t!==-1&&(i.parent=null,this.children.splice(t,1),i.dispatchEvent(Sd)),this},clear:function(){for(let i=0;i<this.children.length;i++){const t=this.children[i];t.parent=null,t.dispatchEvent(Sd)}return this.children.length=0,this},attach:function(i){return this.updateWorldMatrix(!0,!1),ki.copy(this.matrixWorld).invert(),i.parent!==null&&(i.parent.updateWorldMatrix(!0,!1),ki.multiply(i.parent.matrixWorld)),i.applyMatrix4(ki),this.add(i),i.updateWorldMatrix(!1,!0),this},getObjectById:function(i){return this.getObjectByProperty("id",i)},getObjectByName:function(i){return this.getObjectByProperty("name",i)},getObjectByProperty:function(i,t){if(this[i]===t)return this;for(let e=0,n=this.children.length;e<n;e++){const s=this.children[e].getObjectByProperty(i,t);if(s!==void 0)return s}},getWorldPosition:function(i){return i===void 0&&(console.warn("THREE.Object3D: .getWorldPosition() target is now required"),i=new U),this.updateWorldMatrix(!0,!1),i.setFromMatrixPosition(this.matrixWorld)},getWorldQuaternion:function(i){return i===void 0&&(console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"),i=new Ae),this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Gs,i,c0),i},getWorldScale:function(i){return i===void 0&&(console.warn("THREE.Object3D: .getWorldScale() target is now required"),i=new U),this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Gs,h0,i),i},getWorldDirection:function(i){i===void 0&&(console.warn("THREE.Object3D: .getWorldDirection() target is now required"),i=new U),this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return i.set(t[8],t[9],t[10]).normalize()},raycast:function(){},traverse:function(i){i(this);const t=this.children;for(let e=0,n=t.length;e<n;e++)t[e].traverse(i)},traverseVisible:function(i){if(this.visible===!1)return;i(this);const t=this.children;for(let e=0,n=t.length;e<n;e++)t[e].traverseVisible(i)},traverseAncestors:function(i){const t=this.parent;t!==null&&(i(t),t.traverseAncestors(i))},updateMatrix:function(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0},updateMatrixWorld:function(i){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||i)&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,i=!0);const t=this.children;for(let e=0,n=t.length;e<n;e++)t[e].updateMatrixWorld(i)},updateWorldMatrix:function(i,t){const e=this.parent;if(i===!0&&e!==null&&e.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),t===!0){const n=this.children;for(let r=0,s=n.length;r<s;r++)n[r].updateWorldMatrix(!1,!0)}},toJSON:function(i){const t=i===void 0||typeof i=="string",e={};t&&(i={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{}},e.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});const n={};n.uuid=this.uuid,n.type=this.type,this.name!==""&&(n.name=this.name),this.castShadow===!0&&(n.castShadow=!0),this.receiveShadow===!0&&(n.receiveShadow=!0),this.visible===!1&&(n.visible=!1),this.frustumCulled===!1&&(n.frustumCulled=!1),this.renderOrder!==0&&(n.renderOrder=this.renderOrder),JSON.stringify(this.userData)!=="{}"&&(n.userData=this.userData),n.layers=this.layers.mask,n.matrix=this.matrix.toArray(),this.matrixAutoUpdate===!1&&(n.matrixAutoUpdate=!1),this.isInstancedMesh&&(n.type="InstancedMesh",n.count=this.count,n.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(n.instanceColor=this.instanceColor.toJSON()));function r(a,o){return a[o.uuid]===void 0&&(a[o.uuid]=o.toJSON(i)),o.uuid}if(this.isMesh||this.isLine||this.isPoints){n.geometry=r(i.geometries,this.geometry);const a=this.geometry.parameters;if(a!==void 0&&a.shapes!==void 0){const o=a.shapes;if(Array.isArray(o))for(let l=0,c=o.length;l<c;l++){const h=o[l];r(i.shapes,h)}else r(i.shapes,o)}}if(this.isSkinnedMesh&&(n.bindMode=this.bindMode,n.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(r(i.skeletons,this.skeleton),n.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const a=[];for(let o=0,l=this.material.length;o<l;o++)a.push(r(i.materials,this.material[o]));n.material=a}else n.material=r(i.materials,this.material);if(this.children.length>0){n.children=[];for(let a=0;a<this.children.length;a++)n.children.push(this.children[a].toJSON(i).object)}if(this.animations.length>0){n.animations=[];for(let a=0;a<this.animations.length;a++){const o=this.animations[a];n.animations.push(r(i.animations,o))}}if(t){const a=s(i.geometries),o=s(i.materials),l=s(i.textures),c=s(i.images),h=s(i.shapes),u=s(i.skeletons),d=s(i.animations);a.length>0&&(e.geometries=a),o.length>0&&(e.materials=o),l.length>0&&(e.textures=l),c.length>0&&(e.images=c),h.length>0&&(e.shapes=h),u.length>0&&(e.skeletons=u),d.length>0&&(e.animations=d)}return e.object=n,e;function s(a){const o=[];for(const l in a){const c=a[l];delete c.metadata,o.push(c)}return o}},clone:function(i){return new this.constructor().copy(this,i)},copy:function(i,t=!0){if(this.name=i.name,this.up.copy(i.up),this.position.copy(i.position),this.rotation.order=i.rotation.order,this.quaternion.copy(i.quaternion),this.scale.copy(i.scale),this.matrix.copy(i.matrix),this.matrixWorld.copy(i.matrixWorld),this.matrixAutoUpdate=i.matrixAutoUpdate,this.matrixWorldNeedsUpdate=i.matrixWorldNeedsUpdate,this.layers.mask=i.layers.mask,this.visible=i.visible,this.castShadow=i.castShadow,this.receiveShadow=i.receiveShadow,this.frustumCulled=i.frustumCulled,this.renderOrder=i.renderOrder,this.userData=JSON.parse(JSON.stringify(i.userData)),t===!0)for(let e=0;e<i.children.length;e++){const n=i.children[e];this.add(n.clone())}return this}});const oc=new U,d0=new U,f0=new Se;class Li{constructor(t=new U(1,0,0),e=0){this.normal=t,this.constant=e}set(t,e){return this.normal.copy(t),this.constant=e,this}setComponents(t,e,n,r){return this.normal.set(t,e,n),this.constant=r,this}setFromNormalAndCoplanarPoint(t,e){return this.normal.copy(t),this.constant=-e.dot(this.normal),this}setFromCoplanarPoints(t,e,n){const r=oc.subVectors(n,e).cross(d0.subVectors(t,e)).normalize();return this.setFromNormalAndCoplanarPoint(r,t),this}copy(t){return this.normal.copy(t.normal),this.constant=t.constant,this}normalize(){const t=1/this.normal.length();return this.normal.multiplyScalar(t),this.constant*=t,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(t){return this.normal.dot(t)+this.constant}distanceToSphere(t){return this.distanceToPoint(t.center)-t.radius}projectPoint(t,e){return e===void 0&&(console.warn("THREE.Plane: .projectPoint() target is now required"),e=new U),e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)}intersectLine(t,e){e===void 0&&(console.warn("THREE.Plane: .intersectLine() target is now required"),e=new U);const n=t.delta(oc),r=this.normal.dot(n);if(r===0)return this.distanceToPoint(t.start)===0?e.copy(t.start):null;const s=-(t.start.dot(this.normal)+this.constant)/r;return s<0||s>1?null:e.copy(n).multiplyScalar(s).add(t.start)}intersectsLine(t){const e=this.distanceToPoint(t.start),n=this.distanceToPoint(t.end);return e<0&&n>0||n<0&&e>0}intersectsBox(t){return t.intersectsPlane(this)}intersectsSphere(t){return t.intersectsPlane(this)}coplanarPoint(t){return t===void 0&&(console.warn("THREE.Plane: .coplanarPoint() target is now required"),t=new U),t.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(t,e){const n=e||f0.getNormalMatrix(t),r=this.coplanarPoint(oc).applyMatrix4(t),s=this.normal.applyMatrix3(n).normalize();return this.constant=-r.dot(s),this}translate(t){return this.constant-=t.dot(this.normal),this}equals(t){return t.normal.equals(this.normal)&&t.constant===this.constant}clone(){return new this.constructor().copy(this)}}Li.prototype.isPlane=!0;const di=new U,Vi=new U,lc=new U,Wi=new U,Sr=new U,Er=new U,Ed=new U,cc=new U,hc=new U,uc=new U;class ce{constructor(t=new U,e=new U,n=new U){this.a=t,this.b=e,this.c=n}static getNormal(t,e,n,r){r===void 0&&(console.warn("THREE.Triangle: .getNormal() target is now required"),r=new U),r.subVectors(n,e),di.subVectors(t,e),r.cross(di);const s=r.lengthSq();return s>0?r.multiplyScalar(1/Math.sqrt(s)):r.set(0,0,0)}static getBarycoord(t,e,n,r,s){di.subVectors(r,e),Vi.subVectors(n,e),lc.subVectors(t,e);const a=di.dot(di),o=di.dot(Vi),l=di.dot(lc),c=Vi.dot(Vi),h=Vi.dot(lc),u=a*c-o*o;if(s===void 0&&(console.warn("THREE.Triangle: .getBarycoord() target is now required"),s=new U),u===0)return s.set(-2,-1,-1);const d=1/u,f=(c*l-o*h)*d,p=(a*h-o*l)*d;return s.set(1-f-p,p,f)}static containsPoint(t,e,n,r){return this.getBarycoord(t,e,n,r,Wi),Wi.x>=0&&Wi.y>=0&&Wi.x+Wi.y<=1}static getUV(t,e,n,r,s,a,o,l){return this.getBarycoord(t,e,n,r,Wi),l.set(0,0),l.addScaledVector(s,Wi.x),l.addScaledVector(a,Wi.y),l.addScaledVector(o,Wi.z),l}static isFrontFacing(t,e,n,r){return di.subVectors(n,e),Vi.subVectors(t,e),di.cross(Vi).dot(r)<0}set(t,e,n){return this.a.copy(t),this.b.copy(e),this.c.copy(n),this}setFromPointsAndIndices(t,e,n,r){return this.a.copy(t[e]),this.b.copy(t[n]),this.c.copy(t[r]),this}clone(){return new this.constructor().copy(this)}copy(t){return this.a.copy(t.a),this.b.copy(t.b),this.c.copy(t.c),this}getArea(){return di.subVectors(this.c,this.b),Vi.subVectors(this.a,this.b),di.cross(Vi).length()*.5}getMidpoint(t){return t===void 0&&(console.warn("THREE.Triangle: .getMidpoint() target is now required"),t=new U),t.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(t){return ce.getNormal(this.a,this.b,this.c,t)}getPlane(t){return t===void 0&&(console.warn("THREE.Triangle: .getPlane() target is now required"),t=new Li),t.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(t,e){return ce.getBarycoord(t,this.a,this.b,this.c,e)}getUV(t,e,n,r,s){return ce.getUV(t,this.a,this.b,this.c,e,n,r,s)}containsPoint(t){return ce.containsPoint(t,this.a,this.b,this.c)}isFrontFacing(t){return ce.isFrontFacing(this.a,this.b,this.c,t)}intersectsBox(t){return t.intersectsTriangle(this)}closestPointToPoint(t,e){e===void 0&&(console.warn("THREE.Triangle: .closestPointToPoint() target is now required"),e=new U);const n=this.a,r=this.b,s=this.c;let a,o;Sr.subVectors(r,n),Er.subVectors(s,n),cc.subVectors(t,n);const l=Sr.dot(cc),c=Er.dot(cc);if(l<=0&&c<=0)return e.copy(n);hc.subVectors(t,r);const h=Sr.dot(hc),u=Er.dot(hc);if(h>=0&&u<=h)return e.copy(r);const d=l*u-h*c;if(d<=0&&l>=0&&h<=0)return a=l/(l-h),e.copy(n).addScaledVector(Sr,a);uc.subVectors(t,s);const f=Sr.dot(uc),p=Er.dot(uc);if(p>=0&&f<=p)return e.copy(s);const x=f*c-l*p;if(x<=0&&c>=0&&p<=0)return o=c/(c-p),e.copy(n).addScaledVector(Er,o);const y=h*p-f*u;if(y<=0&&u-h>=0&&f-p>=0)return Ed.subVectors(s,r),o=(u-h)/(u-h+(f-p)),e.copy(r).addScaledVector(Ed,o);const g=1/(y+x+d);return a=x*g,o=d*g,e.copy(n).addScaledVector(Sr,a).addScaledVector(Er,o)}equals(t){return t.a.equals(this.a)&&t.b.equals(this.b)&&t.c.equals(this.c)}}let p0=0;function se(){Object.defineProperty(this,"id",{value:p0++}),this.uuid=Ot.generateUUID(),this.name="",this.type="Material",this.fog=!0,this.blending=Ds,this.side=Ba,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.blendSrc=ju,this.blendDst=Zu,this.blendEquation=hr,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=Gl,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=i0,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=Jl,this.stencilZFail=Jl,this.stencilZPass=Jl,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaTest=0,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0}se.prototype=Object.assign(Object.create(Ti.prototype),{constructor:se,isMaterial:!0,onBeforeCompile:function(){},customProgramCacheKey:function(){return this.onBeforeCompile.toString()},setValues:function(i){if(i!==void 0)for(const t in i){const e=i[t];if(e===void 0){console.warn("THREE.Material: '"+t+"' parameter is undefined.");continue}if(t==="shading"){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=e===Vu;continue}const n=this[t];if(n===void 0){console.warn("THREE."+this.type+": '"+t+"' is not a property of this material.");continue}n&&n.isColor?n.set(e):n&&n.isVector3&&e&&e.isVector3?n.copy(e):this[t]=e}},toJSON:function(i){const t=i===void 0||typeof i=="string";t&&(i={textures:{},images:{}});const e={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};e.uuid=this.uuid,e.type=this.type,this.name!==""&&(e.name=this.name),this.color&&this.color.isColor&&(e.color=this.color.getHex()),this.roughness!==void 0&&(e.roughness=this.roughness),this.metalness!==void 0&&(e.metalness=this.metalness),this.sheen&&this.sheen.isColor&&(e.sheen=this.sheen.getHex()),this.emissive&&this.emissive.isColor&&(e.emissive=this.emissive.getHex()),this.emissiveIntensity&&this.emissiveIntensity!==1&&(e.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(e.specular=this.specular.getHex()),this.shininess!==void 0&&(e.shininess=this.shininess),this.clearcoat!==void 0&&(e.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(e.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(e.clearcoatMap=this.clearcoatMap.toJSON(i).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(e.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(i).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(e.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(i).uuid,e.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.map&&this.map.isTexture&&(e.map=this.map.toJSON(i).uuid),this.matcap&&this.matcap.isTexture&&(e.matcap=this.matcap.toJSON(i).uuid),this.alphaMap&&this.alphaMap.isTexture&&(e.alphaMap=this.alphaMap.toJSON(i).uuid),this.lightMap&&this.lightMap.isTexture&&(e.lightMap=this.lightMap.toJSON(i).uuid,e.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(e.aoMap=this.aoMap.toJSON(i).uuid,e.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(e.bumpMap=this.bumpMap.toJSON(i).uuid,e.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(e.normalMap=this.normalMap.toJSON(i).uuid,e.normalMapType=this.normalMapType,e.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(e.displacementMap=this.displacementMap.toJSON(i).uuid,e.displacementScale=this.displacementScale,e.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(e.roughnessMap=this.roughnessMap.toJSON(i).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(e.metalnessMap=this.metalnessMap.toJSON(i).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(e.emissiveMap=this.emissiveMap.toJSON(i).uuid),this.specularMap&&this.specularMap.isTexture&&(e.specularMap=this.specularMap.toJSON(i).uuid),this.envMap&&this.envMap.isTexture&&(e.envMap=this.envMap.toJSON(i).uuid,e.reflectivity=this.reflectivity,e.refractionRatio=this.refractionRatio,this.combine!==void 0&&(e.combine=this.combine),this.envMapIntensity!==void 0&&(e.envMapIntensity=this.envMapIntensity)),this.gradientMap&&this.gradientMap.isTexture&&(e.gradientMap=this.gradientMap.toJSON(i).uuid),this.size!==void 0&&(e.size=this.size),this.shadowSide!==null&&(e.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(e.sizeAttenuation=this.sizeAttenuation),this.blending!==Ds&&(e.blending=this.blending),this.side!==Ba&&(e.side=this.side),this.vertexColors&&(e.vertexColors=!0),this.opacity<1&&(e.opacity=this.opacity),this.transparent===!0&&(e.transparent=this.transparent),e.depthFunc=this.depthFunc,e.depthTest=this.depthTest,e.depthWrite=this.depthWrite,e.colorWrite=this.colorWrite,e.stencilWrite=this.stencilWrite,e.stencilWriteMask=this.stencilWriteMask,e.stencilFunc=this.stencilFunc,e.stencilRef=this.stencilRef,e.stencilFuncMask=this.stencilFuncMask,e.stencilFail=this.stencilFail,e.stencilZFail=this.stencilZFail,e.stencilZPass=this.stencilZPass,this.rotation&&this.rotation!==0&&(e.rotation=this.rotation),this.polygonOffset===!0&&(e.polygonOffset=!0),this.polygonOffsetFactor!==0&&(e.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(e.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth&&this.linewidth!==1&&(e.linewidth=this.linewidth),this.dashSize!==void 0&&(e.dashSize=this.dashSize),this.gapSize!==void 0&&(e.gapSize=this.gapSize),this.scale!==void 0&&(e.scale=this.scale),this.dithering===!0&&(e.dithering=!0),this.alphaTest>0&&(e.alphaTest=this.alphaTest),this.alphaToCoverage===!0&&(e.alphaToCoverage=this.alphaToCoverage),this.premultipliedAlpha===!0&&(e.premultipliedAlpha=this.premultipliedAlpha),this.wireframe===!0&&(e.wireframe=this.wireframe),this.wireframeLinewidth>1&&(e.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(e.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(e.wireframeLinejoin=this.wireframeLinejoin),this.morphTargets===!0&&(e.morphTargets=!0),this.morphNormals===!0&&(e.morphNormals=!0),this.skinning===!0&&(e.skinning=!0),this.flatShading===!0&&(e.flatShading=this.flatShading),this.visible===!1&&(e.visible=!1),this.toneMapped===!1&&(e.toneMapped=!1),JSON.stringify(this.userData)!=="{}"&&(e.userData=this.userData);function n(r){const s=[];for(const a in r){const o=r[a];delete o.metadata,s.push(o)}return s}if(t){const r=n(i.textures),s=n(i.images);r.length>0&&(e.textures=r),s.length>0&&(e.images=s)}return e},clone:function(){return new this.constructor().copy(this)},copy:function(i){this.name=i.name,this.fog=i.fog,this.blending=i.blending,this.side=i.side,this.vertexColors=i.vertexColors,this.opacity=i.opacity,this.transparent=i.transparent,this.blendSrc=i.blendSrc,this.blendDst=i.blendDst,this.blendEquation=i.blendEquation,this.blendSrcAlpha=i.blendSrcAlpha,this.blendDstAlpha=i.blendDstAlpha,this.blendEquationAlpha=i.blendEquationAlpha,this.depthFunc=i.depthFunc,this.depthTest=i.depthTest,this.depthWrite=i.depthWrite,this.stencilWriteMask=i.stencilWriteMask,this.stencilFunc=i.stencilFunc,this.stencilRef=i.stencilRef,this.stencilFuncMask=i.stencilFuncMask,this.stencilFail=i.stencilFail,this.stencilZFail=i.stencilZFail,this.stencilZPass=i.stencilZPass,this.stencilWrite=i.stencilWrite;const t=i.clippingPlanes;let e=null;if(t!==null){const n=t.length;e=new Array(n);for(let r=0;r!==n;++r)e[r]=t[r].clone()}return this.clippingPlanes=e,this.clipIntersection=i.clipIntersection,this.clipShadows=i.clipShadows,this.shadowSide=i.shadowSide,this.colorWrite=i.colorWrite,this.precision=i.precision,this.polygonOffset=i.polygonOffset,this.polygonOffsetFactor=i.polygonOffsetFactor,this.polygonOffsetUnits=i.polygonOffsetUnits,this.dithering=i.dithering,this.alphaTest=i.alphaTest,this.alphaToCoverage=i.alphaToCoverage,this.premultipliedAlpha=i.premultipliedAlpha,this.visible=i.visible,this.toneMapped=i.toneMapped,this.userData=JSON.parse(JSON.stringify(i.userData)),this},dispose:function(){this.dispatchEvent({type:"dispose"})}});Object.defineProperty(se.prototype,"needsUpdate",{set:function(i){i===!0&&this.version++}});const Ad={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},fi={h:0,s:0,l:0},to={h:0,s:0,l:0};function dc(i,t,e){return e<0&&(e+=1),e>1&&(e-=1),e<1/6?i+(t-i)*6*e:e<1/2?t:e<2/3?i+(t-i)*6*(2/3-e):i}function fc(i){return i<.04045?i*.0773993808:Math.pow(i*.9478672986+.0521327014,2.4)}function pc(i){return i<.0031308?i*12.92:1.055*Math.pow(i,.41666)-.055}class zt{constructor(t,e,n){return e===void 0&&n===void 0?this.set(t):this.setRGB(t,e,n)}set(t){return t&&t.isColor?this.copy(t):typeof t=="number"?this.setHex(t):typeof t=="string"&&this.setStyle(t),this}setScalar(t){return this.r=t,this.g=t,this.b=t,this}setHex(t){return t=Math.floor(t),this.r=(t>>16&255)/255,this.g=(t>>8&255)/255,this.b=(t&255)/255,this}setRGB(t,e,n){return this.r=t,this.g=e,this.b=n,this}setHSL(t,e,n){if(t=Ot.euclideanModulo(t,1),e=Ot.clamp(e,0,1),n=Ot.clamp(n,0,1),e===0)this.r=this.g=this.b=n;else{const r=n<=.5?n*(1+e):n+e-n*e,s=2*n-r;this.r=dc(s,r,t+1/3),this.g=dc(s,r,t),this.b=dc(s,r,t-1/3)}return this}setStyle(t){function e(r){r!==void 0&&parseFloat(r)<1&&console.warn("THREE.Color: Alpha component of "+t+" will be ignored.")}let n;if(n=/^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t)){let r;const s=n[1],a=n[2];switch(s){case"rgb":case"rgba":if(r=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return this.r=Math.min(255,parseInt(r[1],10))/255,this.g=Math.min(255,parseInt(r[2],10))/255,this.b=Math.min(255,parseInt(r[3],10))/255,e(r[4]),this;if(r=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return this.r=Math.min(100,parseInt(r[1],10))/100,this.g=Math.min(100,parseInt(r[2],10))/100,this.b=Math.min(100,parseInt(r[3],10))/100,e(r[4]),this;break;case"hsl":case"hsla":if(r=/^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)){const o=parseFloat(r[1])/360,l=parseInt(r[2],10)/100,c=parseInt(r[3],10)/100;return e(r[4]),this.setHSL(o,l,c)}break}}else if(n=/^\#([A-Fa-f\d]+)$/.exec(t)){const r=n[1],s=r.length;if(s===3)return this.r=parseInt(r.charAt(0)+r.charAt(0),16)/255,this.g=parseInt(r.charAt(1)+r.charAt(1),16)/255,this.b=parseInt(r.charAt(2)+r.charAt(2),16)/255,this;if(s===6)return this.r=parseInt(r.charAt(0)+r.charAt(1),16)/255,this.g=parseInt(r.charAt(2)+r.charAt(3),16)/255,this.b=parseInt(r.charAt(4)+r.charAt(5),16)/255,this}return t&&t.length>0?this.setColorName(t):this}setColorName(t){const e=Ad[t];return e!==void 0?this.setHex(e):console.warn("THREE.Color: Unknown color "+t),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(t){return this.r=t.r,this.g=t.g,this.b=t.b,this}copyGammaToLinear(t,e=2){return this.r=Math.pow(t.r,e),this.g=Math.pow(t.g,e),this.b=Math.pow(t.b,e),this}copyLinearToGamma(t,e=2){const n=e>0?1/e:1;return this.r=Math.pow(t.r,n),this.g=Math.pow(t.g,n),this.b=Math.pow(t.b,n),this}convertGammaToLinear(t){return this.copyGammaToLinear(this,t),this}convertLinearToGamma(t){return this.copyLinearToGamma(this,t),this}copySRGBToLinear(t){return this.r=fc(t.r),this.g=fc(t.g),this.b=fc(t.b),this}copyLinearToSRGB(t){return this.r=pc(t.r),this.g=pc(t.g),this.b=pc(t.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(){return this.r*255<<16^this.g*255<<8^this.b*255<<0}getHexString(){return("000000"+this.getHex().toString(16)).slice(-6)}getHSL(t){t===void 0&&(console.warn("THREE.Color: .getHSL() target is now required"),t={h:0,s:0,l:0});const e=this.r,n=this.g,r=this.b,s=Math.max(e,n,r),a=Math.min(e,n,r);let o,l;const c=(a+s)/2;if(a===s)o=0,l=0;else{const h=s-a;switch(l=c<=.5?h/(s+a):h/(2-s-a),s){case e:o=(n-r)/h+(n<r?6:0);break;case n:o=(r-e)/h+2;break;case r:o=(e-n)/h+4;break}o/=6}return t.h=o,t.s=l,t.l=c,t}getStyle(){return"rgb("+(this.r*255|0)+","+(this.g*255|0)+","+(this.b*255|0)+")"}offsetHSL(t,e,n){return this.getHSL(fi),fi.h+=t,fi.s+=e,fi.l+=n,this.setHSL(fi.h,fi.s,fi.l),this}add(t){return this.r+=t.r,this.g+=t.g,this.b+=t.b,this}addColors(t,e){return this.r=t.r+e.r,this.g=t.g+e.g,this.b=t.b+e.b,this}addScalar(t){return this.r+=t,this.g+=t,this.b+=t,this}sub(t){return this.r=Math.max(0,this.r-t.r),this.g=Math.max(0,this.g-t.g),this.b=Math.max(0,this.b-t.b),this}multiply(t){return this.r*=t.r,this.g*=t.g,this.b*=t.b,this}multiplyScalar(t){return this.r*=t,this.g*=t,this.b*=t,this}lerp(t,e){return this.r+=(t.r-this.r)*e,this.g+=(t.g-this.g)*e,this.b+=(t.b-this.b)*e,this}lerpColors(t,e,n){return this.r=t.r+(e.r-t.r)*n,this.g=t.g+(e.g-t.g)*n,this.b=t.b+(e.b-t.b)*n,this}lerpHSL(t,e){this.getHSL(fi),t.getHSL(to);const n=Ot.lerp(fi.h,to.h,e),r=Ot.lerp(fi.s,to.s,e),s=Ot.lerp(fi.l,to.l,e);return this.setHSL(n,r,s),this}equals(t){return t.r===this.r&&t.g===this.g&&t.b===this.b}fromArray(t,e=0){return this.r=t[e],this.g=t[e+1],this.b=t[e+2],this}toArray(t=[],e=0){return t[e]=this.r,t[e+1]=this.g,t[e+2]=this.b,t}fromBufferAttribute(t,e){return this.r=t.getX(e),this.g=t.getY(e),this.b=t.getZ(e),t.normalized===!0&&(this.r/=255,this.g/=255,this.b/=255),this}toJSON(){return this.getHex()}}zt.NAMES=Ad;zt.prototype.isColor=!0;zt.prototype.r=1;zt.prototype.g=1;zt.prototype.b=1;class mc extends se{constructor(t){super();this.type="MeshBasicMaterial",this.color=new zt(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=Ua,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.skinning=t.skinning,this.morphTargets=t.morphTargets,this}}mc.prototype.isMeshBasicMaterial=!0;const Qt=new U,eo=new lt;function Gt(i,t,e){if(Array.isArray(i))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.name="",this.array=i,this.itemSize=t,this.count=i!==void 0?i.length/t:0,this.normalized=e===!0,this.usage=Bs,this.updateRange={offset:0,count:-1},this.version=0}Object.defineProperty(Gt.prototype,"needsUpdate",{set:function(i){i===!0&&this.version++}});Object.assign(Gt.prototype,{isBufferAttribute:!0,onUploadCallback:function(){},setUsage:function(i){return this.usage=i,this},copy:function(i){return this.name=i.name,this.array=new i.array.constructor(i.array),this.itemSize=i.itemSize,this.count=i.count,this.normalized=i.normalized,this.usage=i.usage,this},copyAt:function(i,t,e){i*=this.itemSize,e*=t.itemSize;for(let n=0,r=this.itemSize;n<r;n++)this.array[i+n]=t.array[e+n];return this},copyArray:function(i){return this.array.set(i),this},copyColorsArray:function(i){const t=this.array;let e=0;for(let n=0,r=i.length;n<r;n++){let s=i[n];s===void 0&&(console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined",n),s=new zt),t[e++]=s.r,t[e++]=s.g,t[e++]=s.b}return this},copyVector2sArray:function(i){const t=this.array;let e=0;for(let n=0,r=i.length;n<r;n++){let s=i[n];s===void 0&&(console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined",n),s=new lt),t[e++]=s.x,t[e++]=s.y}return this},copyVector3sArray:function(i){const t=this.array;let e=0;for(let n=0,r=i.length;n<r;n++){let s=i[n];s===void 0&&(console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined",n),s=new U),t[e++]=s.x,t[e++]=s.y,t[e++]=s.z}return this},copyVector4sArray:function(i){const t=this.array;let e=0;for(let n=0,r=i.length;n<r;n++){let s=i[n];s===void 0&&(console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined",n),s=new Yt),t[e++]=s.x,t[e++]=s.y,t[e++]=s.z,t[e++]=s.w}return this},applyMatrix3:function(i){if(this.itemSize===2)for(let t=0,e=this.count;t<e;t++)eo.fromBufferAttribute(this,t),eo.applyMatrix3(i),this.setXY(t,eo.x,eo.y);else if(this.itemSize===3)for(let t=0,e=this.count;t<e;t++)Qt.fromBufferAttribute(this,t),Qt.applyMatrix3(i),this.setXYZ(t,Qt.x,Qt.y,Qt.z);return this},applyMatrix4:function(i){for(let t=0,e=this.count;t<e;t++)Qt.x=this.getX(t),Qt.y=this.getY(t),Qt.z=this.getZ(t),Qt.applyMatrix4(i),this.setXYZ(t,Qt.x,Qt.y,Qt.z);return this},applyNormalMatrix:function(i){for(let t=0,e=this.count;t<e;t++)Qt.x=this.getX(t),Qt.y=this.getY(t),Qt.z=this.getZ(t),Qt.applyNormalMatrix(i),this.setXYZ(t,Qt.x,Qt.y,Qt.z);return this},transformDirection:function(i){for(let t=0,e=this.count;t<e;t++)Qt.x=this.getX(t),Qt.y=this.getY(t),Qt.z=this.getZ(t),Qt.transformDirection(i),this.setXYZ(t,Qt.x,Qt.y,Qt.z);return this},set:function(i,t=0){return this.array.set(i,t),this},getX:function(i){return this.array[i*this.itemSize]},setX:function(i,t){return this.array[i*this.itemSize]=t,this},getY:function(i){return this.array[i*this.itemSize+1]},setY:function(i,t){return this.array[i*this.itemSize+1]=t,this},getZ:function(i){return this.array[i*this.itemSize+2]},setZ:function(i,t){return this.array[i*this.itemSize+2]=t,this},getW:function(i){return this.array[i*this.itemSize+3]},setW:function(i,t){return this.array[i*this.itemSize+3]=t,this},setXY:function(i,t,e){return i*=this.itemSize,this.array[i+0]=t,this.array[i+1]=e,this},setXYZ:function(i,t,e,n){return i*=this.itemSize,this.array[i+0]=t,this.array[i+1]=e,this.array[i+2]=n,this},setXYZW:function(i,t,e,n,r){return i*=this.itemSize,this.array[i+0]=t,this.array[i+1]=e,this.array[i+2]=n,this.array[i+3]=r,this},onUpload:function(i){return this.onUploadCallback=i,this},clone:function(){return new this.constructor(this.array,this.itemSize).copy(this)},toJSON:function(){const i={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.prototype.slice.call(this.array),normalized:this.normalized};return this.name!==""&&(i.name=this.name),this.usage!==Bs&&(i.usage=this.usage),(this.updateRange.offset!==0||this.updateRange.count!==-1)&&(i.updateRange=this.updateRange),i}});function gc(i,t,e){Gt.call(this,new Int8Array(i),t,e)}gc.prototype=Object.create(Gt.prototype);gc.prototype.constructor=gc;function xc(i,t,e){Gt.call(this,new Uint8Array(i),t,e)}xc.prototype=Object.create(Gt.prototype);xc.prototype.constructor=xc;function yc(i,t,e){Gt.call(this,new Uint8ClampedArray(i),t,e)}yc.prototype=Object.create(Gt.prototype);yc.prototype.constructor=yc;function _c(i,t,e){Gt.call(this,new Int16Array(i),t,e)}_c.prototype=Object.create(Gt.prototype);_c.prototype.constructor=_c;function ks(i,t,e){Gt.call(this,new Uint16Array(i),t,e)}ks.prototype=Object.create(Gt.prototype);ks.prototype.constructor=ks;function vc(i,t,e){Gt.call(this,new Int32Array(i),t,e)}vc.prototype=Object.create(Gt.prototype);vc.prototype.constructor=vc;function Vs(i,t,e){Gt.call(this,new Uint32Array(i),t,e)}Vs.prototype=Object.create(Gt.prototype);Vs.prototype.constructor=Vs;function io(i,t,e){Gt.call(this,new Uint16Array(i),t,e)}io.prototype=Object.create(Gt.prototype);io.prototype.constructor=io;io.prototype.isFloat16BufferAttribute=!0;function ie(i,t,e){Gt.call(this,new Float32Array(i),t,e)}ie.prototype=Object.create(Gt.prototype);ie.prototype.constructor=ie;function Mc(i,t,e){Gt.call(this,new Float64Array(i),t,e)}Mc.prototype=Object.create(Gt.prototype);Mc.prototype.constructor=Mc;function Td(i){if(i.length===0)return-1/0;let t=i[0];for(let e=1,n=i.length;e<n;++e)i[e]>t&&(t=i[e]);return t}let m0=0;const Ri=new It,bc=new Bt,Ar=new U,Ye=new ii,Ws=new ii,_e=new U;function $t(){Object.defineProperty(this,"id",{value:m0++}),this.uuid=Ot.generateUUID(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}$t.prototype=Object.assign(Object.create(Ti.prototype),{constructor:$t,isBufferGeometry:!0,getIndex:function(){return this.index},setIndex:function(i){return Array.isArray(i)?this.index=new(Td(i)>65535?Vs:ks)(i,1):this.index=i,this},getAttribute:function(i){return this.attributes[i]},setAttribute:function(i,t){return this.attributes[i]=t,this},deleteAttribute:function(i){return delete this.attributes[i],this},hasAttribute:function(i){return this.attributes[i]!==void 0},addGroup:function(i,t,e=0){this.groups.push({start:i,count:t,materialIndex:e})},clearGroups:function(){this.groups=[]},setDrawRange:function(i,t){this.drawRange.start=i,this.drawRange.count=t},applyMatrix4:function(i){const t=this.attributes.position;t!==void 0&&(t.applyMatrix4(i),t.needsUpdate=!0);const e=this.attributes.normal;if(e!==void 0){const r=new Se().getNormalMatrix(i);e.applyNormalMatrix(r),e.needsUpdate=!0}const n=this.attributes.tangent;return n!==void 0&&(n.transformDirection(i),n.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this},rotateX:function(i){return Ri.makeRotationX(i),this.applyMatrix4(Ri),this},rotateY:function(i){return Ri.makeRotationY(i),this.applyMatrix4(Ri),this},rotateZ:function(i){return Ri.makeRotationZ(i),this.applyMatrix4(Ri),this},translate:function(i,t,e){return Ri.makeTranslation(i,t,e),this.applyMatrix4(Ri),this},scale:function(i,t,e){return Ri.makeScale(i,t,e),this.applyMatrix4(Ri),this},lookAt:function(i){return bc.lookAt(i),bc.updateMatrix(),this.applyMatrix4(bc.matrix),this},center:function(){return this.computeBoundingBox(),this.boundingBox.getCenter(Ar).negate(),this.translate(Ar.x,Ar.y,Ar.z),this},setFromPoints:function(i){const t=[];for(let e=0,n=i.length;e<n;e++){const r=i[e];t.push(r.x,r.y,r.z||0)}return this.setAttribute("position",new ie(t,3)),this},computeBoundingBox:function(){this.boundingBox===null&&(this.boundingBox=new ii);const i=this.attributes.position,t=this.morphAttributes.position;if(i&&i.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingBox.set(new U(-1/0,-1/0,-1/0),new U(1/0,1/0,1/0));return}if(i!==void 0){if(this.boundingBox.setFromBufferAttribute(i),t)for(let e=0,n=t.length;e<n;e++){const r=t[e];Ye.setFromBufferAttribute(r),this.morphTargetsRelative?(_e.addVectors(this.boundingBox.min,Ye.min),this.boundingBox.expandByPoint(_e),_e.addVectors(this.boundingBox.max,Ye.max),this.boundingBox.expandByPoint(_e)):(this.boundingBox.expandByPoint(Ye.min),this.boundingBox.expandByPoint(Ye.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)},computeBoundingSphere:function(){this.boundingSphere===null&&(this.boundingSphere=new vr);const i=this.attributes.position,t=this.morphAttributes.position;if(i&&i.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingSphere.set(new U,1/0);return}if(i){const e=this.boundingSphere.center;if(Ye.setFromBufferAttribute(i),t)for(let r=0,s=t.length;r<s;r++){const a=t[r];Ws.setFromBufferAttribute(a),this.morphTargetsRelative?(_e.addVectors(Ye.min,Ws.min),Ye.expandByPoint(_e),_e.addVectors(Ye.max,Ws.max),Ye.expandByPoint(_e)):(Ye.expandByPoint(Ws.min),Ye.expandByPoint(Ws.max))}Ye.getCenter(e);let n=0;for(let r=0,s=i.count;r<s;r++)_e.fromBufferAttribute(i,r),n=Math.max(n,e.distanceToSquared(_e));if(t)for(let r=0,s=t.length;r<s;r++){const a=t[r],o=this.morphTargetsRelative;for(let l=0,c=a.count;l<c;l++)_e.fromBufferAttribute(a,l),o&&(Ar.fromBufferAttribute(i,l),_e.add(Ar)),n=Math.max(n,e.distanceToSquared(_e))}this.boundingSphere.radius=Math.sqrt(n),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}},computeFaceNormals:function(){},computeTangents:function(){const i=this.index,t=this.attributes;if(i===null||t.position===void 0||t.normal===void 0||t.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const e=i.array,n=t.position.array,r=t.normal.array,s=t.uv.array,a=n.length/3;t.tangent===void 0&&this.setAttribute("tangent",new Gt(new Float32Array(4*a),4));const o=t.tangent.array,l=[],c=[];for(let N=0;N<a;N++)l[N]=new U,c[N]=new U;const h=new U,u=new U,d=new U,f=new lt,p=new lt,x=new lt,y=new U,g=new U;function m(N,G,D){h.fromArray(n,N*3),u.fromArray(n,G*3),d.fromArray(n,D*3),f.fromArray(s,N*2),p.fromArray(s,G*2),x.fromArray(s,D*2),u.sub(h),d.sub(h),p.sub(f),x.sub(f);const V=1/(p.x*x.y-x.x*p.y);!isFinite(V)||(y.copy(u).multiplyScalar(x.y).addScaledVector(d,-p.y).multiplyScalar(V),g.copy(d).multiplyScalar(p.x).addScaledVector(u,-x.x).multiplyScalar(V),l[N].add(y),l[G].add(y),l[D].add(y),c[N].add(g),c[G].add(g),c[D].add(g))}let E=this.groups;E.length===0&&(E=[{start:0,count:e.length}]);for(let N=0,G=E.length;N<G;++N){const D=E[N],V=D.start,R=D.count;for(let L=V,P=V+R;L<P;L+=3)m(e[L+0],e[L+1],e[L+2])}const w=new U,S=new U,_=new U,T=new U;function B(N){_.fromArray(r,N*3),T.copy(_);const G=l[N];w.copy(G),w.sub(_.multiplyScalar(_.dot(G))).normalize(),S.crossVectors(T,G);const V=S.dot(c[N])<0?-1:1;o[N*4]=w.x,o[N*4+1]=w.y,o[N*4+2]=w.z,o[N*4+3]=V}for(let N=0,G=E.length;N<G;++N){const D=E[N],V=D.start,R=D.count;for(let L=V,P=V+R;L<P;L+=3)B(e[L+0]),B(e[L+1]),B(e[L+2])}},computeVertexNormals:function(){const i=this.index,t=this.getAttribute("position");if(t!==void 0){let e=this.getAttribute("normal");if(e===void 0)e=new Gt(new Float32Array(t.count*3),3),this.setAttribute("normal",e);else for(let u=0,d=e.count;u<d;u++)e.setXYZ(u,0,0,0);const n=new U,r=new U,s=new U,a=new U,o=new U,l=new U,c=new U,h=new U;if(i)for(let u=0,d=i.count;u<d;u+=3){const f=i.getX(u+0),p=i.getX(u+1),x=i.getX(u+2);n.fromBufferAttribute(t,f),r.fromBufferAttribute(t,p),s.fromBufferAttribute(t,x),c.subVectors(s,r),h.subVectors(n,r),c.cross(h),a.fromBufferAttribute(e,f),o.fromBufferAttribute(e,p),l.fromBufferAttribute(e,x),a.add(c),o.add(c),l.add(c),e.setXYZ(f,a.x,a.y,a.z),e.setXYZ(p,o.x,o.y,o.z),e.setXYZ(x,l.x,l.y,l.z)}else for(let u=0,d=t.count;u<d;u+=3)n.fromBufferAttribute(t,u+0),r.fromBufferAttribute(t,u+1),s.fromBufferAttribute(t,u+2),c.subVectors(s,r),h.subVectors(n,r),c.cross(h),e.setXYZ(u+0,c.x,c.y,c.z),e.setXYZ(u+1,c.x,c.y,c.z),e.setXYZ(u+2,c.x,c.y,c.z);this.normalizeNormals(),e.needsUpdate=!0}},merge:function(i,t){if(!(i&&i.isBufferGeometry)){console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",i);return}t===void 0&&(t=0,console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));const e=this.attributes;for(const n in e){if(i.attributes[n]===void 0)continue;const s=e[n].array,a=i.attributes[n],o=a.array,l=a.itemSize*t,c=Math.min(o.length,s.length-l);for(let h=0,u=l;h<c;h++,u++)s[u]=o[h]}return this},normalizeNormals:function(){const i=this.attributes.normal;for(let t=0,e=i.count;t<e;t++)_e.fromBufferAttribute(i,t),_e.normalize(),i.setXYZ(t,_e.x,_e.y,_e.z)},toNonIndexed:function(){function i(a,o){const l=a.array,c=a.itemSize,h=a.normalized,u=new l.constructor(o.length*c);let d=0,f=0;for(let p=0,x=o.length;p<x;p++){d=o[p]*c;for(let y=0;y<c;y++)u[f++]=l[d++]}return new Gt(u,c,h)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const t=new $t,e=this.index.array,n=this.attributes;for(const a in n){const o=n[a],l=i(o,e);t.setAttribute(a,l)}const r=this.morphAttributes;for(const a in r){const o=[],l=r[a];for(let c=0,h=l.length;c<h;c++){const u=l[c],d=i(u,e);o.push(d)}t.morphAttributes[a]=o}t.morphTargetsRelative=this.morphTargetsRelative;const s=this.groups;for(let a=0,o=s.length;a<o;a++){const l=s[a];t.addGroup(l.start,l.count,l.materialIndex)}return t},toJSON:function(){const i={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(i.uuid=this.uuid,i.type=this.type,this.name!==""&&(i.name=this.name),Object.keys(this.userData).length>0&&(i.userData=this.userData),this.parameters!==void 0){const o=this.parameters;for(const l in o)o[l]!==void 0&&(i[l]=o[l]);return i}i.data={attributes:{}};const t=this.index;t!==null&&(i.data.index={type:t.array.constructor.name,array:Array.prototype.slice.call(t.array)});const e=this.attributes;for(const o in e){const l=e[o];i.data.attributes[o]=l.toJSON(i.data)}const n={};let r=!1;for(const o in this.morphAttributes){const l=this.morphAttributes[o],c=[];for(let h=0,u=l.length;h<u;h++){const d=l[h];c.push(d.toJSON(i.data))}c.length>0&&(n[o]=c,r=!0)}r&&(i.data.morphAttributes=n,i.data.morphTargetsRelative=this.morphTargetsRelative);const s=this.groups;s.length>0&&(i.data.groups=JSON.parse(JSON.stringify(s)));const a=this.boundingSphere;return a!==null&&(i.data.boundingSphere={center:a.center.toArray(),radius:a.radius}),i},clone:function(){return new $t().copy(this)},copy:function(i){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const t={};this.name=i.name;const e=i.index;e!==null&&this.setIndex(e.clone(t));const n=i.attributes;for(const l in n){const c=n[l];this.setAttribute(l,c.clone(t))}const r=i.morphAttributes;for(const l in r){const c=[],h=r[l];for(let u=0,d=h.length;u<d;u++)c.push(h[u].clone(t));this.morphAttributes[l]=c}this.morphTargetsRelative=i.morphTargetsRelative;const s=i.groups;for(let l=0,c=s.length;l<c;l++){const h=s[l];this.addGroup(h.start,h.count,h.materialIndex)}const a=i.boundingBox;a!==null&&(this.boundingBox=a.clone());const o=i.boundingSphere;return o!==null&&(this.boundingSphere=o.clone()),this.drawRange.start=i.drawRange.start,this.drawRange.count=i.drawRange.count,this.userData=i.userData,this},dispose:function(){this.dispatchEvent({type:"dispose"})}});const Ld=new It,Tr=new Yn,wc=new vr,gn=new U,xn=new U,yn=new U,Sc=new U,Ec=new U,Ac=new U,no=new U,ro=new U,so=new U,ao=new lt,oo=new lt,lo=new lt,Tc=new U,co=new U;function Te(i=new $t,t=new mc){Bt.call(this),this.type="Mesh",this.geometry=i,this.material=t,this.updateMorphTargets()}Te.prototype=Object.assign(Object.create(Bt.prototype),{constructor:Te,isMesh:!0,copy:function(i){return Bt.prototype.copy.call(this,i),i.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=i.morphTargetInfluences.slice()),i.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},i.morphTargetDictionary)),this.material=i.material,this.geometry=i.geometry,this},updateMorphTargets:function(){const i=this.geometry;if(i.isBufferGeometry){const t=i.morphAttributes,e=Object.keys(t);if(e.length>0){const n=t[e[0]];if(n!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,s=n.length;r<s;r++){const a=n[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=r}}}}else{const t=i.morphTargets;t!==void 0&&t.length>0&&console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}},raycast:function(i,t){const e=this.geometry,n=this.material,r=this.matrixWorld;if(n===void 0||(e.boundingSphere===null&&e.computeBoundingSphere(),wc.copy(e.boundingSphere),wc.applyMatrix4(r),i.ray.intersectsSphere(wc)===!1)||(Ld.copy(r).invert(),Tr.copy(i.ray).applyMatrix4(Ld),e.boundingBox!==null&&Tr.intersectsBox(e.boundingBox)===!1))return;let s;if(e.isBufferGeometry){const a=e.index,o=e.attributes.position,l=e.morphAttributes.position,c=e.morphTargetsRelative,h=e.attributes.uv,u=e.attributes.uv2,d=e.groups,f=e.drawRange;if(a!==null)if(Array.isArray(n))for(let p=0,x=d.length;p<x;p++){const y=d[p],g=n[y.materialIndex],m=Math.max(y.start,f.start),E=Math.min(y.start+y.count,f.start+f.count);for(let w=m,S=E;w<S;w+=3){const _=a.getX(w),T=a.getX(w+1),B=a.getX(w+2);s=ho(this,g,i,Tr,o,l,c,h,u,_,T,B),s&&(s.faceIndex=Math.floor(w/3),s.face.materialIndex=y.materialIndex,t.push(s))}}else{const p=Math.max(0,f.start),x=Math.min(a.count,f.start+f.count);for(let y=p,g=x;y<g;y+=3){const m=a.getX(y),E=a.getX(y+1),w=a.getX(y+2);s=ho(this,n,i,Tr,o,l,c,h,u,m,E,w),s&&(s.faceIndex=Math.floor(y/3),t.push(s))}}else if(o!==void 0)if(Array.isArray(n))for(let p=0,x=d.length;p<x;p++){const y=d[p],g=n[y.materialIndex],m=Math.max(y.start,f.start),E=Math.min(y.start+y.count,f.start+f.count);for(let w=m,S=E;w<S;w+=3){const _=w,T=w+1,B=w+2;s=ho(this,g,i,Tr,o,l,c,h,u,_,T,B),s&&(s.faceIndex=Math.floor(w/3),s.face.materialIndex=y.materialIndex,t.push(s))}}else{const p=Math.max(0,f.start),x=Math.min(o.count,f.start+f.count);for(let y=p,g=x;y<g;y+=3){const m=y,E=y+1,w=y+2;s=ho(this,n,i,Tr,o,l,c,h,u,m,E,w),s&&(s.faceIndex=Math.floor(y/3),t.push(s))}}}else e.isGeometry&&console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}});function g0(i,t,e,n,r,s,a,o){let l;if(t.side===ye?l=n.intersectTriangle(a,s,r,!0,o):l=n.intersectTriangle(r,s,a,t.side!==Oa,o),l===null)return null;co.copy(o),co.applyMatrix4(i.matrixWorld);const c=e.ray.origin.distanceTo(co);return c<e.near||c>e.far?null:{distance:c,point:co.clone(),object:i}}function ho(i,t,e,n,r,s,a,o,l,c,h,u){gn.fromBufferAttribute(r,c),xn.fromBufferAttribute(r,h),yn.fromBufferAttribute(r,u);const d=i.morphTargetInfluences;if(t.morphTargets&&s&&d){no.set(0,0,0),ro.set(0,0,0),so.set(0,0,0);for(let p=0,x=s.length;p<x;p++){const y=d[p],g=s[p];y!==0&&(Sc.fromBufferAttribute(g,c),Ec.fromBufferAttribute(g,h),Ac.fromBufferAttribute(g,u),a?(no.addScaledVector(Sc,y),ro.addScaledVector(Ec,y),so.addScaledVector(Ac,y)):(no.addScaledVector(Sc.sub(gn),y),ro.addScaledVector(Ec.sub(xn),y),so.addScaledVector(Ac.sub(yn),y)))}gn.add(no),xn.add(ro),yn.add(so)}i.isSkinnedMesh&&t.skinning&&(i.boneTransform(c,gn),i.boneTransform(h,xn),i.boneTransform(u,yn));const f=g0(i,t,e,n,gn,xn,yn,Tc);if(f){o&&(ao.fromBufferAttribute(o,c),oo.fromBufferAttribute(o,h),lo.fromBufferAttribute(o,u),f.uv=ce.getUV(Tc,gn,xn,yn,ao,oo,lo,new lt)),l&&(ao.fromBufferAttribute(l,c),oo.fromBufferAttribute(l,h),lo.fromBufferAttribute(l,u),f.uv2=ce.getUV(Tc,gn,xn,yn,ao,oo,lo,new lt));const p={a:c,b:h,c:u,normal:new U,materialIndex:0};ce.getNormal(gn,xn,yn,p.normal),f.face=p}return f}class Lc extends $t{constructor(t=1,e=1,n=1,r=1,s=1,a=1){super();this.type="BoxGeometry",this.parameters={width:t,height:e,depth:n,widthSegments:r,heightSegments:s,depthSegments:a};const o=this;r=Math.floor(r),s=Math.floor(s),a=Math.floor(a);const l=[],c=[],h=[],u=[];let d=0,f=0;p("z","y","x",-1,-1,n,e,t,a,s,0),p("z","y","x",1,-1,n,e,-t,a,s,1),p("x","z","y",1,1,t,n,e,r,a,2),p("x","z","y",1,-1,t,n,-e,r,a,3),p("x","y","z",1,-1,t,e,n,r,s,4),p("x","y","z",-1,-1,t,e,-n,r,s,5),this.setIndex(l),this.setAttribute("position",new ie(c,3)),this.setAttribute("normal",new ie(h,3)),this.setAttribute("uv",new ie(u,2));function p(x,y,g,m,E,w,S,_,T,B,N){const G=w/T,D=S/B,V=w/2,R=S/2,L=_/2,P=T+1,F=B+1;let W=0,j=0;const Y=new U;for(let Q=0;Q<F;Q++){const K=Q*D-R;for(let st=0;st<P;st++){const ct=st*G-V;Y[x]=ct*m,Y[y]=K*E,Y[g]=L,c.push(Y.x,Y.y,Y.z),Y[x]=0,Y[y]=0,Y[g]=_>0?1:-1,h.push(Y.x,Y.y,Y.z),u.push(st/T),u.push(1-Q/B),W+=1}}for(let Q=0;Q<B;Q++)for(let K=0;K<T;K++){const st=d+K+P*Q,ct=d+K+P*(Q+1),z=d+(K+1)+P*(Q+1),Et=d+(K+1)+P*Q;l.push(st,ct,Et),l.push(ct,z,Et),j+=6}o.addGroup(f,j,N),f+=j,d+=W}}}function Lr(i){const t={};for(const e in i){t[e]={};for(const n in i[e]){const r=i[e][n];r&&(r.isColor||r.isMatrix3||r.isMatrix4||r.isVector2||r.isVector3||r.isVector4||r.isTexture||r.isQuaternion)?t[e][n]=r.clone():Array.isArray(r)?t[e][n]=r.slice():t[e][n]=r}}return t}function Pe(i){const t={};for(let e=0;e<i.length;e++){const n=Lr(i[e]);for(const r in n)t[r]=n[r]}return t}const x0={clone:Lr,merge:Pe};var y0=`void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,_0=`void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;function ni(i){se.call(this),this.type="ShaderMaterial",this.defines={},this.uniforms={},this.vertexShader=y0,this.fragmentShader=_0,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,i!==void 0&&(i.attributes!==void 0&&console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),this.setValues(i))}ni.prototype=Object.create(se.prototype);ni.prototype.constructor=ni;ni.prototype.isShaderMaterial=!0;ni.prototype.copy=function(i){return se.prototype.copy.call(this,i),this.fragmentShader=i.fragmentShader,this.vertexShader=i.vertexShader,this.uniforms=Lr(i.uniforms),this.defines=Object.assign({},i.defines),this.wireframe=i.wireframe,this.wireframeLinewidth=i.wireframeLinewidth,this.lights=i.lights,this.clipping=i.clipping,this.skinning=i.skinning,this.morphTargets=i.morphTargets,this.morphNormals=i.morphNormals,this.extensions=Object.assign({},i.extensions),this.glslVersion=i.glslVersion,this};ni.prototype.toJSON=function(i){const t=se.prototype.toJSON.call(this,i);t.glslVersion=this.glslVersion,t.uniforms={};for(const n in this.uniforms){const s=this.uniforms[n].value;s&&s.isTexture?t.uniforms[n]={type:"t",value:s.toJSON(i).uuid}:s&&s.isColor?t.uniforms[n]={type:"c",value:s.getHex()}:s&&s.isVector2?t.uniforms[n]={type:"v2",value:s.toArray()}:s&&s.isVector3?t.uniforms[n]={type:"v3",value:s.toArray()}:s&&s.isVector4?t.uniforms[n]={type:"v4",value:s.toArray()}:s&&s.isMatrix3?t.uniforms[n]={type:"m3",value:s.toArray()}:s&&s.isMatrix4?t.uniforms[n]={type:"m4",value:s.toArray()}:t.uniforms[n]={value:s}}Object.keys(this.defines).length>0&&(t.defines=this.defines),t.vertexShader=this.vertexShader,t.fragmentShader=this.fragmentShader;const e={};for(const n in this.extensions)this.extensions[n]===!0&&(e[n]=!0);return Object.keys(e).length>0&&(t.extensions=e),t};function Rr(){Bt.call(this),this.type="Camera",this.matrixWorldInverse=new It,this.projectionMatrix=new It,this.projectionMatrixInverse=new It}Rr.prototype=Object.assign(Object.create(Bt.prototype),{constructor:Rr,isCamera:!0,copy:function(i,t){return Bt.prototype.copy.call(this,i,t),this.matrixWorldInverse.copy(i.matrixWorldInverse),this.projectionMatrix.copy(i.projectionMatrix),this.projectionMatrixInverse.copy(i.projectionMatrixInverse),this},getWorldDirection:function(i){i===void 0&&(console.warn("THREE.Camera: .getWorldDirection() target is now required"),i=new U),this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return i.set(-t[8],-t[9],-t[10]).normalize()},updateMatrixWorld:function(i){Bt.prototype.updateMatrixWorld.call(this,i),this.matrixWorldInverse.copy(this.matrixWorld).invert()},updateWorldMatrix:function(i,t){Bt.prototype.updateWorldMatrix.call(this,i,t),this.matrixWorldInverse.copy(this.matrixWorld).invert()},clone:function(){return new this.constructor().copy(this)}});function We(i=50,t=1,e=.1,n=2e3){Rr.call(this),this.type="PerspectiveCamera",this.fov=i,this.zoom=1,this.near=e,this.far=n,this.focus=10,this.aspect=t,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}We.prototype=Object.assign(Object.create(Rr.prototype),{constructor:We,isPerspectiveCamera:!0,copy:function(i,t){return Rr.prototype.copy.call(this,i,t),this.fov=i.fov,this.zoom=i.zoom,this.near=i.near,this.far=i.far,this.focus=i.focus,this.aspect=i.aspect,this.view=i.view===null?null:Object.assign({},i.view),this.filmGauge=i.filmGauge,this.filmOffset=i.filmOffset,this},setFocalLength:function(i){const t=.5*this.getFilmHeight()/i;this.fov=Ot.RAD2DEG*2*Math.atan(t),this.updateProjectionMatrix()},getFocalLength:function(){const i=Math.tan(Ot.DEG2RAD*.5*this.fov);return .5*this.getFilmHeight()/i},getEffectiveFOV:function(){return Ot.RAD2DEG*2*Math.atan(Math.tan(Ot.DEG2RAD*.5*this.fov)/this.zoom)},getFilmWidth:function(){return this.filmGauge*Math.min(this.aspect,1)},getFilmHeight:function(){return this.filmGauge/Math.max(this.aspect,1)},setViewOffset:function(i,t,e,n,r,s){this.aspect=i/t,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=i,this.view.fullHeight=t,this.view.offsetX=e,this.view.offsetY=n,this.view.width=r,this.view.height=s,this.updateProjectionMatrix()},clearViewOffset:function(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()},updateProjectionMatrix:function(){const i=this.near;let t=i*Math.tan(Ot.DEG2RAD*.5*this.fov)/this.zoom,e=2*t,n=this.aspect*e,r=-.5*n;const s=this.view;if(this.view!==null&&this.view.enabled){const o=s.fullWidth,l=s.fullHeight;r+=s.offsetX*n/o,t-=s.offsetY*e/l,n*=s.width/o,e*=s.height/l}const a=this.filmOffset;a!==0&&(r+=i*a/this.getFilmWidth()),this.projectionMatrix.makePerspective(r,r+n,t,t-e,i,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()},toJSON:function(i){const t=Bt.prototype.toJSON.call(this,i);return t.object.fov=this.fov,t.object.zoom=this.zoom,t.object.near=this.near,t.object.far=this.far,t.object.focus=this.focus,t.object.aspect=this.aspect,this.view!==null&&(t.object.view=Object.assign({},this.view)),t.object.filmGauge=this.filmGauge,t.object.filmOffset=this.filmOffset,t}});const Cr=90,Pr=1;class Rc extends Bt{constructor(t,e,n){super();if(this.type="CubeCamera",n.isWebGLCubeRenderTarget!==!0){console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");return}this.renderTarget=n;const r=new We(Cr,Pr,t,e);r.layers=this.layers,r.up.set(0,-1,0),r.lookAt(new U(1,0,0)),this.add(r);const s=new We(Cr,Pr,t,e);s.layers=this.layers,s.up.set(0,-1,0),s.lookAt(new U(-1,0,0)),this.add(s);const a=new We(Cr,Pr,t,e);a.layers=this.layers,a.up.set(0,0,1),a.lookAt(new U(0,1,0)),this.add(a);const o=new We(Cr,Pr,t,e);o.layers=this.layers,o.up.set(0,0,-1),o.lookAt(new U(0,-1,0)),this.add(o);const l=new We(Cr,Pr,t,e);l.layers=this.layers,l.up.set(0,-1,0),l.lookAt(new U(0,0,1)),this.add(l);const c=new We(Cr,Pr,t,e);c.layers=this.layers,c.up.set(0,-1,0),c.lookAt(new U(0,0,-1)),this.add(c)}update(t,e){this.parent===null&&this.updateMatrixWorld();const n=this.renderTarget,[r,s,a,o,l,c]=this.children,h=t.xr.enabled,u=t.getRenderTarget();t.xr.enabled=!1;const d=n.texture.generateMipmaps;n.texture.generateMipmaps=!1,t.setRenderTarget(n,0),t.render(e,r),t.setRenderTarget(n,1),t.render(e,s),t.setRenderTarget(n,2),t.render(e,a),t.setRenderTarget(n,3),t.render(e,o),t.setRenderTarget(n,4),t.render(e,l),n.texture.generateMipmaps=d,t.setRenderTarget(n,5),t.render(e,c),t.setRenderTarget(u),t.xr.enabled=h}}class uo extends Ee{constructor(t,e,n,r,s,a,o,l,c,h){t=t!==void 0?t:[],e=e!==void 0?e:kl,o=o!==void 0?o:Wn;super(t,e,n,r,s,a,o,l,c,h);this._needsFlipEnvMap=!0,this.flipY=!1}get images(){return this.image}set images(t){this.image=t}}uo.prototype.isCubeTexture=!0;class Rd extends $n{constructor(t,e,n){Number.isInteger(e)&&(console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"),e=n);super(t,t,e);e=e||{},this.texture=new uo(void 0,e.mapping,e.wrapS,e.wrapT,e.magFilter,e.minFilter,e.format,e.type,e.anisotropy,e.encoding),this.texture.generateMipmaps=e.generateMipmaps!==void 0?e.generateMipmaps:!1,this.texture.minFilter=e.minFilter!==void 0?e.minFilter:be,this.texture._needsFlipEnvMap=!1}fromEquirectangularTexture(t,e){this.texture.type=e.type,this.texture.format=hi,this.texture.encoding=e.encoding,this.texture.generateMipmaps=e.generateMipmaps,this.texture.minFilter=e.minFilter,this.texture.magFilter=e.magFilter;const n={uniforms:{tEquirect:{value:null}},vertexShader:`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},r=new Lc(5,5,5),s=new ni({name:"CubemapFromEquirect",uniforms:Lr(n.uniforms),vertexShader:n.vertexShader,fragmentShader:n.fragmentShader,side:ye,blending:Ps});s.uniforms.tEquirect.value=e;const a=new Te(r,s),o=e.minFilter;return e.minFilter===Ha&&(e.minFilter=be),new Rc(1,10,this).update(t,a),e.minFilter=o,a.geometry.dispose(),a.material.dispose(),this}clear(t,e,n,r){const s=t.getRenderTarget();for(let a=0;a<6;a++)t.setRenderTarget(this,a),t.clear(e,n,r);t.setRenderTarget(s)}}Rd.prototype.isWebGLCubeRenderTarget=!0;class Cc extends Ee{constructor(t,e,n,r,s,a,o,l,c,h,u,d){super(null,a,o,l,c,h,r,s,u,d);this.image={data:t||null,width:e||1,height:n||1},this.magFilter=c!==void 0?c:Ge,this.minFilter=h!==void 0?h:Ge,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}}Cc.prototype.isDataTexture=!0;const Dr=new vr,fo=new U;class po{constructor(t=new Li,e=new Li,n=new Li,r=new Li,s=new Li,a=new Li){this.planes=[t,e,n,r,s,a]}set(t,e,n,r,s,a){const o=this.planes;return o[0].copy(t),o[1].copy(e),o[2].copy(n),o[3].copy(r),o[4].copy(s),o[5].copy(a),this}copy(t){const e=this.planes;for(let n=0;n<6;n++)e[n].copy(t.planes[n]);return this}setFromProjectionMatrix(t){const e=this.planes,n=t.elements,r=n[0],s=n[1],a=n[2],o=n[3],l=n[4],c=n[5],h=n[6],u=n[7],d=n[8],f=n[9],p=n[10],x=n[11],y=n[12],g=n[13],m=n[14],E=n[15];return e[0].setComponents(o-r,u-l,x-d,E-y).normalize(),e[1].setComponents(o+r,u+l,x+d,E+y).normalize(),e[2].setComponents(o+s,u+c,x+f,E+g).normalize(),e[3].setComponents(o-s,u-c,x-f,E-g).normalize(),e[4].setComponents(o-a,u-h,x-p,E-m).normalize(),e[5].setComponents(o+a,u+h,x+p,E+m).normalize(),this}intersectsObject(t){const e=t.geometry;return e.boundingSphere===null&&e.computeBoundingSphere(),Dr.copy(e.boundingSphere).applyMatrix4(t.matrixWorld),this.intersectsSphere(Dr)}intersectsSprite(t){return Dr.center.set(0,0,0),Dr.radius=.7071067811865476,Dr.applyMatrix4(t.matrixWorld),this.intersectsSphere(Dr)}intersectsSphere(t){const e=this.planes,n=t.center,r=-t.radius;for(let s=0;s<6;s++)if(e[s].distanceToPoint(n)<r)return!1;return!0}intersectsBox(t){const e=this.planes;for(let n=0;n<6;n++){const r=e[n];if(fo.x=r.normal.x>0?t.max.x:t.min.x,fo.y=r.normal.y>0?t.max.y:t.min.y,fo.z=r.normal.z>0?t.max.z:t.min.z,r.distanceToPoint(fo)<0)return!1}return!0}containsPoint(t){const e=this.planes;for(let n=0;n<6;n++)if(e[n].distanceToPoint(t)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}}function Cd(){let i=null,t=!1,e=null,n=null;function r(s,a){e(s,a),n=i.requestAnimationFrame(r)}return{start:function(){t!==!0&&e!==null&&(n=i.requestAnimationFrame(r),t=!0)},stop:function(){i.cancelAnimationFrame(n),t=!1},setAnimationLoop:function(s){e=s},setContext:function(s){i=s}}}function v0(i,t){const e=t.isWebGL2,n=new WeakMap;function r(c,h){const u=c.array,d=c.usage,f=i.createBuffer();i.bindBuffer(h,f),i.bufferData(h,u,d),c.onUploadCallback();let p=5126;return u instanceof Float32Array?p=5126:u instanceof Float64Array?console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."):u instanceof Uint16Array?c.isFloat16BufferAttribute?e?p=5131:console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."):p=5123:u instanceof Int16Array?p=5122:u instanceof Uint32Array?p=5125:u instanceof Int32Array?p=5124:u instanceof Int8Array?p=5120:u instanceof Uint8Array&&(p=5121),{buffer:f,type:p,bytesPerElement:u.BYTES_PER_ELEMENT,version:c.version}}function s(c,h,u){const d=h.array,f=h.updateRange;i.bindBuffer(u,c),f.count===-1?i.bufferSubData(u,0,d):(e?i.bufferSubData(u,f.offset*d.BYTES_PER_ELEMENT,d,f.offset,f.count):i.bufferSubData(u,f.offset*d.BYTES_PER_ELEMENT,d.subarray(f.offset,f.offset+f.count)),f.count=-1)}function a(c){return c.isInterleavedBufferAttribute&&(c=c.data),n.get(c)}function o(c){c.isInterleavedBufferAttribute&&(c=c.data);const h=n.get(c);h&&(i.deleteBuffer(h.buffer),n.delete(c))}function l(c,h){if(c.isGLBufferAttribute){const d=n.get(c);(!d||d.version<c.version)&&n.set(c,{buffer:c.buffer,type:c.type,bytesPerElement:c.elementSize,version:c.version});return}c.isInterleavedBufferAttribute&&(c=c.data);const u=n.get(c);u===void 0?n.set(c,r(c,h)):u.version<c.version&&(s(u.buffer,c,h),u.version=c.version)}return{get:a,remove:o,update:l}}class M0 extends $t{constructor(t=1,e=1,n=1,r=1){super();this.type="PlaneGeometry",this.parameters={width:t,height:e,widthSegments:n,heightSegments:r};const s=t/2,a=e/2,o=Math.floor(n),l=Math.floor(r),c=o+1,h=l+1,u=t/o,d=e/l,f=[],p=[],x=[],y=[];for(let g=0;g<h;g++){const m=g*d-a;for(let E=0;E<c;E++){const w=E*u-s;p.push(w,-m,0),x.push(0,0,1),y.push(E/o),y.push(1-g/l)}}for(let g=0;g<l;g++)for(let m=0;m<o;m++){const E=m+c*g,w=m+c*(g+1),S=m+1+c*(g+1),_=m+1+c*g;f.push(E,w,_),f.push(w,S,_)}this.setIndex(f),this.setAttribute("position",new ie(p,3)),this.setAttribute("normal",new ie(x,3)),this.setAttribute("uv",new ie(y,2))}}var b0=`#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`,w0=`#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,S0=`#ifdef ALPHATEST
	if ( diffuseColor.a < ALPHATEST ) discard;
#endif`,E0=`#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );
	#endif
#endif`,A0=`#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,T0="vec3 transformed = vec3( position );",L0=`vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,R0=`vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	return vec2( -1.04, 1.04 ) * a004 + r.zw;
}
float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
#if defined ( PHYSICALLY_CORRECT_LIGHTS )
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
#else
	if( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
		return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );
	}
	return 1.0;
#endif
}
vec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {
	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );
	return ( 1.0 - specularColor ) * fresnel + specularColor;
}
vec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {
	float fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );
	vec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;
	return Fr * fresnel + F0;
}
float G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	return 1.0 / ( gl * gv );
}
float G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( incidentLight.direction + viewDir );
	float dotNL = saturate( dot( normal, incidentLight.direction ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );
	vec3 F = F_Schlick( specularColor, dotLH );
	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( G * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
vec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );
	return specularColor * brdf.x + brdf.y;
}
void BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
	vec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );
	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );
	vec3 FssEss = F * brdf.x + brdf.y;
	float Ess = brdf.x + brdf.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );
	float dotNH = saturate( dot( geometry.normal, halfDir ) );
	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );
	vec3 F = F_Schlick( specularColor, dotLH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
float GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {
	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );
}
float BlinnExponentToGGXRoughness( const in float blinnExponent ) {
	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );
}
#if defined( USE_SHEEN )
float D_Charlie(float roughness, float NoH) {
	float invAlpha = 1.0 / roughness;
	float cos2h = NoH * NoH;
	float sin2h = max(1.0 - cos2h, 0.0078125);	return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);
}
float V_Neubelt(float NoV, float NoL) {
	return saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));
}
vec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {
	vec3 N = geometry.normal;
	vec3 V = geometry.viewDir;
	vec3 H = normalize( V + L );
	float dotNH = saturate( dot( N, H ) );
	return specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );
}
#endif`,C0=`#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );
		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,P0=`#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,D0=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,F0=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,I0=`#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,z0=`#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,N0=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,B0=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,O0=`#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,U0=`#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate(a) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement(a) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract(sin(sn) * c);
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
vec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
	float distance = dot( planeNormal, point - pointOnPlane );
	return - distance * planeNormal + point;
}
float sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
	return sign( dot( point - pointOnPlane, planeNormal ) );
}
vec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {
	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float linearToRelativeLuminance( const in vec3 color ) {
	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );
	return dot( weights, color.rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`,H0=`#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_maxMipLevel 8.0
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_maxTileSize 256.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		float texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );
		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );
		vec2 f = fract( uv );
		uv += 0.5 - f;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		if ( mipInt < cubeUV_maxMipLevel ) {
			uv.y += 2.0 * cubeUV_maxTileSize;
		}
		uv.y += filterInt * 2.0 * cubeUV_minTileSize;
		uv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );
		uv *= texelSize;
		vec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.x += texelSize;
		vec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.y += texelSize;
		vec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.x -= texelSize;
		vec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		vec3 tm = mix( tl, tr, f.x );
		vec3 bm = mix( bl, br, f.x );
		return mix( tm, bm, f.y );
	}
	#define r0 1.0
	#define v0 0.339
	#define m0 - 2.0
	#define r1 0.8
	#define v1 0.276
	#define m1 - 1.0
	#define r4 0.4
	#define v4 0.046
	#define m4 2.0
	#define r5 0.305
	#define v5 0.016
	#define m5 3.0
	#define r6 0.21
	#define v6 0.0038
	#define m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= r1 ) {
			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;
		} else if ( roughness >= r4 ) {
			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;
		} else if ( roughness >= r5 ) {
			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;
		} else if ( roughness >= r6 ) {
			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,G0=`vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,k0=`#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,V0=`#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`,W0=`#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,$0=`#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,X0="gl_FragColor = linearToOutputTexel( gl_FragColor );",q0=`
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 GammaToLinear( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );
}
vec4 LinearToGamma( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );
}
vec4 sRGBToLinear( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 RGBEToLinear( in vec4 value ) {
	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );
}
vec4 LinearToRGBE( in vec4 value ) {
	float maxComponent = max( max( value.r, value.g ), value.b );
	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );
	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );
}
vec4 RGBMToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * value.a * maxRange, 1.0 );
}
vec4 LinearToRGBM( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );
	M = ceil( M * 255.0 ) / 255.0;
	return vec4( value.rgb / ( M * maxRange ), M );
}
vec4 RGBDToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );
}
vec4 LinearToRGBD( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float D = max( maxRange / maxRGB, 1.0 );
	D = clamp( floor( D ) / 255.0, 0.0, 1.0 );
	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );
}
const mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );
vec4 LinearToLogLuv( in vec4 value ) {
	vec3 Xp_Y_XYZp = cLogLuvM * value.rgb;
	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );
	vec4 vResult;
	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;
	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;
	vResult.w = fract( Le );
	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;
	return vResult;
}
const mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );
vec4 LogLuvToLinear( in vec4 value ) {
	float Le = value.z * 255.0 + value.w;
	vec3 Xp_Y_XYZp;
	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );
	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;
	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;
	vec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;
	return vec4( max( vRGB, 0.0 ), 1.0 );
}`,Y0=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifndef ENVMAP_TYPE_CUBE_UV
		envColor = envMapTexelToLinear( envColor );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,j0=`#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform int maxMipLevel;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,Z0=`#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,J0=`#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,Q0=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,K0=`#ifdef USE_FOG
	fogDepth = - mvPosition.z;
#endif`,ty=`#ifdef USE_FOG
	varying float fogDepth;
#endif`,ey=`#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, fogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,iy=`#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float fogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,ny=`#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return texture2D( gradientMap, coord ).rgb;
	#else
		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );
	#endif
}`,ry=`#ifdef USE_LIGHTMAP
	vec4 lightMapTexel= texture2D( lightMap, vUv2 );
	reflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
#endif`,sy=`#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,ay=`vec3 diffuse = vec3( 1.0 );
GeometricContext geometry;
geometry.position = mvPosition.xyz;
geometry.normal = normalize( transformedNormal );
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );
GeometricContext backGeometry;
backGeometry.position = geometry.position;
backGeometry.normal = -geometry.normal;
backGeometry.viewDir = geometry.viewDir;
vLightFront = vec3( 0.0 );
vIndirectFront = vec3( 0.0 );
#ifdef DOUBLE_SIDED
	vLightBack = vec3( 0.0 );
	vIndirectBack = vec3( 0.0 );
#endif
IncidentLight directLight;
float dotNL;
vec3 directLightColor_Diffuse;
vIndirectFront += getAmbientLightIrradiance( ambientLightColor );
vIndirectFront += getLightProbeIrradiance( lightProbe, geometry );
#ifdef DOUBLE_SIDED
	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );
	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );
#endif
#if NUM_POINT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_SPOT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_DIR_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_HEMI_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );
		#ifdef DOUBLE_SIDED
			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );
		#endif
	}
	#pragma unroll_loop_end
#endif`,oy=`uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {
	vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	return irradiance;
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {
		directLight.color = directionalLight.color;
		directLight.direction = directionalLight.direction;
		directLight.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {
		vec3 lVector = pointLight.position - geometry.position;
		directLight.direction = normalize( lVector );
		float lightDistance = length( lVector );
		directLight.color = pointLight.color;
		directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );
		directLight.visible = ( directLight.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {
		vec3 lVector = spotLight.position - geometry.position;
		directLight.direction = normalize( lVector );
		float lightDistance = length( lVector );
		float angleCos = dot( directLight.direction, spotLight.direction );
		if ( angleCos > spotLight.coneCos ) {
			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );
			directLight.color = spotLight.color;
			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );
			directLight.visible = true;
		} else {
			directLight.color = vec3( 0.0 );
			directLight.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {
		float dotNL = dot( geometry.normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			irradiance *= PI;
		#endif
		return irradiance;
	}
#endif`,ly=`#if defined( USE_ENVMAP )
	#ifdef ENVMAP_MODE_REFRACTION
		uniform float refractionRatio;
	#endif
	vec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {
		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );
		#ifdef ENVMAP_TYPE_CUBE
			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );
			#ifdef TEXTURE_LOD_EXT
				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );
			#else
				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );
			#endif
			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
		#elif defined( ENVMAP_TYPE_CUBE_UV )
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
		#else
			vec4 envMapColor = vec4( 0.0 );
		#endif
		return PI * envMapColor.rgb * envMapIntensity;
	}
	float getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {
		float maxMIPLevelScalar = float( maxMIPLevel );
		float sigma = PI * roughness * roughness / ( 1.0 + roughness );
		float desiredMIPLevel = maxMIPLevelScalar + log2( sigma );
		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );
	}
	vec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( -viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
		#else
			vec3 reflectVec = refract( -viewDir, normal, refractionRatio );
		#endif
		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
		float specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );
		#ifdef ENVMAP_TYPE_CUBE
			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );
			#ifdef TEXTURE_LOD_EXT
				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );
			#else
				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );
			#endif
			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
		#elif defined( ENVMAP_TYPE_CUBE_UV )
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
		#endif
		return envMapColor.rgb * envMapIntensity;
	}
#endif`,cy=`ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,hy=`varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
#define Material_LightProbeLOD( material )	(0)`,uy=`BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,dy=`varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong
#define Material_LightProbeLOD( material )	(0)`,fy=`PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;
material.specularRoughness = min( material.specularRoughness, 1.0 );
#ifdef REFLECTIVITY
	material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );
#endif
#ifdef CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheen;
#endif`,py=`struct PhysicalMaterial {
	vec3 diffuseColor;
	float specularRoughness;
	vec3 specularColor;
#ifdef CLEARCOAT
	float clearcoat;
	float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	vec3 sheenColor;
#endif
};
#define MAXIMUM_SPECULAR_COEFFICIENT 0.16
#define DEFAULT_SPECULAR_COEFFICIENT 0.04
float clearcoatDHRApprox( const in float roughness, const in float dotNL ) {
	return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.specularRoughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	#ifdef CLEARCOAT
		float ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = ccDotNL * directLight.color;
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			ccIrradiance *= PI;
		#endif
		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );
		reflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );
	#else
		float clearcoatDHR = 0.0;
	#endif
	#ifdef USE_SHEEN
		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(
			material.specularRoughness,
			directLight.direction,
			geometry,
			material.sheenColor
		);
	#else
		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);
	#endif
	reflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef CLEARCOAT
		float ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		reflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );
		float ccDotNL = ccDotNV;
		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );
	#else
		float clearcoatDHR = 0.0;
	#endif
	float clearcoatInv = 1.0 - clearcoatDHR;
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	BRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );
	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );
	reflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,my=`
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointDirectLightIrradiance( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotDirectLightIrradiance( spotLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,gy=`#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			lightMapIrradiance *= PI;
		#endif
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );
	#ifdef CLEARCOAT
		clearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );
	#endif
#endif`,xy=`#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,yy=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,_y=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,vy=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,My=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,by=`#ifdef USE_MAP
	vec4 texelColor = texture2D( map, vUv );
	texelColor = mapTexelToLinear( texelColor );
	diffuseColor *= texelColor;
#endif`,wy=`#ifdef USE_MAP
	uniform sampler2D map;
#endif`,Sy=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	vec4 mapTexel = texture2D( map, uv );
	diffuseColor *= mapTexelToLinear( mapTexel );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,Ey=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,Ay=`float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`,Ty=`#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,Ly=`#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
	objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
	objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
	objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
#endif`,Ry=`#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifndef USE_MORPHNORMALS
		uniform float morphTargetInfluences[ 8 ];
	#else
		uniform float morphTargetInfluences[ 4 ];
	#endif
#endif`,Cy=`#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	transformed += morphTarget0 * morphTargetInfluences[ 0 ];
	transformed += morphTarget1 * morphTargetInfluences[ 1 ];
	transformed += morphTarget2 * morphTargetInfluences[ 2 ];
	transformed += morphTarget3 * morphTargetInfluences[ 3 ];
	#ifndef USE_MORPHNORMALS
		transformed += morphTarget4 * morphTargetInfluences[ 4 ];
		transformed += morphTarget5 * morphTargetInfluences[ 5 ];
		transformed += morphTarget6 * morphTargetInfluences[ 6 ];
		transformed += morphTarget7 * morphTargetInfluences[ 7 ];
	#endif
#endif`,Py=`float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`,Dy=`#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,Fy=`#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`,Iy=`#ifdef CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`,zy=`#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`,Ny=`#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`,By=`vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return (( near + viewZ ) * far ) / (( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`,Oy=`#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,Uy=`vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,Hy=`#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,Gy=`#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,ky=`float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`,Vy=`#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,Wy=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );
		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
		bool frustumTest = all( frustumTestVec );
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,$y=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,Xy=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;
	#endif
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
#endif`,qy=`float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,Yy=`#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,jy=`#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	#ifdef BONE_TEXTURE
		uniform highp sampler2D boneTexture;
		uniform int boneTextureSize;
		mat4 getBoneMatrix( const in float i ) {
			float j = i * 4.0;
			float x = mod( j, float( boneTextureSize ) );
			float y = floor( j / float( boneTextureSize ) );
			float dx = 1.0 / float( boneTextureSize );
			float dy = 1.0 / float( boneTextureSize );
			y = dy * ( y + 0.5 );
			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
			mat4 bone = mat4( v1, v2, v3, v4 );
			return bone;
		}
	#else
		uniform mat4 boneMatrices[ MAX_BONES ];
		mat4 getBoneMatrix( const in float i ) {
			mat4 bone = boneMatrices[ int(i) ];
			return bone;
		}
	#endif
#endif`,Zy=`#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,Jy=`#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,Qy=`float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,Ky=`#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,t_=`#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,e_=`#ifndef saturate
#define saturate(a) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,i_=`#ifdef USE_TRANSMISSIONMAP
	totalTransmission *= texture2D( transmissionMap, vUv ).r;
#endif`,n_=`#ifdef USE_TRANSMISSIONMAP
	uniform sampler2D transmissionMap;
#endif`,r_=`#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`,s_=`#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`,a_=`#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`,o_=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`,l_=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`,c_=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`,h_=`#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`,u_=`uniform sampler2D t2D;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,d_=`varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,f_=`#include <envmap_common_pars_fragment>
uniform float opacity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	vec3 vReflect = vWorldDirection;
	#include <envmap_fragment>
	gl_FragColor = envColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,p_=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,m_=`#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,g_=`#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,x_=`#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,y_=`#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,__=`uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	vec4 texColor = texture2D( tEquirect, sampleUV );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,v_=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,M_=`uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,b_=`uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,w_=`uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
	
		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,S_=`#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <skinbase_vertex>
	#ifdef USE_ENVMAP
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,E_=`uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <emissivemap_fragment>
	#ifdef DOUBLE_SIDED
		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;
	#else
		reflectedLight.indirectDiffuse += vIndirectFront;
	#endif
	#include <lightmap_fragment>
	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );
	#ifdef DOUBLE_SIDED
		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;
	#else
		reflectedLight.directDiffuse = vLightFront;
	#endif
	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,A_=`#define LAMBERT
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars_begin>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <lights_lambert_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,T_=`#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <fog_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
		matcapColor = matcapTexelToLinear( matcapColor );
	#else
		vec4 matcapColor = vec4( 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,L_=`#define MATCAP
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#ifndef FLAT_SHADED
		vNormal = normalize( transformedNormal );
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,R_=`#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,C_=`#define TOON
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,P_=`#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,D_=`#define PHONG
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,F_=`#define STANDARD
#ifdef PHYSICAL
	#define REFLECTIVITY
	#define CLEARCOAT
	#define TRANSMISSION
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef TRANSMISSION
	uniform float transmission;
#endif
#ifdef REFLECTIVITY
	uniform float reflectivity;
#endif
#ifdef CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheen;
#endif
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <transmissionmap_pars_fragment>
#include <bsdfs>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <lights_physical_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#ifdef TRANSMISSION
		float totalTransmission = transmission;
	#endif
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <transmissionmap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#ifdef TRANSMISSION
		diffuseColor.a *= mix( saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) ), 1.0, metalness );
	#endif
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,I_=`#define STANDARD
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,z_=`#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <packing>
#include <uv_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
}`,N_=`#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`,B_=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,O_=`uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,U_=`uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,H_=`#include <common>
#include <fog_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <begin_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,G_=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,k_=`uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`;const kt={alphamap_fragment:b0,alphamap_pars_fragment:w0,alphatest_fragment:S0,aomap_fragment:E0,aomap_pars_fragment:A0,begin_vertex:T0,beginnormal_vertex:L0,bsdfs:R0,bumpmap_pars_fragment:C0,clipping_planes_fragment:P0,clipping_planes_pars_fragment:D0,clipping_planes_pars_vertex:F0,clipping_planes_vertex:I0,color_fragment:z0,color_pars_fragment:N0,color_pars_vertex:B0,color_vertex:O0,common:U0,cube_uv_reflection_fragment:H0,defaultnormal_vertex:G0,displacementmap_pars_vertex:k0,displacementmap_vertex:V0,emissivemap_fragment:W0,emissivemap_pars_fragment:$0,encodings_fragment:X0,encodings_pars_fragment:q0,envmap_fragment:Y0,envmap_common_pars_fragment:j0,envmap_pars_fragment:Z0,envmap_pars_vertex:J0,envmap_physical_pars_fragment:ly,envmap_vertex:Q0,fog_vertex:K0,fog_pars_vertex:ty,fog_fragment:ey,fog_pars_fragment:iy,gradientmap_pars_fragment:ny,lightmap_fragment:ry,lightmap_pars_fragment:sy,lights_lambert_vertex:ay,lights_pars_begin:oy,lights_toon_fragment:cy,lights_toon_pars_fragment:hy,lights_phong_fragment:uy,lights_phong_pars_fragment:dy,lights_physical_fragment:fy,lights_physical_pars_fragment:py,lights_fragment_begin:my,lights_fragment_maps:gy,lights_fragment_end:xy,logdepthbuf_fragment:yy,logdepthbuf_pars_fragment:_y,logdepthbuf_pars_vertex:vy,logdepthbuf_vertex:My,map_fragment:by,map_pars_fragment:wy,map_particle_fragment:Sy,map_particle_pars_fragment:Ey,metalnessmap_fragment:Ay,metalnessmap_pars_fragment:Ty,morphnormal_vertex:Ly,morphtarget_pars_vertex:Ry,morphtarget_vertex:Cy,normal_fragment_begin:Py,normal_fragment_maps:Dy,normalmap_pars_fragment:Fy,clearcoat_normal_fragment_begin:Iy,clearcoat_normal_fragment_maps:zy,clearcoat_pars_fragment:Ny,packing:By,premultiplied_alpha_fragment:Oy,project_vertex:Uy,dithering_fragment:Hy,dithering_pars_fragment:Gy,roughnessmap_fragment:ky,roughnessmap_pars_fragment:Vy,shadowmap_pars_fragment:Wy,shadowmap_pars_vertex:$y,shadowmap_vertex:Xy,shadowmask_pars_fragment:qy,skinbase_vertex:Yy,skinning_pars_vertex:jy,skinning_vertex:Zy,skinnormal_vertex:Jy,specularmap_fragment:Qy,specularmap_pars_fragment:Ky,tonemapping_fragment:t_,tonemapping_pars_fragment:e_,transmissionmap_fragment:i_,transmissionmap_pars_fragment:n_,uv_pars_fragment:r_,uv_pars_vertex:s_,uv_vertex:a_,uv2_pars_fragment:o_,uv2_pars_vertex:l_,uv2_vertex:c_,worldpos_vertex:h_,background_frag:u_,background_vert:d_,cube_frag:f_,cube_vert:p_,depth_frag:m_,depth_vert:g_,distanceRGBA_frag:x_,distanceRGBA_vert:y_,equirect_frag:__,equirect_vert:v_,linedashed_frag:M_,linedashed_vert:b_,meshbasic_frag:w_,meshbasic_vert:S_,meshlambert_frag:E_,meshlambert_vert:A_,meshmatcap_frag:T_,meshmatcap_vert:L_,meshtoon_frag:R_,meshtoon_vert:C_,meshphong_frag:P_,meshphong_vert:D_,meshphysical_frag:F_,meshphysical_vert:I_,normal_frag:z_,normal_vert:N_,points_frag:B_,points_vert:O_,shadow_frag:U_,shadow_vert:H_,sprite_frag:G_,sprite_vert:k_},_t={common:{diffuse:{value:new zt(15658734)},opacity:{value:1},map:{value:null},uvTransform:{value:new Se},uv2Transform:{value:new Se},alphaMap:{value:null}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},refractionRatio:{value:.98},maxMipLevel:{value:0}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new lt(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new zt(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new zt(15658734)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},uvTransform:{value:new Se}},sprite:{diffuse:{value:new zt(15658734)},opacity:{value:1},center:{value:new lt(.5,.5)},rotation:{value:0},map:{value:null},alphaMap:{value:null},uvTransform:{value:new Se}}},Ci={basic:{uniforms:Pe([_t.common,_t.specularmap,_t.envmap,_t.aomap,_t.lightmap,_t.fog]),vertexShader:kt.meshbasic_vert,fragmentShader:kt.meshbasic_frag},lambert:{uniforms:Pe([_t.common,_t.specularmap,_t.envmap,_t.aomap,_t.lightmap,_t.emissivemap,_t.fog,_t.lights,{emissive:{value:new zt(0)}}]),vertexShader:kt.meshlambert_vert,fragmentShader:kt.meshlambert_frag},phong:{uniforms:Pe([_t.common,_t.specularmap,_t.envmap,_t.aomap,_t.lightmap,_t.emissivemap,_t.bumpmap,_t.normalmap,_t.displacementmap,_t.fog,_t.lights,{emissive:{value:new zt(0)},specular:{value:new zt(1118481)},shininess:{value:30}}]),vertexShader:kt.meshphong_vert,fragmentShader:kt.meshphong_frag},standard:{uniforms:Pe([_t.common,_t.envmap,_t.aomap,_t.lightmap,_t.emissivemap,_t.bumpmap,_t.normalmap,_t.displacementmap,_t.roughnessmap,_t.metalnessmap,_t.fog,_t.lights,{emissive:{value:new zt(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:kt.meshphysical_vert,fragmentShader:kt.meshphysical_frag},toon:{uniforms:Pe([_t.common,_t.aomap,_t.lightmap,_t.emissivemap,_t.bumpmap,_t.normalmap,_t.displacementmap,_t.gradientmap,_t.fog,_t.lights,{emissive:{value:new zt(0)}}]),vertexShader:kt.meshtoon_vert,fragmentShader:kt.meshtoon_frag},matcap:{uniforms:Pe([_t.common,_t.bumpmap,_t.normalmap,_t.displacementmap,_t.fog,{matcap:{value:null}}]),vertexShader:kt.meshmatcap_vert,fragmentShader:kt.meshmatcap_frag},points:{uniforms:Pe([_t.points,_t.fog]),vertexShader:kt.points_vert,fragmentShader:kt.points_frag},dashed:{uniforms:Pe([_t.common,_t.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:kt.linedashed_vert,fragmentShader:kt.linedashed_frag},depth:{uniforms:Pe([_t.common,_t.displacementmap]),vertexShader:kt.depth_vert,fragmentShader:kt.depth_frag},normal:{uniforms:Pe([_t.common,_t.bumpmap,_t.normalmap,_t.displacementmap,{opacity:{value:1}}]),vertexShader:kt.normal_vert,fragmentShader:kt.normal_frag},sprite:{uniforms:Pe([_t.sprite,_t.fog]),vertexShader:kt.sprite_vert,fragmentShader:kt.sprite_frag},background:{uniforms:{uvTransform:{value:new Se},t2D:{value:null}},vertexShader:kt.background_vert,fragmentShader:kt.background_frag},cube:{uniforms:Pe([_t.envmap,{opacity:{value:1}}]),vertexShader:kt.cube_vert,fragmentShader:kt.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:kt.equirect_vert,fragmentShader:kt.equirect_frag},distanceRGBA:{uniforms:Pe([_t.common,_t.displacementmap,{referencePosition:{value:new U},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:kt.distanceRGBA_vert,fragmentShader:kt.distanceRGBA_frag},shadow:{uniforms:Pe([_t.lights,_t.fog,{color:{value:new zt(0)},opacity:{value:1}}]),vertexShader:kt.shadow_vert,fragmentShader:kt.shadow_frag}};Ci.physical={uniforms:Pe([Ci.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new lt(1,1)},clearcoatNormalMap:{value:null},sheen:{value:new zt(0)},transmission:{value:0},transmissionMap:{value:null}}]),vertexShader:kt.meshphysical_vert,fragmentShader:kt.meshphysical_frag};function V_(i,t,e,n,r){const s=new zt(0);let a=0,o,l,c=null,h=0,u=null;function d(p,x,y,g){let m=x.isScene===!0?x.background:null;m&&m.isTexture&&(m=t.get(m));const E=i.xr,w=E.getSession&&E.getSession();w&&w.environmentBlendMode==="additive"&&(m=null),m===null?f(s,a):m&&m.isColor&&(f(m,1),g=!0),(i.autoClear||g)&&i.clear(i.autoClearColor,i.autoClearDepth,i.autoClearStencil),m&&(m.isCubeTexture||m.mapping===Wl)?(l===void 0&&(l=new Te(new Lc(1,1,1),new ni({name:"BackgroundCubeMaterial",uniforms:Lr(Ci.cube.uniforms),vertexShader:Ci.cube.vertexShader,fragmentShader:Ci.cube.fragmentShader,side:ye,depthTest:!1,depthWrite:!1,fog:!1})),l.geometry.deleteAttribute("normal"),l.geometry.deleteAttribute("uv"),l.onBeforeRender=function(S,_,T){this.matrixWorld.copyPosition(T.matrixWorld)},Object.defineProperty(l.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),n.update(l)),l.material.uniforms.envMap.value=m,l.material.uniforms.flipEnvMap.value=m.isCubeTexture&&m._needsFlipEnvMap?-1:1,(c!==m||h!==m.version||u!==i.toneMapping)&&(l.material.needsUpdate=!0,c=m,h=m.version,u=i.toneMapping),p.unshift(l,l.geometry,l.material,0,0,null)):m&&m.isTexture&&(o===void 0&&(o=new Te(new M0(2,2),new ni({name:"BackgroundMaterial",uniforms:Lr(Ci.background.uniforms),vertexShader:Ci.background.vertexShader,fragmentShader:Ci.background.fragmentShader,side:Ba,depthTest:!1,depthWrite:!1,fog:!1})),o.geometry.deleteAttribute("normal"),Object.defineProperty(o.material,"map",{get:function(){return this.uniforms.t2D.value}}),n.update(o)),o.material.uniforms.t2D.value=m,m.matrixAutoUpdate===!0&&m.updateMatrix(),o.material.uniforms.uvTransform.value.copy(m.matrix),(c!==m||h!==m.version||u!==i.toneMapping)&&(o.material.needsUpdate=!0,c=m,h=m.version,u=i.toneMapping),p.unshift(o,o.geometry,o.material,0,0,null))}function f(p,x){e.buffers.color.setClear(p.r,p.g,p.b,x,r)}return{getClearColor:function(){return s},setClearColor:function(p,x=1){s.set(p),a=x,f(s,a)},getClearAlpha:function(){return a},setClearAlpha:function(p){a=p,f(s,a)},render:d}}function W_(i,t,e,n){const r=i.getParameter(34921),s=n.isWebGL2?null:t.get("OES_vertex_array_object"),a=n.isWebGL2||s!==null,o={},l=x(null);let c=l;function h(R,L,P,F,W){let j=!1;if(a){const Y=p(F,P,L);c!==Y&&(c=Y,d(c.object)),j=y(F,W),j&&g(F,W)}else{const Y=L.wireframe===!0;(c.geometry!==F.id||c.program!==P.id||c.wireframe!==Y)&&(c.geometry=F.id,c.program=P.id,c.wireframe=Y,j=!0)}R.isInstancedMesh===!0&&(j=!0),W!==null&&e.update(W,34963),j&&(T(R,L,P,F),W!==null&&i.bindBuffer(34963,e.get(W).buffer))}function u(){return n.isWebGL2?i.createVertexArray():s.createVertexArrayOES()}function d(R){return n.isWebGL2?i.bindVertexArray(R):s.bindVertexArrayOES(R)}function f(R){return n.isWebGL2?i.deleteVertexArray(R):s.deleteVertexArrayOES(R)}function p(R,L,P){const F=P.wireframe===!0;let W=o[R.id];W===void 0&&(W={},o[R.id]=W);let j=W[L.id];j===void 0&&(j={},W[L.id]=j);let Y=j[F];return Y===void 0&&(Y=x(u()),j[F]=Y),Y}function x(R){const L=[],P=[],F=[];for(let W=0;W<r;W++)L[W]=0,P[W]=0,F[W]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:L,enabledAttributes:P,attributeDivisors:F,object:R,attributes:{},index:null}}function y(R,L){const P=c.attributes,F=R.attributes;let W=0;for(const j in F){const Y=P[j],Q=F[j];if(Y===void 0||Y.attribute!==Q||Y.data!==Q.data)return!0;W++}return c.attributesNum!==W||c.index!==L}function g(R,L){const P={},F=R.attributes;let W=0;for(const j in F){const Y=F[j],Q={};Q.attribute=Y,Y.data&&(Q.data=Y.data),P[j]=Q,W++}c.attributes=P,c.attributesNum=W,c.index=L}function m(){const R=c.newAttributes;for(let L=0,P=R.length;L<P;L++)R[L]=0}function E(R){w(R,0)}function w(R,L){const P=c.newAttributes,F=c.enabledAttributes,W=c.attributeDivisors;P[R]=1,F[R]===0&&(i.enableVertexAttribArray(R),F[R]=1),W[R]!==L&&((n.isWebGL2?i:t.get("ANGLE_instanced_arrays"))[n.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](R,L),W[R]=L)}function S(){const R=c.newAttributes,L=c.enabledAttributes;for(let P=0,F=L.length;P<F;P++)L[P]!==R[P]&&(i.disableVertexAttribArray(P),L[P]=0)}function _(R,L,P,F,W,j){n.isWebGL2===!0&&(P===5124||P===5125)?i.vertexAttribIPointer(R,L,P,W,j):i.vertexAttribPointer(R,L,P,F,W,j)}function T(R,L,P,F){if(n.isWebGL2===!1&&(R.isInstancedMesh||F.isInstancedBufferGeometry)&&t.get("ANGLE_instanced_arrays")===null)return;m();const W=F.attributes,j=P.getAttributes(),Y=L.defaultAttributeValues;for(const Q in j){const K=j[Q];if(K>=0){const st=W[Q];if(st!==void 0){const ct=st.normalized,z=st.itemSize,Et=e.get(st);if(Et===void 0)continue;const At=Et.buffer,yt=Et.type,ot=Et.bytesPerElement;if(st.isInterleavedBufferAttribute){const Ct=st.data,Mt=Ct.stride,St=st.offset;Ct&&Ct.isInstancedInterleavedBuffer?(w(K,Ct.meshPerAttribute),F._maxInstanceCount===void 0&&(F._maxInstanceCount=Ct.meshPerAttribute*Ct.count)):E(K),i.bindBuffer(34962,At),_(K,z,yt,ct,Mt*ot,St*ot)}else st.isInstancedBufferAttribute?(w(K,st.meshPerAttribute),F._maxInstanceCount===void 0&&(F._maxInstanceCount=st.meshPerAttribute*st.count)):E(K),i.bindBuffer(34962,At),_(K,z,yt,ct,0,0)}else if(Q==="instanceMatrix"){const ct=e.get(R.instanceMatrix);if(ct===void 0)continue;const z=ct.buffer,Et=ct.type;w(K+0,1),w(K+1,1),w(K+2,1),w(K+3,1),i.bindBuffer(34962,z),i.vertexAttribPointer(K+0,4,Et,!1,64,0),i.vertexAttribPointer(K+1,4,Et,!1,64,16),i.vertexAttribPointer(K+2,4,Et,!1,64,32),i.vertexAttribPointer(K+3,4,Et,!1,64,48)}else if(Q==="instanceColor"){const ct=e.get(R.instanceColor);if(ct===void 0)continue;const z=ct.buffer,Et=ct.type;w(K,1),i.bindBuffer(34962,z),i.vertexAttribPointer(K,3,Et,!1,12,0)}else if(Y!==void 0){const ct=Y[Q];if(ct!==void 0)switch(ct.length){case 2:i.vertexAttrib2fv(K,ct);break;case 3:i.vertexAttrib3fv(K,ct);break;case 4:i.vertexAttrib4fv(K,ct);break;default:i.vertexAttrib1fv(K,ct)}}}}S()}function B(){D();for(const R in o){const L=o[R];for(const P in L){const F=L[P];for(const W in F)f(F[W].object),delete F[W];delete L[P]}delete o[R]}}function N(R){if(o[R.id]===void 0)return;const L=o[R.id];for(const P in L){const F=L[P];for(const W in F)f(F[W].object),delete F[W];delete L[P]}delete o[R.id]}function G(R){for(const L in o){const P=o[L];if(P[R.id]===void 0)continue;const F=P[R.id];for(const W in F)f(F[W].object),delete F[W];delete P[R.id]}}function D(){V(),c!==l&&(c=l,d(c.object))}function V(){l.geometry=null,l.program=null,l.wireframe=!1}return{setup:h,reset:D,resetDefaultState:V,dispose:B,releaseStatesOfGeometry:N,releaseStatesOfProgram:G,initAttributes:m,enableAttribute:E,disableUnusedAttributes:S}}function $_(i,t,e,n){const r=n.isWebGL2;let s;function a(c){s=c}function o(c,h){i.drawArrays(s,c,h),e.update(h,s,1)}function l(c,h,u){if(u===0)return;let d,f;if(r)d=i,f="drawArraysInstanced";else if(d=t.get("ANGLE_instanced_arrays"),f="drawArraysInstancedANGLE",d===null){console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}d[f](s,c,h,u),e.update(h,s,u)}this.setMode=a,this.render=o,this.renderInstances=l}function X_(i,t,e){let n;function r(){if(n!==void 0)return n;if(t.has("EXT_texture_filter_anisotropic")===!0){const _=t.get("EXT_texture_filter_anisotropic");n=i.getParameter(_.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else n=0;return n}function s(_){if(_==="highp"){if(i.getShaderPrecisionFormat(35633,36338).precision>0&&i.getShaderPrecisionFormat(35632,36338).precision>0)return"highp";_="mediump"}return _==="mediump"&&i.getShaderPrecisionFormat(35633,36337).precision>0&&i.getShaderPrecisionFormat(35632,36337).precision>0?"mediump":"lowp"}const a=typeof WebGL2RenderingContext!="undefined"&&i instanceof WebGL2RenderingContext||typeof WebGL2ComputeRenderingContext!="undefined"&&i instanceof WebGL2ComputeRenderingContext;let o=e.precision!==void 0?e.precision:"highp";const l=s(o);l!==o&&(console.warn("THREE.WebGLRenderer:",o,"not supported, using",l,"instead."),o=l);const c=e.logarithmicDepthBuffer===!0,h=i.getParameter(34930),u=i.getParameter(35660),d=i.getParameter(3379),f=i.getParameter(34076),p=i.getParameter(34921),x=i.getParameter(36347),y=i.getParameter(36348),g=i.getParameter(36349),m=u>0,E=a||t.has("OES_texture_float"),w=m&&E,S=a?i.getParameter(36183):0;return{isWebGL2:a,getMaxAnisotropy:r,getMaxPrecision:s,precision:o,logarithmicDepthBuffer:c,maxTextures:h,maxVertexTextures:u,maxTextureSize:d,maxCubemapSize:f,maxAttributes:p,maxVertexUniforms:x,maxVaryings:y,maxFragmentUniforms:g,vertexTextures:m,floatFragmentTextures:E,floatVertexTextures:w,maxSamples:S}}function q_(i){const t=this;let e=null,n=0,r=!1,s=!1;const a=new Li,o=new Se,l={value:null,needsUpdate:!1};this.uniform=l,this.numPlanes=0,this.numIntersection=0,this.init=function(u,d,f){const p=u.length!==0||d||n!==0||r;return r=d,e=h(u,f,0),n=u.length,p},this.beginShadows=function(){s=!0,h(null)},this.endShadows=function(){s=!1,c()},this.setState=function(u,d,f){const p=u.clippingPlanes,x=u.clipIntersection,y=u.clipShadows,g=i.get(u);if(!r||p===null||p.length===0||s&&!y)s?h(null):c();else{const m=s?0:n,E=m*4;let w=g.clippingState||null;l.value=w,w=h(p,d,E,f);for(let S=0;S!==E;++S)w[S]=e[S];g.clippingState=w,this.numIntersection=x?this.numPlanes:0,this.numPlanes+=m}};function c(){l.value!==e&&(l.value=e,l.needsUpdate=n>0),t.numPlanes=n,t.numIntersection=0}function h(u,d,f,p){const x=u!==null?u.length:0;let y=null;if(x!==0){if(y=l.value,p!==!0||y===null){const g=f+x*4,m=d.matrixWorldInverse;o.getNormalMatrix(m),(y===null||y.length<g)&&(y=new Float32Array(g));for(let E=0,w=f;E!==x;++E,w+=4)a.copy(u[E]).applyMatrix4(m,o),a.normal.toArray(y,w),y[w+3]=a.constant}l.value=y,l.needsUpdate=!0}return t.numPlanes=x,t.numIntersection=0,y}}function Y_(i){let t=new WeakMap;function e(a,o){return o===Qu?a.mapping=kl:o===Ku&&(a.mapping=Vl),a}function n(a){if(a&&a.isTexture){const o=a.mapping;if(o===Qu||o===Ku)if(t.has(a)){const l=t.get(a).texture;return e(l,a.mapping)}else{const l=a.image;if(l&&l.height>0){const c=i.getRenderTarget(),h=new Rd(l.height/2);return h.fromEquirectangularTexture(i,a),t.set(a,h),i.setRenderTarget(c),a.addEventListener("dispose",r),e(h.texture,a.mapping)}else return null}}return a}function r(a){const o=a.target;o.removeEventListener("dispose",r);const l=t.get(o);l!==void 0&&(t.delete(o),l.dispose())}function s(){t=new WeakMap}return{get:n,dispose:s}}function j_(i){const t={};function e(n){if(t[n]!==void 0)return t[n];let r;switch(n){case"WEBGL_depth_texture":r=i.getExtension("WEBGL_depth_texture")||i.getExtension("MOZ_WEBGL_depth_texture")||i.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":r=i.getExtension("EXT_texture_filter_anisotropic")||i.getExtension("MOZ_EXT_texture_filter_anisotropic")||i.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":r=i.getExtension("WEBGL_compressed_texture_s3tc")||i.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||i.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":r=i.getExtension("WEBGL_compressed_texture_pvrtc")||i.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:r=i.getExtension(n)}return t[n]=r,r}return{has:function(n){return e(n)!==null},init:function(n){n.isWebGL2?e("EXT_color_buffer_float"):(e("WEBGL_depth_texture"),e("OES_texture_float"),e("OES_texture_half_float"),e("OES_texture_half_float_linear"),e("OES_standard_derivatives"),e("OES_element_index_uint"),e("OES_vertex_array_object"),e("ANGLE_instanced_arrays")),e("OES_texture_float_linear"),e("EXT_color_buffer_half_float")},get:function(n){const r=e(n);return r===null&&console.warn("THREE.WebGLRenderer: "+n+" extension not supported."),r}}}function Z_(i,t,e,n){const r={},s=new WeakMap;function a(u){const d=u.target;d.index!==null&&t.remove(d.index);for(const p in d.attributes)t.remove(d.attributes[p]);d.removeEventListener("dispose",a),delete r[d.id];const f=s.get(d);f&&(t.remove(f),s.delete(d)),n.releaseStatesOfGeometry(d),d.isInstancedBufferGeometry===!0&&delete d._maxInstanceCount,e.memory.geometries--}function o(u,d){return r[d.id]===!0||(d.addEventListener("dispose",a),r[d.id]=!0,e.memory.geometries++),d}function l(u){const d=u.attributes;for(const p in d)t.update(d[p],34962);const f=u.morphAttributes;for(const p in f){const x=f[p];for(let y=0,g=x.length;y<g;y++)t.update(x[y],34962)}}function c(u){const d=[],f=u.index,p=u.attributes.position;let x=0;if(f!==null){const m=f.array;x=f.version;for(let E=0,w=m.length;E<w;E+=3){const S=m[E+0],_=m[E+1],T=m[E+2];d.push(S,_,_,T,T,S)}}else{const m=p.array;x=p.version;for(let E=0,w=m.length/3-1;E<w;E+=3){const S=E+0,_=E+1,T=E+2;d.push(S,_,_,T,T,S)}}const y=new(Td(d)>65535?Vs:ks)(d,1);y.version=x;const g=s.get(u);g&&t.remove(g),s.set(u,y)}function h(u){const d=s.get(u);if(d){const f=u.index;f!==null&&d.version<f.version&&c(u)}else c(u);return s.get(u)}return{get:o,update:l,getWireframeAttribute:h}}function J_(i,t,e,n){const r=n.isWebGL2;let s;function a(d){s=d}let o,l;function c(d){o=d.type,l=d.bytesPerElement}function h(d,f){i.drawElements(s,f,o,d*l),e.update(f,s,1)}function u(d,f,p){if(p===0)return;let x,y;if(r)x=i,y="drawElementsInstanced";else if(x=t.get("ANGLE_instanced_arrays"),y="drawElementsInstancedANGLE",x===null){console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}x[y](s,f,o,d*l,p),e.update(f,s,p)}this.setMode=a,this.setIndex=c,this.render=h,this.renderInstances=u}function Q_(i){const t={geometries:0,textures:0},e={frame:0,calls:0,triangles:0,points:0,lines:0};function n(s,a,o){switch(e.calls++,a){case 4:e.triangles+=o*(s/3);break;case 1:e.lines+=o*(s/2);break;case 3:e.lines+=o*(s-1);break;case 2:e.lines+=o*s;break;case 0:e.points+=o*s;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",a);break}}function r(){e.frame++,e.calls=0,e.triangles=0,e.points=0,e.lines=0}return{memory:t,render:e,programs:null,autoReset:!0,reset:r,update:n}}function K_(i,t){return i[0]-t[0]}function tv(i,t){return Math.abs(t[1])-Math.abs(i[1])}function ev(i){const t={},e=new Float32Array(8),n=[];for(let s=0;s<8;s++)n[s]=[s,0];function r(s,a,o,l){const c=s.morphTargetInfluences,h=c===void 0?0:c.length;let u=t[a.id];if(u===void 0){u=[];for(let y=0;y<h;y++)u[y]=[y,0];t[a.id]=u}for(let y=0;y<h;y++){const g=u[y];g[0]=y,g[1]=c[y]}u.sort(tv);for(let y=0;y<8;y++)y<h&&u[y][1]?(n[y][0]=u[y][0],n[y][1]=u[y][1]):(n[y][0]=Number.MAX_SAFE_INTEGER,n[y][1]=0);n.sort(K_);const d=o.morphTargets&&a.morphAttributes.position,f=o.morphNormals&&a.morphAttributes.normal;let p=0;for(let y=0;y<8;y++){const g=n[y],m=g[0],E=g[1];m!==Number.MAX_SAFE_INTEGER&&E?(d&&a.getAttribute("morphTarget"+y)!==d[m]&&a.setAttribute("morphTarget"+y,d[m]),f&&a.getAttribute("morphNormal"+y)!==f[m]&&a.setAttribute("morphNormal"+y,f[m]),e[y]=E,p+=E):(d&&a.hasAttribute("morphTarget"+y)===!0&&a.deleteAttribute("morphTarget"+y),f&&a.hasAttribute("morphNormal"+y)===!0&&a.deleteAttribute("morphNormal"+y),e[y]=0)}const x=a.morphTargetsRelative?1:1-p;l.getUniforms().setValue(i,"morphTargetBaseInfluence",x),l.getUniforms().setValue(i,"morphTargetInfluences",e)}return{update:r}}function iv(i,t,e,n){let r=new WeakMap;function s(l){const c=n.render.frame,h=l.geometry,u=t.get(l,h);return r.get(u)!==c&&(t.update(u),r.set(u,c)),l.isInstancedMesh&&(l.hasEventListener("dispose",o)===!1&&l.addEventListener("dispose",o),e.update(l.instanceMatrix,34962),l.instanceColor!==null&&e.update(l.instanceColor,34962)),u}function a(){r=new WeakMap}function o(l){const c=l.target;c.removeEventListener("dispose",o),e.remove(c.instanceMatrix),c.instanceColor!==null&&e.remove(c.instanceColor)}return{update:s,dispose:a}}class Pd extends Ee{constructor(t=null,e=1,n=1,r=1){super(null);this.image={data:t,width:e,height:n,depth:r},this.magFilter=Ge,this.minFilter=Ge,this.wrapR=Xe,this.generateMipmaps=!1,this.flipY=!1,this.needsUpdate=!0}}Pd.prototype.isDataTexture2DArray=!0;class Dd extends Ee{constructor(t=null,e=1,n=1,r=1){super(null);this.image={data:t,width:e,height:n,depth:r},this.magFilter=Ge,this.minFilter=Ge,this.wrapR=Xe,this.generateMipmaps=!1,this.flipY=!1,this.needsUpdate=!0}}Dd.prototype.isDataTexture3D=!0;const Fd=new Ee,nv=new Pd,rv=new Dd,Id=new uo,zd=[],Nd=[],Bd=new Float32Array(16),Od=new Float32Array(9),Ud=new Float32Array(4);function Fr(i,t,e){const n=i[0];if(n<=0||n>0)return i;const r=t*e;let s=zd[r];if(s===void 0&&(s=new Float32Array(r),zd[r]=s),t!==0){n.toArray(s,0);for(let a=1,o=0;a!==t;++a)o+=e,i[a].toArray(s,o)}return s}function ke(i,t){if(i.length!==t.length)return!1;for(let e=0,n=i.length;e<n;e++)if(i[e]!==t[e])return!1;return!0}function De(i,t){for(let e=0,n=t.length;e<n;e++)i[e]=t[e]}function Hd(i,t){let e=Nd[t];e===void 0&&(e=new Int32Array(t),Nd[t]=e);for(let n=0;n!==t;++n)e[n]=i.allocateTextureUnit();return e}function sv(i,t){const e=this.cache;e[0]!==t&&(i.uniform1f(this.addr,t),e[0]=t)}function av(i,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y)&&(i.uniform2f(this.addr,t.x,t.y),e[0]=t.x,e[1]=t.y);else{if(ke(e,t))return;i.uniform2fv(this.addr,t),De(e,t)}}function ov(i,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y||e[2]!==t.z)&&(i.uniform3f(this.addr,t.x,t.y,t.z),e[0]=t.x,e[1]=t.y,e[2]=t.z);else if(t.r!==void 0)(e[0]!==t.r||e[1]!==t.g||e[2]!==t.b)&&(i.uniform3f(this.addr,t.r,t.g,t.b),e[0]=t.r,e[1]=t.g,e[2]=t.b);else{if(ke(e,t))return;i.uniform3fv(this.addr,t),De(e,t)}}function lv(i,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y||e[2]!==t.z||e[3]!==t.w)&&(i.uniform4f(this.addr,t.x,t.y,t.z,t.w),e[0]=t.x,e[1]=t.y,e[2]=t.z,e[3]=t.w);else{if(ke(e,t))return;i.uniform4fv(this.addr,t),De(e,t)}}function cv(i,t){const e=this.cache,n=t.elements;if(n===void 0){if(ke(e,t))return;i.uniformMatrix2fv(this.addr,!1,t),De(e,t)}else{if(ke(e,n))return;Ud.set(n),i.uniformMatrix2fv(this.addr,!1,Ud),De(e,n)}}function hv(i,t){const e=this.cache,n=t.elements;if(n===void 0){if(ke(e,t))return;i.uniformMatrix3fv(this.addr,!1,t),De(e,t)}else{if(ke(e,n))return;Od.set(n),i.uniformMatrix3fv(this.addr,!1,Od),De(e,n)}}function uv(i,t){const e=this.cache,n=t.elements;if(n===void 0){if(ke(e,t))return;i.uniformMatrix4fv(this.addr,!1,t),De(e,t)}else{if(ke(e,n))return;Bd.set(n),i.uniformMatrix4fv(this.addr,!1,Bd),De(e,n)}}function dv(i,t){const e=this.cache;e[0]!==t&&(i.uniform1i(this.addr,t),e[0]=t)}function fv(i,t){const e=this.cache;ke(e,t)||(i.uniform2iv(this.addr,t),De(e,t))}function pv(i,t){const e=this.cache;ke(e,t)||(i.uniform3iv(this.addr,t),De(e,t))}function mv(i,t){const e=this.cache;ke(e,t)||(i.uniform4iv(this.addr,t),De(e,t))}function gv(i,t){const e=this.cache;e[0]!==t&&(i.uniform1ui(this.addr,t),e[0]=t)}function xv(i,t){const e=this.cache;ke(e,t)||(i.uniform2uiv(this.addr,t),De(e,t))}function yv(i,t){const e=this.cache;ke(e,t)||(i.uniform3uiv(this.addr,t),De(e,t))}function _v(i,t){const e=this.cache;ke(e,t)||(i.uniform4uiv(this.addr,t),De(e,t))}function vv(i,t,e){const n=this.cache,r=e.allocateTextureUnit();n[0]!==r&&(i.uniform1i(this.addr,r),n[0]=r),e.safeSetTexture2D(t||Fd,r)}function Mv(i,t,e){const n=this.cache,r=e.allocateTextureUnit();n[0]!==r&&(i.uniform1i(this.addr,r),n[0]=r),e.setTexture3D(t||rv,r)}function bv(i,t,e){const n=this.cache,r=e.allocateTextureUnit();n[0]!==r&&(i.uniform1i(this.addr,r),n[0]=r),e.safeSetTextureCube(t||Id,r)}function wv(i,t,e){const n=this.cache,r=e.allocateTextureUnit();n[0]!==r&&(i.uniform1i(this.addr,r),n[0]=r),e.setTexture2DArray(t||nv,r)}function Sv(i){switch(i){case 5126:return sv;case 35664:return av;case 35665:return ov;case 35666:return lv;case 35674:return cv;case 35675:return hv;case 35676:return uv;case 5124:case 35670:return dv;case 35667:case 35671:return fv;case 35668:case 35672:return pv;case 35669:case 35673:return mv;case 5125:return gv;case 36294:return xv;case 36295:return yv;case 36296:return _v;case 35678:case 36198:case 36298:case 36306:case 35682:return vv;case 35679:case 36299:case 36307:return Mv;case 35680:case 36300:case 36308:case 36293:return bv;case 36289:case 36303:case 36311:case 36292:return wv}}function Ev(i,t){i.uniform1fv(this.addr,t)}function Av(i,t){const e=Fr(t,this.size,2);i.uniform2fv(this.addr,e)}function Tv(i,t){const e=Fr(t,this.size,3);i.uniform3fv(this.addr,e)}function Lv(i,t){const e=Fr(t,this.size,4);i.uniform4fv(this.addr,e)}function Rv(i,t){const e=Fr(t,this.size,4);i.uniformMatrix2fv(this.addr,!1,e)}function Cv(i,t){const e=Fr(t,this.size,9);i.uniformMatrix3fv(this.addr,!1,e)}function Pv(i,t){const e=Fr(t,this.size,16);i.uniformMatrix4fv(this.addr,!1,e)}function Dv(i,t){i.uniform1iv(this.addr,t)}function Fv(i,t){i.uniform2iv(this.addr,t)}function Iv(i,t){i.uniform3iv(this.addr,t)}function zv(i,t){i.uniform4iv(this.addr,t)}function Nv(i,t){i.uniform1uiv(this.addr,t)}function Bv(i,t){i.uniform2uiv(this.addr,t)}function Ov(i,t){i.uniform3uiv(this.addr,t)}function Uv(i,t){i.uniform4uiv(this.addr,t)}function Hv(i,t,e){const n=t.length,r=Hd(e,n);i.uniform1iv(this.addr,r);for(let s=0;s!==n;++s)e.safeSetTexture2D(t[s]||Fd,r[s])}function Gv(i,t,e){const n=t.length,r=Hd(e,n);i.uniform1iv(this.addr,r);for(let s=0;s!==n;++s)e.safeSetTextureCube(t[s]||Id,r[s])}function kv(i){switch(i){case 5126:return Ev;case 35664:return Av;case 35665:return Tv;case 35666:return Lv;case 35674:return Rv;case 35675:return Cv;case 35676:return Pv;case 5124:case 35670:return Dv;case 35667:case 35671:return Fv;case 35668:case 35672:return Iv;case 35669:case 35673:return zv;case 5125:return Nv;case 36294:return Bv;case 36295:return Ov;case 36296:return Uv;case 35678:case 36198:case 36298:case 36306:case 35682:return Hv;case 35680:case 36300:case 36308:case 36293:return Gv}}function Vv(i,t,e){this.id=i,this.addr=e,this.cache=[],this.setValue=Sv(t.type)}function Gd(i,t,e){this.id=i,this.addr=e,this.cache=[],this.size=t.size,this.setValue=kv(t.type)}Gd.prototype.updateCache=function(i){const t=this.cache;i instanceof Float32Array&&t.length!==i.length&&(this.cache=new Float32Array(i.length)),De(t,i)};function kd(i){this.id=i,this.seq=[],this.map={}}kd.prototype.setValue=function(i,t,e){const n=this.seq;for(let r=0,s=n.length;r!==s;++r){const a=n[r];a.setValue(i,t[a.id],e)}};const Pc=/(\w+)(\])?(\[|\.)?/g;function Vd(i,t){i.seq.push(t),i.map[t.id]=t}function Wv(i,t,e){const n=i.name,r=n.length;for(Pc.lastIndex=0;;){const s=Pc.exec(n),a=Pc.lastIndex;let o=s[1];const l=s[2]==="]",c=s[3];if(l&&(o=o|0),c===void 0||c==="["&&a+2===r){Vd(e,c===void 0?new Vv(o,i,t):new Gd(o,i,t));break}else{let u=e.map[o];u===void 0&&(u=new kd(o),Vd(e,u)),e=u}}}function _n(i,t){this.seq=[],this.map={};const e=i.getProgramParameter(t,35718);for(let n=0;n<e;++n){const r=i.getActiveUniform(t,n),s=i.getUniformLocation(t,r.name);Wv(r,s,this)}}_n.prototype.setValue=function(i,t,e,n){const r=this.map[t];r!==void 0&&r.setValue(i,e,n)};_n.prototype.setOptional=function(i,t,e){const n=t[e];n!==void 0&&this.setValue(i,e,n)};_n.upload=function(i,t,e,n){for(let r=0,s=t.length;r!==s;++r){const a=t[r],o=e[a.id];o.needsUpdate!==!1&&a.setValue(i,o.value,n)}};_n.seqWithValue=function(i,t){const e=[];for(let n=0,r=i.length;n!==r;++n){const s=i[n];s.id in t&&e.push(s)}return e};function Wd(i,t,e){const n=i.createShader(t);return i.shaderSource(n,e),i.compileShader(n),n}let $v=0;function Xv(i){const t=i.split(`
`);for(let e=0;e<t.length;e++)t[e]=e+1+": "+t[e];return t.join(`
`)}function $d(i){switch(i){case Ns:return["Linear","( value )"];case fd:return["sRGB","( value )"];case Yx:return["RGBE","( value )"];case Zx:return["RGBM","( value, 7.0 )"];case Jx:return["RGBM","( value, 16.0 )"];case Qx:return["RGBD","( value, 256.0 )"];case qx:return["Gamma","( value, float( GAMMA_FACTOR ) )"];case jx:return["LogLuv","( value )"];default:return console.warn("THREE.WebGLProgram: Unsupported encoding:",i),["Linear","( value )"]}}function Xd(i,t,e){const n=i.getShaderParameter(t,35713),r=i.getShaderInfoLog(t).trim();if(n&&r==="")return"";const s=i.getShaderSource(t);return"THREE.WebGLShader: gl.getShaderInfoLog() "+e+`
`+r+Xv(s)}function $s(i,t){const e=$d(t);return"vec4 "+i+"( vec4 value ) { return "+e[0]+"ToLinear"+e[1]+"; }"}function qv(i,t){const e=$d(t);return"vec4 "+i+"( vec4 value ) { return LinearTo"+e[0]+e[1]+"; }"}function Yv(i,t){let e;switch(t){case Xg:e="Linear";break;case qg:e="Reinhard";break;case Yg:e="OptimizedCineon";break;case jg:e="ACESFilmic";break;case Zg:e="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",t),e="Linear"}return"vec3 "+i+"( vec3 color ) { return "+e+"ToneMapping( color ); }"}function jv(i){return[i.extensionDerivatives||i.envMapCubeUV||i.bumpMap||i.tangentSpaceNormalMap||i.clearcoatNormalMap||i.flatShading||i.shaderID==="physical"?"#extension GL_OES_standard_derivatives : enable":"",(i.extensionFragDepth||i.logarithmicDepthBuffer)&&i.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",i.extensionDrawBuffers&&i.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(i.extensionShaderTextureLOD||i.envMap)&&i.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(Xs).join(`
`)}function Zv(i){const t=[];for(const e in i){const n=i[e];n!==!1&&t.push("#define "+e+" "+n)}return t.join(`
`)}function Jv(i,t){const e={},n=i.getProgramParameter(t,35721);for(let r=0;r<n;r++){const a=i.getActiveAttrib(t,r).name;e[a]=i.getAttribLocation(t,a)}return e}function Xs(i){return i!==""}function qd(i,t){return i.replace(/NUM_DIR_LIGHTS/g,t.numDirLights).replace(/NUM_SPOT_LIGHTS/g,t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,t.numPointLights).replace(/NUM_HEMI_LIGHTS/g,t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g,t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,t.numPointLightShadows)}function Yd(i,t){return i.replace(/NUM_CLIPPING_PLANES/g,t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,t.numClippingPlanes-t.numClipIntersection)}const Qv=/^[ \t]*#include +<([\w\d./]+)>/gm;function Dc(i){return i.replace(Qv,Kv)}function Kv(i,t){const e=kt[t];if(e===void 0)throw new Error("Can not resolve #include <"+t+">");return Dc(e)}const tM=/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,eM=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function jd(i){return i.replace(eM,Zd).replace(tM,iM)}function iM(i,t,e,n){return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."),Zd(i,t,e,n)}function Zd(i,t,e,n){let r="";for(let s=parseInt(t);s<parseInt(e);s++)r+=n.replace(/\[\s*i\s*\]/g,"[ "+s+" ]").replace(/UNROLLED_LOOP_INDEX/g,s);return r}function Jd(i){let t="precision "+i.precision+` float;
precision `+i.precision+" int;";return i.precision==="highp"?t+=`
#define HIGH_PRECISION`:i.precision==="mediump"?t+=`
#define MEDIUM_PRECISION`:i.precision==="lowp"&&(t+=`
#define LOW_PRECISION`),t}function nM(i){let t="SHADOWMAP_TYPE_BASIC";return i.shadowMapType===ku?t="SHADOWMAP_TYPE_PCF":i.shadowMapType===Sg?t="SHADOWMAP_TYPE_PCF_SOFT":i.shadowMapType===Cs&&(t="SHADOWMAP_TYPE_VSM"),t}function rM(i){let t="ENVMAP_TYPE_CUBE";if(i.envMap)switch(i.envMapMode){case kl:case Vl:t="ENVMAP_TYPE_CUBE";break;case Wl:case $l:t="ENVMAP_TYPE_CUBE_UV";break}return t}function sM(i){let t="ENVMAP_MODE_REFLECTION";if(i.envMap)switch(i.envMapMode){case Vl:case $l:t="ENVMAP_MODE_REFRACTION";break}return t}function aM(i){let t="ENVMAP_BLENDING_NONE";if(i.envMap)switch(i.combine){case Ua:t="ENVMAP_BLENDING_MULTIPLY";break;case Wg:t="ENVMAP_BLENDING_MIX";break;case $g:t="ENVMAP_BLENDING_ADD";break}return t}function oM(i,t,e,n){const r=i.getContext(),s=e.defines;let a=e.vertexShader,o=e.fragmentShader;const l=nM(e),c=rM(e),h=sM(e),u=aM(e),d=i.gammaFactor>0?i.gammaFactor:1,f=e.isWebGL2?"":jv(e),p=Zv(s),x=r.createProgram();let y,g,m=e.glslVersion?"#version "+e.glslVersion+`
`:"";e.isRawShaderMaterial?(y=[p].filter(Xs).join(`
`),y.length>0&&(y+=`
`),g=[f,p].filter(Xs).join(`
`),g.length>0&&(g+=`
`)):(y=[Jd(e),"#define SHADER_NAME "+e.shaderName,p,e.instancing?"#define USE_INSTANCING":"",e.instancingColor?"#define USE_INSTANCING_COLOR":"",e.supportsVertexTextures?"#define VERTEX_TEXTURES":"","#define GAMMA_FACTOR "+d,"#define MAX_BONES "+e.maxBones,e.useFog&&e.fog?"#define USE_FOG":"",e.useFog&&e.fogExp2?"#define FOG_EXP2":"",e.map?"#define USE_MAP":"",e.envMap?"#define USE_ENVMAP":"",e.envMap?"#define "+h:"",e.lightMap?"#define USE_LIGHTMAP":"",e.aoMap?"#define USE_AOMAP":"",e.emissiveMap?"#define USE_EMISSIVEMAP":"",e.bumpMap?"#define USE_BUMPMAP":"",e.normalMap?"#define USE_NORMALMAP":"",e.normalMap&&e.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",e.normalMap&&e.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",e.clearcoatMap?"#define USE_CLEARCOATMAP":"",e.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",e.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",e.displacementMap&&e.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",e.specularMap?"#define USE_SPECULARMAP":"",e.roughnessMap?"#define USE_ROUGHNESSMAP":"",e.metalnessMap?"#define USE_METALNESSMAP":"",e.alphaMap?"#define USE_ALPHAMAP":"",e.transmissionMap?"#define USE_TRANSMISSIONMAP":"",e.vertexTangents?"#define USE_TANGENT":"",e.vertexColors?"#define USE_COLOR":"",e.vertexAlphas?"#define USE_COLOR_ALPHA":"",e.vertexUvs?"#define USE_UV":"",e.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",e.flatShading?"#define FLAT_SHADED":"",e.skinning?"#define USE_SKINNING":"",e.useVertexTexture?"#define BONE_TEXTURE":"",e.morphTargets?"#define USE_MORPHTARGETS":"",e.morphNormals&&e.flatShading===!1?"#define USE_MORPHNORMALS":"",e.doubleSided?"#define DOUBLE_SIDED":"",e.flipSided?"#define FLIP_SIDED":"",e.shadowMapEnabled?"#define USE_SHADOWMAP":"",e.shadowMapEnabled?"#define "+l:"",e.sizeAttenuation?"#define USE_SIZEATTENUATION":"",e.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",e.logarithmicDepthBuffer&&e.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","	attribute vec4 color;","#elif defined( USE_COLOR )","	attribute vec3 color;","#endif","#ifdef USE_MORPHTARGETS","	attribute vec3 morphTarget0;","	attribute vec3 morphTarget1;","	attribute vec3 morphTarget2;","	attribute vec3 morphTarget3;","	#ifdef USE_MORPHNORMALS","		attribute vec3 morphNormal0;","		attribute vec3 morphNormal1;","		attribute vec3 morphNormal2;","		attribute vec3 morphNormal3;","	#else","		attribute vec3 morphTarget4;","		attribute vec3 morphTarget5;","		attribute vec3 morphTarget6;","		attribute vec3 morphTarget7;","	#endif","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif",`
`].filter(Xs).join(`
`),g=[f,Jd(e),"#define SHADER_NAME "+e.shaderName,p,e.alphaTest?"#define ALPHATEST "+e.alphaTest+(e.alphaTest%1?"":".0"):"","#define GAMMA_FACTOR "+d,e.useFog&&e.fog?"#define USE_FOG":"",e.useFog&&e.fogExp2?"#define FOG_EXP2":"",e.map?"#define USE_MAP":"",e.matcap?"#define USE_MATCAP":"",e.envMap?"#define USE_ENVMAP":"",e.envMap?"#define "+c:"",e.envMap?"#define "+h:"",e.envMap?"#define "+u:"",e.lightMap?"#define USE_LIGHTMAP":"",e.aoMap?"#define USE_AOMAP":"",e.emissiveMap?"#define USE_EMISSIVEMAP":"",e.bumpMap?"#define USE_BUMPMAP":"",e.normalMap?"#define USE_NORMALMAP":"",e.normalMap&&e.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",e.normalMap&&e.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",e.clearcoatMap?"#define USE_CLEARCOATMAP":"",e.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",e.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",e.specularMap?"#define USE_SPECULARMAP":"",e.roughnessMap?"#define USE_ROUGHNESSMAP":"",e.metalnessMap?"#define USE_METALNESSMAP":"",e.alphaMap?"#define USE_ALPHAMAP":"",e.sheen?"#define USE_SHEEN":"",e.transmissionMap?"#define USE_TRANSMISSIONMAP":"",e.vertexTangents?"#define USE_TANGENT":"",e.vertexColors||e.instancingColor?"#define USE_COLOR":"",e.vertexAlphas?"#define USE_COLOR_ALPHA":"",e.vertexUvs?"#define USE_UV":"",e.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",e.gradientMap?"#define USE_GRADIENTMAP":"",e.flatShading?"#define FLAT_SHADED":"",e.doubleSided?"#define DOUBLE_SIDED":"",e.flipSided?"#define FLIP_SIDED":"",e.shadowMapEnabled?"#define USE_SHADOWMAP":"",e.shadowMapEnabled?"#define "+l:"",e.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",e.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":"",e.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",e.logarithmicDepthBuffer&&e.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"",(e.extensionShaderTextureLOD||e.envMap)&&e.rendererExtensionShaderTextureLod?"#define TEXTURE_LOD_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",e.toneMapping!==Fs?"#define TONE_MAPPING":"",e.toneMapping!==Fs?kt.tonemapping_pars_fragment:"",e.toneMapping!==Fs?Yv("toneMapping",e.toneMapping):"",e.dithering?"#define DITHERING":"",kt.encodings_pars_fragment,e.map?$s("mapTexelToLinear",e.mapEncoding):"",e.matcap?$s("matcapTexelToLinear",e.matcapEncoding):"",e.envMap?$s("envMapTexelToLinear",e.envMapEncoding):"",e.emissiveMap?$s("emissiveMapTexelToLinear",e.emissiveMapEncoding):"",e.lightMap?$s("lightMapTexelToLinear",e.lightMapEncoding):"",qv("linearToOutputTexel",e.outputEncoding),e.depthPacking?"#define DEPTH_PACKING "+e.depthPacking:"",`
`].filter(Xs).join(`
`)),a=Dc(a),a=qd(a,e),a=Yd(a,e),o=Dc(o),o=qd(o,e),o=Yd(o,e),a=jd(a),o=jd(o),e.isWebGL2&&e.isRawShaderMaterial!==!0&&(m=`#version 300 es
`,y=["#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+y,g=["#define varying in",e.glslVersion===pd?"":"out highp vec4 pc_fragColor;",e.glslVersion===pd?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+g);const E=m+y+a,w=m+g+o,S=Wd(r,35633,E),_=Wd(r,35632,w);if(r.attachShader(x,S),r.attachShader(x,_),e.index0AttributeName!==void 0?r.bindAttribLocation(x,0,e.index0AttributeName):e.morphTargets===!0&&r.bindAttribLocation(x,0,"position"),r.linkProgram(x),i.debug.checkShaderErrors){const N=r.getProgramInfoLog(x).trim(),G=r.getShaderInfoLog(S).trim(),D=r.getShaderInfoLog(_).trim();let V=!0,R=!0;if(r.getProgramParameter(x,35714)===!1){V=!1;const L=Xd(r,S,"vertex"),P=Xd(r,_,"fragment");console.error("THREE.WebGLProgram: shader error: ",r.getError(),"35715",r.getProgramParameter(x,35715),"gl.getProgramInfoLog",N,L,P)}else N!==""?console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()",N):(G===""||D==="")&&(R=!1);R&&(this.diagnostics={runnable:V,programLog:N,vertexShader:{log:G,prefix:y},fragmentShader:{log:D,prefix:g}})}r.deleteShader(S),r.deleteShader(_);let T;this.getUniforms=function(){return T===void 0&&(T=new _n(r,x)),T};let B;return this.getAttributes=function(){return B===void 0&&(B=Jv(r,x)),B},this.destroy=function(){n.releaseStatesOfProgram(this),r.deleteProgram(x),this.program=void 0},this.name=e.shaderName,this.id=$v++,this.cacheKey=t,this.usedTimes=1,this.program=x,this.vertexShader=S,this.fragmentShader=_,this}function lM(i,t,e,n,r,s){const a=[],o=n.isWebGL2,l=n.logarithmicDepthBuffer,c=n.floatVertexTextures,h=n.maxVertexUniforms,u=n.vertexTextures;let d=n.precision;const f={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"},p=["precision","isWebGL2","supportsVertexTextures","outputEncoding","instancing","instancingColor","map","mapEncoding","matcap","matcapEncoding","envMap","envMapMode","envMapEncoding","envMapCubeUV","lightMap","lightMapEncoding","aoMap","emissiveMap","emissiveMapEncoding","bumpMap","normalMap","objectSpaceNormalMap","tangentSpaceNormalMap","clearcoatMap","clearcoatRoughnessMap","clearcoatNormalMap","displacementMap","specularMap","roughnessMap","metalnessMap","gradientMap","alphaMap","combine","vertexColors","vertexAlphas","vertexTangents","vertexUvs","uvsVertexOnly","fog","useFog","fogExp2","flatShading","sizeAttenuation","logarithmicDepthBuffer","skinning","maxBones","useVertexTexture","morphTargets","morphNormals","premultipliedAlpha","numDirLights","numPointLights","numSpotLights","numHemiLights","numRectAreaLights","numDirLightShadows","numPointLightShadows","numSpotLightShadows","shadowMapEnabled","shadowMapType","toneMapping","physicallyCorrectLights","alphaTest","doubleSided","flipSided","numClippingPlanes","numClipIntersection","depthPacking","dithering","sheen","transmissionMap"];function x(_){const B=_.skeleton.bones;if(c)return 1024;{const G=Math.floor((h-20)/4),D=Math.min(G,B.length);return D<B.length?(console.warn("THREE.WebGLRenderer: Skeleton has "+B.length+" bones. This GPU supports "+D+"."),0):D}}function y(_){let T;return _&&_.isTexture?T=_.encoding:_&&_.isWebGLRenderTarget?(console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."),T=_.texture.encoding):T=Ns,T}function g(_,T,B,N,G){const D=N.fog,V=_.isMeshStandardMaterial?N.environment:null,R=t.get(_.envMap||V),L=f[_.type],P=G.isSkinnedMesh?x(G):0;_.precision!==null&&(d=n.getMaxPrecision(_.precision),d!==_.precision&&console.warn("THREE.WebGLProgram.getParameters:",_.precision,"not supported, using",d,"instead."));let F,W;if(L){const Q=Ci[L];F=Q.vertexShader,W=Q.fragmentShader}else F=_.vertexShader,W=_.fragmentShader;const j=i.getRenderTarget();return{isWebGL2:o,shaderID:L,shaderName:_.type,vertexShader:F,fragmentShader:W,defines:_.defines,isRawShaderMaterial:_.isRawShaderMaterial===!0,glslVersion:_.glslVersion,precision:d,instancing:G.isInstancedMesh===!0,instancingColor:G.isInstancedMesh===!0&&G.instanceColor!==null,supportsVertexTextures:u,outputEncoding:j!==null?y(j.texture):i.outputEncoding,map:!!_.map,mapEncoding:y(_.map),matcap:!!_.matcap,matcapEncoding:y(_.matcap),envMap:!!R,envMapMode:R&&R.mapping,envMapEncoding:y(R),envMapCubeUV:!!R&&(R.mapping===Wl||R.mapping===$l),lightMap:!!_.lightMap,lightMapEncoding:y(_.lightMap),aoMap:!!_.aoMap,emissiveMap:!!_.emissiveMap,emissiveMapEncoding:y(_.emissiveMap),bumpMap:!!_.bumpMap,normalMap:!!_.normalMap,objectSpaceNormalMap:_.normalMapType===e0,tangentSpaceNormalMap:_.normalMapType===pr,clearcoatMap:!!_.clearcoatMap,clearcoatRoughnessMap:!!_.clearcoatRoughnessMap,clearcoatNormalMap:!!_.clearcoatNormalMap,displacementMap:!!_.displacementMap,roughnessMap:!!_.roughnessMap,metalnessMap:!!_.metalnessMap,specularMap:!!_.specularMap,alphaMap:!!_.alphaMap,gradientMap:!!_.gradientMap,sheen:!!_.sheen,transmissionMap:!!_.transmissionMap,combine:_.combine,vertexTangents:_.normalMap&&_.vertexTangents,vertexColors:_.vertexColors,vertexAlphas:_.vertexColors===!0&&G.geometry.attributes.color&&G.geometry.attributes.color.itemSize===4,vertexUvs:!!_.map||!!_.bumpMap||!!_.normalMap||!!_.specularMap||!!_.alphaMap||!!_.emissiveMap||!!_.roughnessMap||!!_.metalnessMap||!!_.clearcoatMap||!!_.clearcoatRoughnessMap||!!_.clearcoatNormalMap||!!_.displacementMap||!!_.transmissionMap,uvsVertexOnly:!(!!_.map||!!_.bumpMap||!!_.normalMap||!!_.specularMap||!!_.alphaMap||!!_.emissiveMap||!!_.roughnessMap||!!_.metalnessMap||!!_.clearcoatNormalMap||!!_.transmissionMap)&&!!_.displacementMap,fog:!!D,useFog:_.fog,fogExp2:D&&D.isFogExp2,flatShading:!!_.flatShading,sizeAttenuation:_.sizeAttenuation,logarithmicDepthBuffer:l,skinning:_.skinning&&P>0,maxBones:P,useVertexTexture:c,morphTargets:_.morphTargets,morphNormals:_.morphNormals,numDirLights:T.directional.length,numPointLights:T.point.length,numSpotLights:T.spot.length,numRectAreaLights:T.rectArea.length,numHemiLights:T.hemi.length,numDirLightShadows:T.directionalShadowMap.length,numPointLightShadows:T.pointShadowMap.length,numSpotLightShadows:T.spotShadowMap.length,numClippingPlanes:s.numPlanes,numClipIntersection:s.numIntersection,dithering:_.dithering,shadowMapEnabled:i.shadowMap.enabled&&B.length>0,shadowMapType:i.shadowMap.type,toneMapping:_.toneMapped?i.toneMapping:Fs,physicallyCorrectLights:i.physicallyCorrectLights,premultipliedAlpha:_.premultipliedAlpha,alphaTest:_.alphaTest,doubleSided:_.side===Oa,flipSided:_.side===ye,depthPacking:_.depthPacking!==void 0?_.depthPacking:!1,index0AttributeName:_.index0AttributeName,extensionDerivatives:_.extensions&&_.extensions.derivatives,extensionFragDepth:_.extensions&&_.extensions.fragDepth,extensionDrawBuffers:_.extensions&&_.extensions.drawBuffers,extensionShaderTextureLOD:_.extensions&&_.extensions.shaderTextureLOD,rendererExtensionFragDepth:o||e.has("EXT_frag_depth"),rendererExtensionDrawBuffers:o||e.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:o||e.has("EXT_shader_texture_lod"),customProgramCacheKey:_.customProgramCacheKey()}}function m(_){const T=[];if(_.shaderID?T.push(_.shaderID):(T.push(_.fragmentShader),T.push(_.vertexShader)),_.defines!==void 0)for(const B in _.defines)T.push(B),T.push(_.defines[B]);if(_.isRawShaderMaterial===!1){for(let B=0;B<p.length;B++)T.push(_[p[B]]);T.push(i.outputEncoding),T.push(i.gammaFactor)}return T.push(_.customProgramCacheKey),T.join()}function E(_){const T=f[_.type];let B;if(T){const N=Ci[T];B=x0.clone(N.uniforms)}else B=_.uniforms;return B}function w(_,T){let B;for(let N=0,G=a.length;N<G;N++){const D=a[N];if(D.cacheKey===T){B=D,++B.usedTimes;break}}return B===void 0&&(B=new oM(i,T,_,r),a.push(B)),B}function S(_){if(--_.usedTimes==0){const T=a.indexOf(_);a[T]=a[a.length-1],a.pop(),_.destroy()}}return{getParameters:g,getProgramCacheKey:m,getUniforms:E,acquireProgram:w,releaseProgram:S,programs:a}}function cM(){let i=new WeakMap;function t(s){let a=i.get(s);return a===void 0&&(a={},i.set(s,a)),a}function e(s){i.delete(s)}function n(s,a,o){i.get(s)[a]=o}function r(){i=new WeakMap}return{get:t,remove:e,update:n,dispose:r}}function hM(i,t){return i.groupOrder!==t.groupOrder?i.groupOrder-t.groupOrder:i.renderOrder!==t.renderOrder?i.renderOrder-t.renderOrder:i.program!==t.program?i.program.id-t.program.id:i.material.id!==t.material.id?i.material.id-t.material.id:i.z!==t.z?i.z-t.z:i.id-t.id}function uM(i,t){return i.groupOrder!==t.groupOrder?i.groupOrder-t.groupOrder:i.renderOrder!==t.renderOrder?i.renderOrder-t.renderOrder:i.z!==t.z?t.z-i.z:i.id-t.id}function Qd(i){const t=[];let e=0;const n=[],r=[],s={id:-1};function a(){e=0,n.length=0,r.length=0}function o(d,f,p,x,y,g){let m=t[e];const E=i.get(p);return m===void 0?(m={id:d.id,object:d,geometry:f,material:p,program:E.program||s,groupOrder:x,renderOrder:d.renderOrder,z:y,group:g},t[e]=m):(m.id=d.id,m.object=d,m.geometry=f,m.material=p,m.program=E.program||s,m.groupOrder=x,m.renderOrder=d.renderOrder,m.z=y,m.group=g),e++,m}function l(d,f,p,x,y,g){const m=o(d,f,p,x,y,g);(p.transparent===!0?r:n).push(m)}function c(d,f,p,x,y,g){const m=o(d,f,p,x,y,g);(p.transparent===!0?r:n).unshift(m)}function h(d,f){n.length>1&&n.sort(d||hM),r.length>1&&r.sort(f||uM)}function u(){for(let d=e,f=t.length;d<f;d++){const p=t[d];if(p.id===null)break;p.id=null,p.object=null,p.geometry=null,p.material=null,p.program=null,p.group=null}}return{opaque:n,transparent:r,init:a,push:l,unshift:c,finish:u,sort:h}}function dM(i){let t=new WeakMap;function e(r,s){let a;return t.has(r)===!1?(a=new Qd(i),t.set(r,[a])):s>=t.get(r).length?(a=new Qd(i),t.get(r).push(a)):a=t.get(r)[s],a}function n(){t=new WeakMap}return{get:e,dispose:n}}function fM(){const i={};return{get:function(t){if(i[t.id]!==void 0)return i[t.id];let e;switch(t.type){case"DirectionalLight":e={direction:new U,color:new zt};break;case"SpotLight":e={position:new U,direction:new U,color:new zt,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":e={position:new U,color:new zt,distance:0,decay:0};break;case"HemisphereLight":e={direction:new U,skyColor:new zt,groundColor:new zt};break;case"RectAreaLight":e={color:new zt,position:new U,halfWidth:new U,halfHeight:new U};break}return i[t.id]=e,e}}}function pM(){const i={};return{get:function(t){if(i[t.id]!==void 0)return i[t.id];let e;switch(t.type){case"DirectionalLight":e={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new lt};break;case"SpotLight":e={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new lt};break;case"PointLight":e={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new lt,shadowCameraNear:1,shadowCameraFar:1e3};break}return i[t.id]=e,e}}}let mM=0;function gM(i,t){return(t.castShadow?1:0)-(i.castShadow?1:0)}function xM(i,t){const e=new fM,n=pM(),r={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadow:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[]};for(let h=0;h<9;h++)r.probe.push(new U);const s=new U,a=new It,o=new It;function l(h){let u=0,d=0,f=0;for(let T=0;T<9;T++)r.probe[T].set(0,0,0);let p=0,x=0,y=0,g=0,m=0,E=0,w=0,S=0;h.sort(gM);for(let T=0,B=h.length;T<B;T++){const N=h[T],G=N.color,D=N.intensity,V=N.distance,R=N.shadow&&N.shadow.map?N.shadow.map.texture:null;if(N.isAmbientLight)u+=G.r*D,d+=G.g*D,f+=G.b*D;else if(N.isLightProbe)for(let L=0;L<9;L++)r.probe[L].addScaledVector(N.sh.coefficients[L],D);else if(N.isDirectionalLight){const L=e.get(N);if(L.color.copy(N.color).multiplyScalar(N.intensity),N.castShadow){const P=N.shadow,F=n.get(N);F.shadowBias=P.bias,F.shadowNormalBias=P.normalBias,F.shadowRadius=P.radius,F.shadowMapSize=P.mapSize,r.directionalShadow[p]=F,r.directionalShadowMap[p]=R,r.directionalShadowMatrix[p]=N.shadow.matrix,E++}r.directional[p]=L,p++}else if(N.isSpotLight){const L=e.get(N);if(L.position.setFromMatrixPosition(N.matrixWorld),L.color.copy(G).multiplyScalar(D),L.distance=V,L.coneCos=Math.cos(N.angle),L.penumbraCos=Math.cos(N.angle*(1-N.penumbra)),L.decay=N.decay,N.castShadow){const P=N.shadow,F=n.get(N);F.shadowBias=P.bias,F.shadowNormalBias=P.normalBias,F.shadowRadius=P.radius,F.shadowMapSize=P.mapSize,r.spotShadow[y]=F,r.spotShadowMap[y]=R,r.spotShadowMatrix[y]=N.shadow.matrix,S++}r.spot[y]=L,y++}else if(N.isRectAreaLight){const L=e.get(N);L.color.copy(G).multiplyScalar(D),L.halfWidth.set(N.width*.5,0,0),L.halfHeight.set(0,N.height*.5,0),r.rectArea[g]=L,g++}else if(N.isPointLight){const L=e.get(N);if(L.color.copy(N.color).multiplyScalar(N.intensity),L.distance=N.distance,L.decay=N.decay,N.castShadow){const P=N.shadow,F=n.get(N);F.shadowBias=P.bias,F.shadowNormalBias=P.normalBias,F.shadowRadius=P.radius,F.shadowMapSize=P.mapSize,F.shadowCameraNear=P.camera.near,F.shadowCameraFar=P.camera.far,r.pointShadow[x]=F,r.pointShadowMap[x]=R,r.pointShadowMatrix[x]=N.shadow.matrix,w++}r.point[x]=L,x++}else if(N.isHemisphereLight){const L=e.get(N);L.skyColor.copy(N.color).multiplyScalar(D),L.groundColor.copy(N.groundColor).multiplyScalar(D),r.hemi[m]=L,m++}}g>0&&(t.isWebGL2||i.has("OES_texture_float_linear")===!0?(r.rectAreaLTC1=_t.LTC_FLOAT_1,r.rectAreaLTC2=_t.LTC_FLOAT_2):i.has("OES_texture_half_float_linear")===!0?(r.rectAreaLTC1=_t.LTC_HALF_1,r.rectAreaLTC2=_t.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),r.ambient[0]=u,r.ambient[1]=d,r.ambient[2]=f;const _=r.hash;(_.directionalLength!==p||_.pointLength!==x||_.spotLength!==y||_.rectAreaLength!==g||_.hemiLength!==m||_.numDirectionalShadows!==E||_.numPointShadows!==w||_.numSpotShadows!==S)&&(r.directional.length=p,r.spot.length=y,r.rectArea.length=g,r.point.length=x,r.hemi.length=m,r.directionalShadow.length=E,r.directionalShadowMap.length=E,r.pointShadow.length=w,r.pointShadowMap.length=w,r.spotShadow.length=S,r.spotShadowMap.length=S,r.directionalShadowMatrix.length=E,r.pointShadowMatrix.length=w,r.spotShadowMatrix.length=S,_.directionalLength=p,_.pointLength=x,_.spotLength=y,_.rectAreaLength=g,_.hemiLength=m,_.numDirectionalShadows=E,_.numPointShadows=w,_.numSpotShadows=S,r.version=mM++)}function c(h,u){let d=0,f=0,p=0,x=0,y=0;const g=u.matrixWorldInverse;for(let m=0,E=h.length;m<E;m++){const w=h[m];if(w.isDirectionalLight){const S=r.directional[d];S.direction.setFromMatrixPosition(w.matrixWorld),s.setFromMatrixPosition(w.target.matrixWorld),S.direction.sub(s),S.direction.transformDirection(g),d++}else if(w.isSpotLight){const S=r.spot[p];S.position.setFromMatrixPosition(w.matrixWorld),S.position.applyMatrix4(g),S.direction.setFromMatrixPosition(w.matrixWorld),s.setFromMatrixPosition(w.target.matrixWorld),S.direction.sub(s),S.direction.transformDirection(g),p++}else if(w.isRectAreaLight){const S=r.rectArea[x];S.position.setFromMatrixPosition(w.matrixWorld),S.position.applyMatrix4(g),o.identity(),a.copy(w.matrixWorld),a.premultiply(g),o.extractRotation(a),S.halfWidth.set(w.width*.5,0,0),S.halfHeight.set(0,w.height*.5,0),S.halfWidth.applyMatrix4(o),S.halfHeight.applyMatrix4(o),x++}else if(w.isPointLight){const S=r.point[f];S.position.setFromMatrixPosition(w.matrixWorld),S.position.applyMatrix4(g),f++}else if(w.isHemisphereLight){const S=r.hemi[y];S.direction.setFromMatrixPosition(w.matrixWorld),S.direction.transformDirection(g),S.direction.normalize(),y++}}}return{setup:l,setupView:c,state:r}}function Kd(i,t){const e=new xM(i,t),n=[],r=[];function s(){n.length=0,r.length=0}function a(u){n.push(u)}function o(u){r.push(u)}function l(){e.setup(n)}function c(u){e.setupView(n,u)}return{init:s,state:{lightsArray:n,shadowsArray:r,lights:e},setupLights:l,setupLightsView:c,pushLight:a,pushShadow:o}}function yM(i,t){let e=new WeakMap;function n(s,a=0){let o;return e.has(s)===!1?(o=new Kd(i,t),e.set(s,[o])):a>=e.get(s).length?(o=new Kd(i,t),e.get(s).push(o)):o=e.get(s)[a],o}function r(){e=new WeakMap}return{get:n,dispose:r}}class tf extends se{constructor(t){super();this.type="MeshDepthMaterial",this.depthPacking=Kx,this.skinning=!1,this.morphTargets=!1,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.setValues(t)}copy(t){return super.copy(t),this.depthPacking=t.depthPacking,this.skinning=t.skinning,this.morphTargets=t.morphTargets,this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this}}tf.prototype.isMeshDepthMaterial=!0;class ef extends se{constructor(t){super();this.type="MeshDistanceMaterial",this.referencePosition=new U,this.nearDistance=1,this.farDistance=1e3,this.skinning=!1,this.morphTargets=!1,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.fog=!1,this.setValues(t)}copy(t){return super.copy(t),this.referencePosition.copy(t.referencePosition),this.nearDistance=t.nearDistance,this.farDistance=t.farDistance,this.skinning=t.skinning,this.morphTargets=t.morphTargets,this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this}}ef.prototype.isMeshDistanceMaterial=!0;var _M=`uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	float mean = 0.0;
	float squared_mean = 0.0;
	float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );
	for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean * HALF_SAMPLE_RATE;
	squared_mean = squared_mean * HALF_SAMPLE_RATE;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`,vM=`void main() {
	gl_Position = vec4( position, 1.0 );
}`;function nf(i,t,e){let n=new po;const r=new lt,s=new lt,a=new Yt,o=[],l=[],c={},h=e.maxTextureSize,u={0:ye,1:Ba,2:Oa},d=new ni({defines:{SAMPLE_RATE:2/8,HALF_SAMPLE_RATE:1/8},uniforms:{shadow_pass:{value:null},resolution:{value:new lt},radius:{value:4}},vertexShader:vM,fragmentShader:_M}),f=d.clone();f.defines.HORIZONTAL_PASS=1;const p=new $t;p.setAttribute("position",new Gt(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const x=new Te(p,d),y=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=ku,this.render=function(_,T,B){if(y.enabled===!1||y.autoUpdate===!1&&y.needsUpdate===!1||_.length===0)return;const N=i.getRenderTarget(),G=i.getActiveCubeFace(),D=i.getActiveMipmapLevel(),V=i.state;V.setBlending(Ps),V.buffers.color.setClear(1,1,1,1),V.buffers.depth.setTest(!0),V.setScissorTest(!1);for(let R=0,L=_.length;R<L;R++){const P=_[R],F=P.shadow;if(F===void 0){console.warn("THREE.WebGLShadowMap:",P,"has no shadow.");continue}if(F.autoUpdate===!1&&F.needsUpdate===!1)continue;r.copy(F.mapSize);const W=F.getFrameExtents();if(r.multiply(W),s.copy(F.mapSize),(r.x>h||r.y>h)&&(r.x>h&&(s.x=Math.floor(h/W.x),r.x=s.x*W.x,F.mapSize.x=s.x),r.y>h&&(s.y=Math.floor(h/W.y),r.y=s.y*W.y,F.mapSize.y=s.y)),F.map===null&&!F.isPointLightShadow&&this.type===Cs){const Y={minFilter:be,magFilter:be,format:hi};F.map=new $n(r.x,r.y,Y),F.map.texture.name=P.name+".shadowMap",F.mapPass=new $n(r.x,r.y,Y),F.camera.updateProjectionMatrix()}if(F.map===null){const Y={minFilter:Ge,magFilter:Ge,format:hi};F.map=new $n(r.x,r.y,Y),F.map.texture.name=P.name+".shadowMap",F.camera.updateProjectionMatrix()}i.setRenderTarget(F.map),i.clear();const j=F.getViewportCount();for(let Y=0;Y<j;Y++){const Q=F.getViewport(Y);a.set(s.x*Q.x,s.y*Q.y,s.x*Q.z,s.y*Q.w),V.viewport(a),F.updateMatrices(P,Y),n=F.getFrustum(),S(T,B,F.camera,P,this.type)}!F.isPointLightShadow&&this.type===Cs&&g(F,B),F.needsUpdate=!1}y.needsUpdate=!1,i.setRenderTarget(N,G,D)};function g(_,T){const B=t.update(x);d.uniforms.shadow_pass.value=_.map.texture,d.uniforms.resolution.value=_.mapSize,d.uniforms.radius.value=_.radius,i.setRenderTarget(_.mapPass),i.clear(),i.renderBufferDirect(T,null,B,d,x,null),f.uniforms.shadow_pass.value=_.mapPass.texture,f.uniforms.resolution.value=_.mapSize,f.uniforms.radius.value=_.radius,i.setRenderTarget(_.map),i.clear(),i.renderBufferDirect(T,null,B,f,x,null)}function m(_,T,B){const N=_<<0|T<<1|B<<2;let G=o[N];return G===void 0&&(G=new tf({depthPacking:t0,morphTargets:_,skinning:T}),o[N]=G),G}function E(_,T,B){const N=_<<0|T<<1|B<<2;let G=l[N];return G===void 0&&(G=new ef({morphTargets:_,skinning:T}),l[N]=G),G}function w(_,T,B,N,G,D,V){let R=null,L=m,P=_.customDepthMaterial;if(N.isPointLight===!0&&(L=E,P=_.customDistanceMaterial),P===void 0){let F=!1;B.morphTargets===!0&&(F=T.morphAttributes&&T.morphAttributes.position&&T.morphAttributes.position.length>0);let W=!1;_.isSkinnedMesh===!0&&(B.skinning===!0?W=!0:console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:",_));const j=_.isInstancedMesh===!0;R=L(F,W,j)}else R=P;if(i.localClippingEnabled&&B.clipShadows===!0&&B.clippingPlanes.length!==0){const F=R.uuid,W=B.uuid;let j=c[F];j===void 0&&(j={},c[F]=j);let Y=j[W];Y===void 0&&(Y=R.clone(),j[W]=Y),R=Y}return R.visible=B.visible,R.wireframe=B.wireframe,V===Cs?R.side=B.shadowSide!==null?B.shadowSide:B.side:R.side=B.shadowSide!==null?B.shadowSide:u[B.side],R.clipShadows=B.clipShadows,R.clippingPlanes=B.clippingPlanes,R.clipIntersection=B.clipIntersection,R.wireframeLinewidth=B.wireframeLinewidth,R.linewidth=B.linewidth,N.isPointLight===!0&&R.isMeshDistanceMaterial===!0&&(R.referencePosition.setFromMatrixPosition(N.matrixWorld),R.nearDistance=G,R.farDistance=D),R}function S(_,T,B,N,G){if(_.visible===!1)return;if(_.layers.test(T.layers)&&(_.isMesh||_.isLine||_.isPoints)&&(_.castShadow||_.receiveShadow&&G===Cs)&&(!_.frustumCulled||n.intersectsObject(_))){_.modelViewMatrix.multiplyMatrices(B.matrixWorldInverse,_.matrixWorld);const R=t.update(_),L=_.material;if(Array.isArray(L)){const P=R.groups;for(let F=0,W=P.length;F<W;F++){const j=P[F],Y=L[j.materialIndex];if(Y&&Y.visible){const Q=w(_,R,Y,N,B.near,B.far,G);i.renderBufferDirect(B,null,R,Q,_,j)}}}else if(L.visible){const P=w(_,R,L,N,B.near,B.far,G);i.renderBufferDirect(B,null,R,P,_,null)}}const V=_.children;for(let R=0,L=V.length;R<L;R++)S(V[R],T,B,N,G)}}function MM(i,t,e){const n=e.isWebGL2;function r(){let A=!1;const C=new Yt;let q=null;const et=new Yt(0,0,0,0);return{setMask:function(k){q!==k&&!A&&(i.colorMask(k,k,k,k),q=k)},setLocked:function(k){A=k},setClear:function(k,at,Rt,Nt,xe){xe===!0&&(k*=Nt,at*=Nt,Rt*=Nt),C.set(k,at,Rt,Nt),et.equals(C)===!1&&(i.clearColor(k,at,Rt,Nt),et.copy(C))},reset:function(){A=!1,q=null,et.set(-1,0,0,0)}}}function s(){let A=!1,C=null,q=null,et=null;return{setTest:function(k){k?st(2929):ct(2929)},setMask:function(k){C!==k&&!A&&(i.depthMask(k),C=k)},setFunc:function(k){if(q!==k){if(k)switch(k){case Bg:i.depthFunc(512);break;case Og:i.depthFunc(519);break;case Ug:i.depthFunc(513);break;case Gl:i.depthFunc(515);break;case Hg:i.depthFunc(514);break;case Gg:i.depthFunc(518);break;case kg:i.depthFunc(516);break;case Vg:i.depthFunc(517);break;default:i.depthFunc(515)}else i.depthFunc(515);q=k}},setLocked:function(k){A=k},setClear:function(k){et!==k&&(i.clearDepth(k),et=k)},reset:function(){A=!1,C=null,q=null,et=null}}}function a(){let A=!1,C=null,q=null,et=null,k=null,at=null,Rt=null,Nt=null,xe=null;return{setTest:function(Ft){A||(Ft?st(2960):ct(2960))},setMask:function(Ft){C!==Ft&&!A&&(i.stencilMask(Ft),C=Ft)},setFunc:function(Ft,Xt,re){(q!==Ft||et!==Xt||k!==re)&&(i.stencilFunc(Ft,Xt,re),q=Ft,et=Xt,k=re)},setOp:function(Ft,Xt,re){(at!==Ft||Rt!==Xt||Nt!==re)&&(i.stencilOp(Ft,Xt,re),at=Ft,Rt=Xt,Nt=re)},setLocked:function(Ft){A=Ft},setClear:function(Ft){xe!==Ft&&(i.clearStencil(Ft),xe=Ft)},reset:function(){A=!1,C=null,q=null,et=null,k=null,at=null,Rt=null,Nt=null,xe=null}}}const o=new r,l=new s,c=new a;let h={},u=null,d={},f=null,p=!1,x=null,y=null,g=null,m=null,E=null,w=null,S=null,_=!1,T=null,B=null,N=null,G=null,D=null;const V=i.getParameter(35661);let R=!1,L=0;const P=i.getParameter(7938);P.indexOf("WebGL")!==-1?(L=parseFloat(/^WebGL (\d)/.exec(P)[1]),R=L>=1):P.indexOf("OpenGL ES")!==-1&&(L=parseFloat(/^OpenGL ES (\d)/.exec(P)[1]),R=L>=2);let F=null,W={};const j=new Yt(0,0,i.canvas.width,i.canvas.height),Y=new Yt(0,0,i.canvas.width,i.canvas.height);function Q(A,C,q){const et=new Uint8Array(4),k=i.createTexture();i.bindTexture(A,k),i.texParameteri(A,10241,9728),i.texParameteri(A,10240,9728);for(let at=0;at<q;at++)i.texImage2D(C+at,0,6408,1,1,0,6408,5121,et);return k}const K={};K[3553]=Q(3553,3553,1),K[34067]=Q(34067,34069,6),o.setClear(0,0,0,1),l.setClear(1),c.setClear(0),st(2929),l.setFunc(Gl),St(!1),rt(Gu),st(2884),Ct(Ps);function st(A){h[A]!==!0&&(i.enable(A),h[A]=!0)}function ct(A){h[A]!==!1&&(i.disable(A),h[A]=!1)}function z(A){A!==u&&(i.bindFramebuffer(36160,A),u=A)}function Et(A,C){C===null&&u!==null&&(C=u),d[A]!==C&&(i.bindFramebuffer(A,C),d[A]=C)}function At(A){return f!==A?(i.useProgram(A),f=A,!0):!1}const yt={[hr]:32774,[Ag]:32778,[Tg]:32779};if(n)yt[qu]=32775,yt[Yu]=32776;else{const A=t.get("EXT_blend_minmax");A!==null&&(yt[qu]=A.MIN_EXT,yt[Yu]=A.MAX_EXT)}const ot={[Lg]:0,[Rg]:1,[Cg]:768,[ju]:770,[Ng]:776,[Ig]:774,[Dg]:772,[Pg]:769,[Zu]:771,[zg]:775,[Fg]:773};function Ct(A,C,q,et,k,at,Rt,Nt){if(A===Ps){p===!0&&(ct(3042),p=!1);return}if(p===!1&&(st(3042),p=!0),A!==Eg){if(A!==x||Nt!==_){if((y!==hr||E!==hr)&&(i.blendEquation(32774),y=hr,E=hr),Nt)switch(A){case Ds:i.blendFuncSeparate(1,771,1,771);break;case Wu:i.blendFunc(1,1);break;case $u:i.blendFuncSeparate(0,0,769,771);break;case Xu:i.blendFuncSeparate(0,768,0,770);break;default:console.error("THREE.WebGLState: Invalid blending: ",A);break}else switch(A){case Ds:i.blendFuncSeparate(770,771,1,771);break;case Wu:i.blendFunc(770,1);break;case $u:i.blendFunc(0,769);break;case Xu:i.blendFunc(0,768);break;default:console.error("THREE.WebGLState: Invalid blending: ",A);break}g=null,m=null,w=null,S=null,x=A,_=Nt}return}k=k||C,at=at||q,Rt=Rt||et,(C!==y||k!==E)&&(i.blendEquationSeparate(yt[C],yt[k]),y=C,E=k),(q!==g||et!==m||at!==w||Rt!==S)&&(i.blendFuncSeparate(ot[q],ot[et],ot[at],ot[Rt]),g=q,m=et,w=at,S=Rt),x=A,_=null}function Mt(A,C){A.side===Oa?ct(2884):st(2884);let q=A.side===ye;C&&(q=!q),St(q),A.blending===Ds&&A.transparent===!1?Ct(Ps):Ct(A.blending,A.blendEquation,A.blendSrc,A.blendDst,A.blendEquationAlpha,A.blendSrcAlpha,A.blendDstAlpha,A.premultipliedAlpha),l.setFunc(A.depthFunc),l.setTest(A.depthTest),l.setMask(A.depthWrite),o.setMask(A.colorWrite);const et=A.stencilWrite;c.setTest(et),et&&(c.setMask(A.stencilWriteMask),c.setFunc(A.stencilFunc,A.stencilRef,A.stencilFuncMask),c.setOp(A.stencilFail,A.stencilZFail,A.stencilZPass)),mt(A.polygonOffset,A.polygonOffsetFactor,A.polygonOffsetUnits),A.alphaToCoverage===!0?st(32926):ct(32926)}function St(A){T!==A&&(A?i.frontFace(2304):i.frontFace(2305),T=A)}function rt(A){A!==bg?(st(2884),A!==B&&(A===Gu?i.cullFace(1029):A===wg?i.cullFace(1028):i.cullFace(1032))):ct(2884),B=A}function dt(A){A!==N&&(R&&i.lineWidth(A),N=A)}function mt(A,C,q){A?(st(32823),(G!==C||D!==q)&&(i.polygonOffset(C,q),G=C,D=q)):ct(32823)}function bt(A){A?st(3089):ct(3089)}function ft(A){A===void 0&&(A=33984+V-1),F!==A&&(i.activeTexture(A),F=A)}function b(A,C){F===null&&ft();let q=W[F];q===void 0&&(q={type:void 0,texture:void 0},W[F]=q),(q.type!==A||q.texture!==C)&&(i.bindTexture(A,C||K[A]),q.type=A,q.texture=C)}function M(){const A=W[F];A!==void 0&&A.type!==void 0&&(i.bindTexture(A.type,null),A.type=void 0,A.texture=void 0)}function X(){try{i.compressedTexImage2D.apply(i,arguments)}catch(A){console.error("THREE.WebGLState:",A)}}function $(){try{i.texImage2D.apply(i,arguments)}catch(A){console.error("THREE.WebGLState:",A)}}function tt(){try{i.texImage3D.apply(i,arguments)}catch(A){console.error("THREE.WebGLState:",A)}}function nt(A){j.equals(A)===!1&&(i.scissor(A.x,A.y,A.z,A.w),j.copy(A))}function Lt(A){Y.equals(A)===!1&&(i.viewport(A.x,A.y,A.z,A.w),Y.copy(A))}function xt(){i.disable(3042),i.disable(2884),i.disable(2929),i.disable(32823),i.disable(3089),i.disable(2960),i.disable(32926),i.blendEquation(32774),i.blendFunc(1,0),i.blendFuncSeparate(1,0,1,0),i.colorMask(!0,!0,!0,!0),i.clearColor(0,0,0,0),i.depthMask(!0),i.depthFunc(513),i.clearDepth(1),i.stencilMask(4294967295),i.stencilFunc(519,0,4294967295),i.stencilOp(7680,7680,7680),i.clearStencil(0),i.cullFace(1029),i.frontFace(2305),i.polygonOffset(0,0),i.activeTexture(33984),i.bindFramebuffer(36160,null),n===!0&&(i.bindFramebuffer(36009,null),i.bindFramebuffer(36008,null)),i.useProgram(null),i.lineWidth(1),i.scissor(0,0,i.canvas.width,i.canvas.height),i.viewport(0,0,i.canvas.width,i.canvas.height),h={},F=null,W={},u=null,d={},f=null,p=!1,x=null,y=null,g=null,m=null,E=null,w=null,S=null,_=!1,T=null,B=null,N=null,G=null,D=null,j.set(0,0,i.canvas.width,i.canvas.height),Y.set(0,0,i.canvas.width,i.canvas.height),o.reset(),l.reset(),c.reset()}return{buffers:{color:o,depth:l,stencil:c},enable:st,disable:ct,bindFramebuffer:Et,bindXRFramebuffer:z,useProgram:At,setBlending:Ct,setMaterial:Mt,setFlipSided:St,setCullFace:rt,setLineWidth:dt,setPolygonOffset:mt,setScissorTest:bt,activeTexture:ft,bindTexture:b,unbindTexture:M,compressedTexImage2D:X,texImage2D:$,texImage3D:tt,scissor:nt,viewport:Lt,reset:xt}}function bM(i,t,e,n,r,s,a){const o=r.isWebGL2,l=r.maxTextures,c=r.maxCubemapSize,h=r.maxTextureSize,u=r.maxSamples,d=new WeakMap;let f,p=!1;try{p=typeof OffscreenCanvas!="undefined"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch(b){}function x(b,M){return p?new OffscreenCanvas(b,M):document.createElementNS("http://www.w3.org/1999/xhtml","canvas")}function y(b,M,X,$){let tt=1;if((b.width>$||b.height>$)&&(tt=$/Math.max(b.width,b.height)),tt<1||M===!0)if(typeof HTMLImageElement!="undefined"&&b instanceof HTMLImageElement||typeof HTMLCanvasElement!="undefined"&&b instanceof HTMLCanvasElement||typeof ImageBitmap!="undefined"&&b instanceof ImageBitmap){const nt=M?Ot.floorPowerOfTwo:Math.floor,Lt=nt(tt*b.width),xt=nt(tt*b.height);f===void 0&&(f=x(Lt,xt));const A=X?x(Lt,xt):f;return A.width=Lt,A.height=xt,A.getContext("2d").drawImage(b,0,0,Lt,xt),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+b.width+"x"+b.height+") to ("+Lt+"x"+xt+")."),A}else return"data"in b&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+b.width+"x"+b.height+")."),b;return b}function g(b){return Ot.isPowerOfTwo(b.width)&&Ot.isPowerOfTwo(b.height)}function m(b){return o?!1:b.wrapS!==Xe||b.wrapT!==Xe||b.minFilter!==Ge&&b.minFilter!==be}function E(b,M){return b.generateMipmaps&&M&&b.minFilter!==Ge&&b.minFilter!==be}function w(b,M,X,$){i.generateMipmap(b);const tt=n.get(M);tt.__maxMipLevel=Math.log2(Math.max(X,$))}function S(b,M,X){if(o===!1)return M;if(b!==null){if(i[b]!==void 0)return i[b];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+b+"'")}let $=M;return M===6403&&(X===5126&&($=33326),X===5131&&($=33325),X===5121&&($=33321)),M===6407&&(X===5126&&($=34837),X===5131&&($=34843),X===5121&&($=32849)),M===6408&&(X===5126&&($=34836),X===5131&&($=34842),X===5121&&($=32856)),($===33325||$===33326||$===34842||$===34836)&&t.get("EXT_color_buffer_float"),$}function _(b){return b===Ge||b===td||b===ed?9728:9729}function T(b){const M=b.target;M.removeEventListener("dispose",T),N(M),M.isVideoTexture&&d.delete(M),a.memory.textures--}function B(b){const M=b.target;M.removeEventListener("dispose",B),G(M),a.memory.textures--}function N(b){const M=n.get(b);M.__webglInit!==void 0&&(i.deleteTexture(M.__webglTexture),n.remove(b))}function G(b){const M=b.texture,X=n.get(b),$=n.get(M);if(!!b){if($.__webglTexture!==void 0&&i.deleteTexture($.__webglTexture),b.depthTexture&&b.depthTexture.dispose(),b.isWebGLCubeRenderTarget)for(let tt=0;tt<6;tt++)i.deleteFramebuffer(X.__webglFramebuffer[tt]),X.__webglDepthbuffer&&i.deleteRenderbuffer(X.__webglDepthbuffer[tt]);else i.deleteFramebuffer(X.__webglFramebuffer),X.__webglDepthbuffer&&i.deleteRenderbuffer(X.__webglDepthbuffer),X.__webglMultisampledFramebuffer&&i.deleteFramebuffer(X.__webglMultisampledFramebuffer),X.__webglColorRenderbuffer&&i.deleteRenderbuffer(X.__webglColorRenderbuffer),X.__webglDepthRenderbuffer&&i.deleteRenderbuffer(X.__webglDepthRenderbuffer);n.remove(M),n.remove(b)}}let D=0;function V(){D=0}function R(){const b=D;return b>=l&&console.warn("THREE.WebGLTextures: Trying to use "+b+" texture units while this GPU supports only "+l),D+=1,b}function L(b,M){const X=n.get(b);if(b.isVideoTexture&&rt(b),b.version>0&&X.__version!==b.version){const $=b.image;if($===void 0)console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");else if($.complete===!1)console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");else{st(X,b,M);return}}e.activeTexture(33984+M),e.bindTexture(3553,X.__webglTexture)}function P(b,M){const X=n.get(b);if(b.version>0&&X.__version!==b.version){st(X,b,M);return}e.activeTexture(33984+M),e.bindTexture(35866,X.__webglTexture)}function F(b,M){const X=n.get(b);if(b.version>0&&X.__version!==b.version){st(X,b,M);return}e.activeTexture(33984+M),e.bindTexture(32879,X.__webglTexture)}function W(b,M){const X=n.get(b);if(b.version>0&&X.__version!==b.version){ct(X,b,M);return}e.activeTexture(33984+M),e.bindTexture(34067,X.__webglTexture)}const j={[Xl]:10497,[Xe]:33071,[ql]:33648},Y={[Ge]:9728,[td]:9984,[ed]:9986,[be]:9729,[Jg]:9985,[Ha]:9987};function Q(b,M,X){if(X?(i.texParameteri(b,10242,j[M.wrapS]),i.texParameteri(b,10243,j[M.wrapT]),(b===32879||b===35866)&&i.texParameteri(b,32882,j[M.wrapR]),i.texParameteri(b,10240,Y[M.magFilter]),i.texParameteri(b,10241,Y[M.minFilter])):(i.texParameteri(b,10242,33071),i.texParameteri(b,10243,33071),(b===32879||b===35866)&&i.texParameteri(b,32882,33071),(M.wrapS!==Xe||M.wrapT!==Xe)&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),i.texParameteri(b,10240,_(M.magFilter)),i.texParameteri(b,10241,_(M.minFilter)),M.minFilter!==Ge&&M.minFilter!==be&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),t.has("EXT_texture_filter_anisotropic")===!0){const $=t.get("EXT_texture_filter_anisotropic");if(M.type===un&&t.has("OES_texture_float_linear")===!1||o===!1&&M.type===Va&&t.has("OES_texture_half_float_linear")===!1)return;(M.anisotropy>1||n.get(M).__currentAnisotropy)&&(i.texParameterf(b,$.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(M.anisotropy,r.getMaxAnisotropy())),n.get(M).__currentAnisotropy=M.anisotropy)}}function K(b,M){b.__webglInit===void 0&&(b.__webglInit=!0,M.addEventListener("dispose",T),b.__webglTexture=i.createTexture(),a.memory.textures++)}function st(b,M,X){let $=3553;M.isDataTexture2DArray&&($=35866),M.isDataTexture3D&&($=32879),K(b,M),e.activeTexture(33984+X),e.bindTexture($,b.__webglTexture),i.pixelStorei(37440,M.flipY),i.pixelStorei(37441,M.premultiplyAlpha),i.pixelStorei(3317,M.unpackAlignment),i.pixelStorei(37443,0);const tt=m(M)&&g(M.image)===!1,nt=y(M.image,tt,!1,h),Lt=g(nt)||o,xt=s.convert(M.format);let A=s.convert(M.type),C=S(M.internalFormat,xt,A);Q($,M,Lt);let q;const et=M.mipmaps;if(M.isDepthTexture)C=6402,o?M.type===un?C=36012:M.type===ka?C=33190:M.type===Is?C=35056:C=33189:M.type===un&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),M.format===ur&&C===6402&&M.type!==Ga&&M.type!==ka&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),M.type=Ga,A=s.convert(M.type)),M.format===zs&&C===6402&&(C=34041,M.type!==Is&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),M.type=Is,A=s.convert(M.type))),e.texImage2D(3553,0,C,nt.width,nt.height,0,xt,A,null);else if(M.isDataTexture)if(et.length>0&&Lt){for(let k=0,at=et.length;k<at;k++)q=et[k],e.texImage2D(3553,k,C,q.width,q.height,0,xt,A,q.data);M.generateMipmaps=!1,b.__maxMipLevel=et.length-1}else e.texImage2D(3553,0,C,nt.width,nt.height,0,xt,A,nt.data),b.__maxMipLevel=0;else if(M.isCompressedTexture){for(let k=0,at=et.length;k<at;k++)q=et[k],M.format!==hi&&M.format!==Wn?xt!==null?e.compressedTexImage2D(3553,k,C,q.width,q.height,0,q.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):e.texImage2D(3553,k,C,q.width,q.height,0,xt,A,q.data);b.__maxMipLevel=et.length-1}else if(M.isDataTexture2DArray)e.texImage3D(35866,0,C,nt.width,nt.height,nt.depth,0,xt,A,nt.data),b.__maxMipLevel=0;else if(M.isDataTexture3D)e.texImage3D(32879,0,C,nt.width,nt.height,nt.depth,0,xt,A,nt.data),b.__maxMipLevel=0;else if(et.length>0&&Lt){for(let k=0,at=et.length;k<at;k++)q=et[k],e.texImage2D(3553,k,C,xt,A,q);M.generateMipmaps=!1,b.__maxMipLevel=et.length-1}else e.texImage2D(3553,0,C,xt,A,nt),b.__maxMipLevel=0;E(M,Lt)&&w($,M,nt.width,nt.height),b.__version=M.version,M.onUpdate&&M.onUpdate(M)}function ct(b,M,X){if(M.image.length!==6)return;K(b,M),e.activeTexture(33984+X),e.bindTexture(34067,b.__webglTexture),i.pixelStorei(37440,M.flipY),i.pixelStorei(37441,M.premultiplyAlpha),i.pixelStorei(3317,M.unpackAlignment),i.pixelStorei(37443,0);const $=M&&(M.isCompressedTexture||M.image[0].isCompressedTexture),tt=M.image[0]&&M.image[0].isDataTexture,nt=[];for(let k=0;k<6;k++)!$&&!tt?nt[k]=y(M.image[k],!1,!0,c):nt[k]=tt?M.image[k].image:M.image[k];const Lt=nt[0],xt=g(Lt)||o,A=s.convert(M.format),C=s.convert(M.type),q=S(M.internalFormat,A,C);Q(34067,M,xt);let et;if($){for(let k=0;k<6;k++){et=nt[k].mipmaps;for(let at=0;at<et.length;at++){const Rt=et[at];M.format!==hi&&M.format!==Wn?A!==null?e.compressedTexImage2D(34069+k,at,q,Rt.width,Rt.height,0,Rt.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):e.texImage2D(34069+k,at,q,Rt.width,Rt.height,0,A,C,Rt.data)}}b.__maxMipLevel=et.length-1}else{et=M.mipmaps;for(let k=0;k<6;k++)if(tt){e.texImage2D(34069+k,0,q,nt[k].width,nt[k].height,0,A,C,nt[k].data);for(let at=0;at<et.length;at++){const Nt=et[at].image[k].image;e.texImage2D(34069+k,at+1,q,Nt.width,Nt.height,0,A,C,Nt.data)}}else{e.texImage2D(34069+k,0,q,A,C,nt[k]);for(let at=0;at<et.length;at++){const Rt=et[at];e.texImage2D(34069+k,at+1,q,A,C,Rt.image[k])}}b.__maxMipLevel=et.length}E(M,xt)&&w(34067,M,Lt.width,Lt.height),b.__version=M.version,M.onUpdate&&M.onUpdate(M)}function z(b,M,X,$){const tt=M.texture,nt=s.convert(tt.format),Lt=s.convert(tt.type),xt=S(tt.internalFormat,nt,Lt);$===32879||$===35866?e.texImage3D($,0,xt,M.width,M.height,M.depth,0,nt,Lt,null):e.texImage2D($,0,xt,M.width,M.height,0,nt,Lt,null),e.bindFramebuffer(36160,b),i.framebufferTexture2D(36160,X,$,n.get(tt).__webglTexture,0),e.bindFramebuffer(36160,null)}function Et(b,M,X){if(i.bindRenderbuffer(36161,b),M.depthBuffer&&!M.stencilBuffer){let $=33189;if(X){const tt=M.depthTexture;tt&&tt.isDepthTexture&&(tt.type===un?$=36012:tt.type===ka&&($=33190));const nt=St(M);i.renderbufferStorageMultisample(36161,nt,$,M.width,M.height)}else i.renderbufferStorage(36161,$,M.width,M.height);i.framebufferRenderbuffer(36160,36096,36161,b)}else if(M.depthBuffer&&M.stencilBuffer){if(X){const $=St(M);i.renderbufferStorageMultisample(36161,$,35056,M.width,M.height)}else i.renderbufferStorage(36161,34041,M.width,M.height);i.framebufferRenderbuffer(36160,33306,36161,b)}else{const $=M.texture,tt=s.convert($.format),nt=s.convert($.type),Lt=S($.internalFormat,tt,nt);if(X){const xt=St(M);i.renderbufferStorageMultisample(36161,xt,Lt,M.width,M.height)}else i.renderbufferStorage(36161,Lt,M.width,M.height)}i.bindRenderbuffer(36161,null)}function At(b,M){if(M&&M.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(e.bindFramebuffer(36160,b),!(M.depthTexture&&M.depthTexture.isDepthTexture))throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");(!n.get(M.depthTexture).__webglTexture||M.depthTexture.image.width!==M.width||M.depthTexture.image.height!==M.height)&&(M.depthTexture.image.width=M.width,M.depthTexture.image.height=M.height,M.depthTexture.needsUpdate=!0),L(M.depthTexture,0);const $=n.get(M.depthTexture).__webglTexture;if(M.depthTexture.format===ur)i.framebufferTexture2D(36160,36096,3553,$,0);else if(M.depthTexture.format===zs)i.framebufferTexture2D(36160,33306,3553,$,0);else throw new Error("Unknown depthTexture format")}function yt(b){const M=n.get(b),X=b.isWebGLCubeRenderTarget===!0;if(b.depthTexture){if(X)throw new Error("target.depthTexture not supported in Cube render targets");At(M.__webglFramebuffer,b)}else if(X){M.__webglDepthbuffer=[];for(let $=0;$<6;$++)e.bindFramebuffer(36160,M.__webglFramebuffer[$]),M.__webglDepthbuffer[$]=i.createRenderbuffer(),Et(M.__webglDepthbuffer[$],b,!1)}else e.bindFramebuffer(36160,M.__webglFramebuffer),M.__webglDepthbuffer=i.createRenderbuffer(),Et(M.__webglDepthbuffer,b,!1);e.bindFramebuffer(36160,null)}function ot(b){const M=b.texture,X=n.get(b),$=n.get(M);b.addEventListener("dispose",B),$.__webglTexture=i.createTexture(),$.__version=M.version,a.memory.textures++;const tt=b.isWebGLCubeRenderTarget===!0,nt=b.isWebGLMultisampleRenderTarget===!0,Lt=M.isDataTexture3D||M.isDataTexture2DArray,xt=g(b)||o;if(o&&M.format===Wn&&(M.type===un||M.type===Va)&&(M.format=hi,console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")),tt){X.__webglFramebuffer=[];for(let A=0;A<6;A++)X.__webglFramebuffer[A]=i.createFramebuffer()}else if(X.__webglFramebuffer=i.createFramebuffer(),nt)if(o){X.__webglMultisampledFramebuffer=i.createFramebuffer(),X.__webglColorRenderbuffer=i.createRenderbuffer(),i.bindRenderbuffer(36161,X.__webglColorRenderbuffer);const A=s.convert(M.format),C=s.convert(M.type),q=S(M.internalFormat,A,C),et=St(b);i.renderbufferStorageMultisample(36161,et,q,b.width,b.height),e.bindFramebuffer(36160,X.__webglMultisampledFramebuffer),i.framebufferRenderbuffer(36160,36064,36161,X.__webglColorRenderbuffer),i.bindRenderbuffer(36161,null),b.depthBuffer&&(X.__webglDepthRenderbuffer=i.createRenderbuffer(),Et(X.__webglDepthRenderbuffer,b,!0)),e.bindFramebuffer(36160,null)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");if(tt){e.bindTexture(34067,$.__webglTexture),Q(34067,M,xt);for(let A=0;A<6;A++)z(X.__webglFramebuffer[A],b,36064,34069+A);E(M,xt)&&w(34067,M,b.width,b.height),e.bindTexture(34067,null)}else{let A=3553;Lt&&(o?A=M.isDataTexture3D?32879:35866:console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.")),e.bindTexture(A,$.__webglTexture),Q(A,M,xt),z(X.__webglFramebuffer,b,36064,A),E(M,xt)&&w(3553,M,b.width,b.height),e.bindTexture(3553,null)}b.depthBuffer&&yt(b)}function Ct(b){const M=b.texture,X=g(b)||o;if(E(M,X)){const $=b.isWebGLCubeRenderTarget?34067:3553,tt=n.get(M).__webglTexture;e.bindTexture($,tt),w($,M,b.width,b.height),e.bindTexture($,null)}}function Mt(b){if(b.isWebGLMultisampleRenderTarget)if(o){const M=n.get(b);e.bindFramebuffer(36008,M.__webglMultisampledFramebuffer),e.bindFramebuffer(36009,M.__webglFramebuffer);const X=b.width,$=b.height;let tt=16384;b.depthBuffer&&(tt|=256),b.stencilBuffer&&(tt|=1024),i.blitFramebuffer(0,0,X,$,0,0,X,$,tt,9728),e.bindFramebuffer(36160,M.__webglMultisampledFramebuffer)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")}function St(b){return o&&b.isWebGLMultisampleRenderTarget?Math.min(u,b.samples):0}function rt(b){const M=a.render.frame;d.get(b)!==M&&(d.set(b,M),b.update())}let dt=!1,mt=!1;function bt(b,M){b&&b.isWebGLRenderTarget&&(dt===!1&&(console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."),dt=!0),b=b.texture),L(b,M)}function ft(b,M){b&&b.isWebGLCubeRenderTarget&&(mt===!1&&(console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."),mt=!0),b=b.texture),W(b,M)}this.allocateTextureUnit=R,this.resetTextureUnits=V,this.setTexture2D=L,this.setTexture2DArray=P,this.setTexture3D=F,this.setTextureCube=W,this.setupRenderTarget=ot,this.updateRenderTargetMipmap=Ct,this.updateMultisampleRenderTarget=Mt,this.safeSetTexture2D=bt,this.safeSetTextureCube=ft}function wM(i,t,e){const n=e.isWebGL2;function r(s){let a;if(s===Yl)return 5121;if(s===ex)return 32819;if(s===ix)return 32820;if(s===nx)return 33635;if(s===Qg)return 5120;if(s===Kg)return 5122;if(s===Ga)return 5123;if(s===tx)return 5124;if(s===ka)return 5125;if(s===un)return 5126;if(s===Va)return n?5131:(a=t.get("OES_texture_half_float"),a!==null?a.HALF_FLOAT_OES:null);if(s===rx)return 6406;if(s===Wn)return 6407;if(s===hi)return 6408;if(s===sx)return 6409;if(s===ax)return 6410;if(s===ur)return 6402;if(s===zs)return 34041;if(s===ox)return 6403;if(s===lx)return 36244;if(s===cx)return 33319;if(s===hx)return 33320;if(s===ux)return 36248;if(s===dx)return 36249;if(s===id||s===nd||s===rd||s===sd)if(a=t.get("WEBGL_compressed_texture_s3tc"),a!==null){if(s===id)return a.COMPRESSED_RGB_S3TC_DXT1_EXT;if(s===nd)return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(s===rd)return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(s===sd)return a.COMPRESSED_RGBA_S3TC_DXT5_EXT}else return null;if(s===ad||s===od||s===ld||s===cd)if(a=t.get("WEBGL_compressed_texture_pvrtc"),a!==null){if(s===ad)return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(s===od)return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(s===ld)return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(s===cd)return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}else return null;if(s===fx)return a=t.get("WEBGL_compressed_texture_etc1"),a!==null?a.COMPRESSED_RGB_ETC1_WEBGL:null;if((s===hd||s===ud)&&(a=t.get("WEBGL_compressed_texture_etc"),a!==null)){if(s===hd)return a.COMPRESSED_RGB8_ETC2;if(s===ud)return a.COMPRESSED_RGBA8_ETC2_EAC}if(s===px||s===mx||s===gx||s===xx||s===yx||s===_x||s===vx||s===Mx||s===bx||s===wx||s===Sx||s===Ex||s===Ax||s===Tx||s===Rx||s===Cx||s===Px||s===Dx||s===Fx||s===Ix||s===zx||s===Nx||s===Bx||s===Ox||s===Ux||s===Hx||s===Gx||s===kx)return a=t.get("WEBGL_compressed_texture_astc"),a!==null?s:null;if(s===Lx)return a=t.get("EXT_texture_compression_bptc"),a!==null?s:null;if(s===Is)return n?34042:(a=t.get("WEBGL_depth_texture"),a!==null?a.UNSIGNED_INT_24_8_WEBGL:null)}return{convert:r}}class rf extends We{constructor(t=[]){super();this.cameras=t}}rf.prototype.isArrayCamera=!0;class qs extends Bt{constructor(){super();this.type="Group"}}qs.prototype.isGroup=!0;function Ys(){this._targetRay=null,this._grip=null,this._hand=null}Object.assign(Ys.prototype,{constructor:Ys,getHandSpace:function(){return this._hand===null&&(this._hand=new qs,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand},getTargetRaySpace:function(){return this._targetRay===null&&(this._targetRay=new qs,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1),this._targetRay},getGripSpace:function(){return this._grip===null&&(this._grip=new qs,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1),this._grip},dispatchEvent:function(i){return this._targetRay!==null&&this._targetRay.dispatchEvent(i),this._grip!==null&&this._grip.dispatchEvent(i),this._hand!==null&&this._hand.dispatchEvent(i),this},disconnect:function(i){return this.dispatchEvent({type:"disconnected",data:i}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this},update:function(i,t,e){let n=null,r=null,s=null;const a=this._targetRay,o=this._grip,l=this._hand;if(i&&t.session.visibilityState!=="visible-blurred")if(a!==null&&(n=t.getPose(i.targetRaySpace,e),n!==null&&(a.matrix.fromArray(n.transform.matrix),a.matrix.decompose(a.position,a.rotation,a.scale))),l&&i.hand){s=!0;for(const p of i.hand.values()){const x=t.getJointPose(p,e);if(l.joints[p.jointName]===void 0){const g=new qs;g.matrixAutoUpdate=!1,g.visible=!1,l.joints[p.jointName]=g,l.add(g)}const y=l.joints[p.jointName];x!==null&&(y.matrix.fromArray(x.transform.matrix),y.matrix.decompose(y.position,y.rotation,y.scale),y.jointRadius=x.radius),y.visible=x!==null}const c=l.joints["index-finger-tip"],h=l.joints["thumb-tip"],u=c.position.distanceTo(h.position),d=.02,f=.005;l.inputState.pinching&&u>d+f?(l.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:i.handedness,target:this})):!l.inputState.pinching&&u<=d-f&&(l.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:i.handedness,target:this}))}else o!==null&&i.gripSpace&&(r=t.getPose(i.gripSpace,e),r!==null&&(o.matrix.fromArray(r.transform.matrix),o.matrix.decompose(o.position,o.rotation,o.scale)));return a!==null&&(a.visible=n!==null),o!==null&&(o.visible=r!==null),l!==null&&(l.visible=s!==null),this}});function sf(i,t){const e=this,n=i.state;let r=null,s=1,a=null,o="local-floor",l=null;const c=[],h=new Map,u=new We;u.layers.enable(1),u.viewport=new Yt;const d=new We;d.layers.enable(2),d.viewport=new Yt;const f=[u,d],p=new rf;p.layers.enable(1),p.layers.enable(2);let x=null,y=null;this.enabled=!1,this.isPresenting=!1,this.getController=function(D){let V=c[D];return V===void 0&&(V=new Ys,c[D]=V),V.getTargetRaySpace()},this.getControllerGrip=function(D){let V=c[D];return V===void 0&&(V=new Ys,c[D]=V),V.getGripSpace()},this.getHand=function(D){let V=c[D];return V===void 0&&(V=new Ys,c[D]=V),V.getHandSpace()};function g(D){const V=h.get(D.inputSource);V&&V.dispatchEvent({type:D.type,data:D.inputSource})}function m(){h.forEach(function(D,V){D.disconnect(V)}),h.clear(),x=null,y=null,n.bindXRFramebuffer(null),i.setRenderTarget(i.getRenderTarget()),G.stop(),e.isPresenting=!1,e.dispatchEvent({type:"sessionend"})}this.setFramebufferScaleFactor=function(D){s=D,e.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(D){o=D,e.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return a},this.getSession=function(){return r},this.setSession=async function(D){if(r=D,r!==null){r.addEventListener("select",g),r.addEventListener("selectstart",g),r.addEventListener("selectend",g),r.addEventListener("squeeze",g),r.addEventListener("squeezestart",g),r.addEventListener("squeezeend",g),r.addEventListener("end",m),r.addEventListener("inputsourceschange",E);const V=t.getContextAttributes();V.xrCompatible!==!0&&await t.makeXRCompatible();const R={antialias:V.antialias,alpha:V.alpha,depth:V.depth,stencil:V.stencil,framebufferScaleFactor:s},L=new XRWebGLLayer(r,t,R);r.updateRenderState({baseLayer:L}),a=await r.requestReferenceSpace(o),G.setContext(r),G.start(),e.isPresenting=!0,e.dispatchEvent({type:"sessionstart"})}};function E(D){const V=r.inputSources;for(let R=0;R<c.length;R++)h.set(V[R],c[R]);for(let R=0;R<D.removed.length;R++){const L=D.removed[R],P=h.get(L);P&&(P.dispatchEvent({type:"disconnected",data:L}),h.delete(L))}for(let R=0;R<D.added.length;R++){const L=D.added[R],P=h.get(L);P&&P.dispatchEvent({type:"connected",data:L})}}const w=new U,S=new U;function _(D,V,R){w.setFromMatrixPosition(V.matrixWorld),S.setFromMatrixPosition(R.matrixWorld);const L=w.distanceTo(S),P=V.projectionMatrix.elements,F=R.projectionMatrix.elements,W=P[14]/(P[10]-1),j=P[14]/(P[10]+1),Y=(P[9]+1)/P[5],Q=(P[9]-1)/P[5],K=(P[8]-1)/P[0],st=(F[8]+1)/F[0],ct=W*K,z=W*st,Et=L/(-K+st),At=Et*-K;V.matrixWorld.decompose(D.position,D.quaternion,D.scale),D.translateX(At),D.translateZ(Et),D.matrixWorld.compose(D.position,D.quaternion,D.scale),D.matrixWorldInverse.copy(D.matrixWorld).invert();const yt=W+Et,ot=j+Et,Ct=ct-At,Mt=z+(L-At),St=Y*j/ot*yt,rt=Q*j/ot*yt;D.projectionMatrix.makePerspective(Ct,Mt,St,rt,yt,ot)}function T(D,V){V===null?D.matrixWorld.copy(D.matrix):D.matrixWorld.multiplyMatrices(V.matrixWorld,D.matrix),D.matrixWorldInverse.copy(D.matrixWorld).invert()}this.getCamera=function(D){p.near=d.near=u.near=D.near,p.far=d.far=u.far=D.far,(x!==p.near||y!==p.far)&&(r.updateRenderState({depthNear:p.near,depthFar:p.far}),x=p.near,y=p.far);const V=D.parent,R=p.cameras;T(p,V);for(let P=0;P<R.length;P++)T(R[P],V);D.matrixWorld.copy(p.matrixWorld),D.matrix.copy(p.matrix),D.matrix.decompose(D.position,D.quaternion,D.scale);const L=D.children;for(let P=0,F=L.length;P<F;P++)L[P].updateMatrixWorld(!0);return R.length===2?_(p,u,d):p.projectionMatrix.copy(u.projectionMatrix),p};let B=null;function N(D,V){if(l=V.getViewerPose(a),l!==null){const L=l.views,P=r.renderState.baseLayer;n.bindXRFramebuffer(P.framebuffer);let F=!1;L.length!==p.cameras.length&&(p.cameras.length=0,F=!0);for(let W=0;W<L.length;W++){const j=L[W],Y=P.getViewport(j),Q=f[W];Q.matrix.fromArray(j.transform.matrix),Q.projectionMatrix.fromArray(j.projectionMatrix),Q.viewport.set(Y.x,Y.y,Y.width,Y.height),W===0&&p.matrix.copy(Q.matrix),F===!0&&p.cameras.push(Q)}}const R=r.inputSources;for(let L=0;L<c.length;L++){const P=c[L],F=R[L];P.update(F,V,a)}B&&B(D,V)}const G=new Cd;G.setAnimationLoop(N),this.setAnimationLoop=function(D){B=D},this.dispose=function(){}}Object.assign(sf.prototype,Ti.prototype);function SM(i){function t(g,m){g.fogColor.value.copy(m.color),m.isFog?(g.fogNear.value=m.near,g.fogFar.value=m.far):m.isFogExp2&&(g.fogDensity.value=m.density)}function e(g,m,E,w){m.isMeshBasicMaterial?n(g,m):m.isMeshLambertMaterial?(n(g,m),l(g,m)):m.isMeshToonMaterial?(n(g,m),h(g,m)):m.isMeshPhongMaterial?(n(g,m),c(g,m)):m.isMeshStandardMaterial?(n(g,m),m.isMeshPhysicalMaterial?d(g,m):u(g,m)):m.isMeshMatcapMaterial?(n(g,m),f(g,m)):m.isMeshDepthMaterial?(n(g,m),p(g,m)):m.isMeshDistanceMaterial?(n(g,m),x(g,m)):m.isMeshNormalMaterial?(n(g,m),y(g,m)):m.isLineBasicMaterial?(r(g,m),m.isLineDashedMaterial&&s(g,m)):m.isPointsMaterial?a(g,m,E,w):m.isSpriteMaterial?o(g,m):m.isShadowMaterial?(g.color.value.copy(m.color),g.opacity.value=m.opacity):m.isShaderMaterial&&(m.uniformsNeedUpdate=!1)}function n(g,m){g.opacity.value=m.opacity,m.color&&g.diffuse.value.copy(m.color),m.emissive&&g.emissive.value.copy(m.emissive).multiplyScalar(m.emissiveIntensity),m.map&&(g.map.value=m.map),m.alphaMap&&(g.alphaMap.value=m.alphaMap),m.specularMap&&(g.specularMap.value=m.specularMap);const E=i.get(m).envMap;if(E){g.envMap.value=E,g.flipEnvMap.value=E.isCubeTexture&&E._needsFlipEnvMap?-1:1,g.reflectivity.value=m.reflectivity,g.refractionRatio.value=m.refractionRatio;const _=i.get(E).__maxMipLevel;_!==void 0&&(g.maxMipLevel.value=_)}m.lightMap&&(g.lightMap.value=m.lightMap,g.lightMapIntensity.value=m.lightMapIntensity),m.aoMap&&(g.aoMap.value=m.aoMap,g.aoMapIntensity.value=m.aoMapIntensity);let w;m.map?w=m.map:m.specularMap?w=m.specularMap:m.displacementMap?w=m.displacementMap:m.normalMap?w=m.normalMap:m.bumpMap?w=m.bumpMap:m.roughnessMap?w=m.roughnessMap:m.metalnessMap?w=m.metalnessMap:m.alphaMap?w=m.alphaMap:m.emissiveMap?w=m.emissiveMap:m.clearcoatMap?w=m.clearcoatMap:m.clearcoatNormalMap?w=m.clearcoatNormalMap:m.clearcoatRoughnessMap&&(w=m.clearcoatRoughnessMap),w!==void 0&&(w.isWebGLRenderTarget&&(w=w.texture),w.matrixAutoUpdate===!0&&w.updateMatrix(),g.uvTransform.value.copy(w.matrix));let S;m.aoMap?S=m.aoMap:m.lightMap&&(S=m.lightMap),S!==void 0&&(S.isWebGLRenderTarget&&(S=S.texture),S.matrixAutoUpdate===!0&&S.updateMatrix(),g.uv2Transform.value.copy(S.matrix))}function r(g,m){g.diffuse.value.copy(m.color),g.opacity.value=m.opacity}function s(g,m){g.dashSize.value=m.dashSize,g.totalSize.value=m.dashSize+m.gapSize,g.scale.value=m.scale}function a(g,m,E,w){g.diffuse.value.copy(m.color),g.opacity.value=m.opacity,g.size.value=m.size*E,g.scale.value=w*.5,m.map&&(g.map.value=m.map),m.alphaMap&&(g.alphaMap.value=m.alphaMap);let S;m.map?S=m.map:m.alphaMap&&(S=m.alphaMap),S!==void 0&&(S.matrixAutoUpdate===!0&&S.updateMatrix(),g.uvTransform.value.copy(S.matrix))}function o(g,m){g.diffuse.value.copy(m.color),g.opacity.value=m.opacity,g.rotation.value=m.rotation,m.map&&(g.map.value=m.map),m.alphaMap&&(g.alphaMap.value=m.alphaMap);let E;m.map?E=m.map:m.alphaMap&&(E=m.alphaMap),E!==void 0&&(E.matrixAutoUpdate===!0&&E.updateMatrix(),g.uvTransform.value.copy(E.matrix))}function l(g,m){m.emissiveMap&&(g.emissiveMap.value=m.emissiveMap)}function c(g,m){g.specular.value.copy(m.specular),g.shininess.value=Math.max(m.shininess,1e-4),m.emissiveMap&&(g.emissiveMap.value=m.emissiveMap),m.bumpMap&&(g.bumpMap.value=m.bumpMap,g.bumpScale.value=m.bumpScale,m.side===ye&&(g.bumpScale.value*=-1)),m.normalMap&&(g.normalMap.value=m.normalMap,g.normalScale.value.copy(m.normalScale),m.side===ye&&g.normalScale.value.negate()),m.displacementMap&&(g.displacementMap.value=m.displacementMap,g.displacementScale.value=m.displacementScale,g.displacementBias.value=m.displacementBias)}function h(g,m){m.gradientMap&&(g.gradientMap.value=m.gradientMap),m.emissiveMap&&(g.emissiveMap.value=m.emissiveMap),m.bumpMap&&(g.bumpMap.value=m.bumpMap,g.bumpScale.value=m.bumpScale,m.side===ye&&(g.bumpScale.value*=-1)),m.normalMap&&(g.normalMap.value=m.normalMap,g.normalScale.value.copy(m.normalScale),m.side===ye&&g.normalScale.value.negate()),m.displacementMap&&(g.displacementMap.value=m.displacementMap,g.displacementScale.value=m.displacementScale,g.displacementBias.value=m.displacementBias)}function u(g,m){g.roughness.value=m.roughness,g.metalness.value=m.metalness,m.roughnessMap&&(g.roughnessMap.value=m.roughnessMap),m.metalnessMap&&(g.metalnessMap.value=m.metalnessMap),m.emissiveMap&&(g.emissiveMap.value=m.emissiveMap),m.bumpMap&&(g.bumpMap.value=m.bumpMap,g.bumpScale.value=m.bumpScale,m.side===ye&&(g.bumpScale.value*=-1)),m.normalMap&&(g.normalMap.value=m.normalMap,g.normalScale.value.copy(m.normalScale),m.side===ye&&g.normalScale.value.negate()),m.displacementMap&&(g.displacementMap.value=m.displacementMap,g.displacementScale.value=m.displacementScale,g.displacementBias.value=m.displacementBias),i.get(m).envMap&&(g.envMapIntensity.value=m.envMapIntensity)}function d(g,m){u(g,m),g.reflectivity.value=m.reflectivity,g.clearcoat.value=m.clearcoat,g.clearcoatRoughness.value=m.clearcoatRoughness,m.sheen&&g.sheen.value.copy(m.sheen),m.clearcoatMap&&(g.clearcoatMap.value=m.clearcoatMap),m.clearcoatRoughnessMap&&(g.clearcoatRoughnessMap.value=m.clearcoatRoughnessMap),m.clearcoatNormalMap&&(g.clearcoatNormalScale.value.copy(m.clearcoatNormalScale),g.clearcoatNormalMap.value=m.clearcoatNormalMap,m.side===ye&&g.clearcoatNormalScale.value.negate()),g.transmission.value=m.transmission,m.transmissionMap&&(g.transmissionMap.value=m.transmissionMap)}function f(g,m){m.matcap&&(g.matcap.value=m.matcap),m.bumpMap&&(g.bumpMap.value=m.bumpMap,g.bumpScale.value=m.bumpScale,m.side===ye&&(g.bumpScale.value*=-1)),m.normalMap&&(g.normalMap.value=m.normalMap,g.normalScale.value.copy(m.normalScale),m.side===ye&&g.normalScale.value.negate()),m.displacementMap&&(g.displacementMap.value=m.displacementMap,g.displacementScale.value=m.displacementScale,g.displacementBias.value=m.displacementBias)}function p(g,m){m.displacementMap&&(g.displacementMap.value=m.displacementMap,g.displacementScale.value=m.displacementScale,g.displacementBias.value=m.displacementBias)}function x(g,m){m.displacementMap&&(g.displacementMap.value=m.displacementMap,g.displacementScale.value=m.displacementScale,g.displacementBias.value=m.displacementBias),g.referencePosition.value.copy(m.referencePosition),g.nearDistance.value=m.nearDistance,g.farDistance.value=m.farDistance}function y(g,m){m.bumpMap&&(g.bumpMap.value=m.bumpMap,g.bumpScale.value=m.bumpScale,m.side===ye&&(g.bumpScale.value*=-1)),m.normalMap&&(g.normalMap.value=m.normalMap,g.normalScale.value.copy(m.normalScale),m.side===ye&&g.normalScale.value.negate()),m.displacementMap&&(g.displacementMap.value=m.displacementMap,g.displacementScale.value=m.displacementScale,g.displacementBias.value=m.displacementBias)}return{refreshFogUniforms:t,refreshMaterialUniforms:e}}function EM(){const i=document.createElementNS("http://www.w3.org/1999/xhtml","canvas");return i.style.display="block",i}function jt(i){i=i||{};const t=i.canvas!==void 0?i.canvas:EM(),e=i.context!==void 0?i.context:null,n=i.alpha!==void 0?i.alpha:!1,r=i.depth!==void 0?i.depth:!0,s=i.stencil!==void 0?i.stencil:!0,a=i.antialias!==void 0?i.antialias:!1,o=i.premultipliedAlpha!==void 0?i.premultipliedAlpha:!0,l=i.preserveDrawingBuffer!==void 0?i.preserveDrawingBuffer:!1,c=i.powerPreference!==void 0?i.powerPreference:"default",h=i.failIfMajorPerformanceCaveat!==void 0?i.failIfMajorPerformanceCaveat:!1;let u=null,d=null;const f=[],p=[];this.domElement=t,this.debug={checkShaderErrors:!0},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.gammaFactor=2,this.outputEncoding=Ns,this.physicallyCorrectLights=!1,this.toneMapping=Fs,this.toneMappingExposure=1;const x=this;let y=!1,g=0,m=0,E=null,w=-1,S=null;const _=new Yt,T=new Yt;let B=null,N=t.width,G=t.height,D=1,V=null,R=null;const L=new Yt(0,0,N,G),P=new Yt(0,0,N,G);let F=!1;const W=new po;let j=!1,Y=!1;const Q=new It,K=new U,st={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function ct(){return E===null?D:1}let z=e;function Et(v,O){for(let I=0;I<v.length;I++){const H=v[I],J=t.getContext(H,O);if(J!==null)return J}return null}try{const v={alpha:n,depth:r,stencil:s,antialias:a,premultipliedAlpha:o,preserveDrawingBuffer:l,powerPreference:c,failIfMajorPerformanceCaveat:h};if(t.addEventListener("webglcontextlost",at,!1),t.addEventListener("webglcontextrestored",Rt,!1),z===null){const O=["webgl2","webgl","experimental-webgl"];if(x.isWebGL1Renderer===!0&&O.shift(),z=Et(O,v),z===null)throw Et(O)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}z.getShaderPrecisionFormat===void 0&&(z.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(v){throw console.error("THREE.WebGLRenderer: "+v.message),v}let At,yt,ot,Ct,Mt,St,rt,dt,mt,bt,ft,b,M,X,$,tt,nt,Lt,xt,A,C,q;function et(){At=new j_(z),yt=new X_(z,At,i),At.init(yt),C=new wM(z,At,yt),ot=new MM(z,At,yt),Ct=new Q_(z),Mt=new cM,St=new bM(z,At,ot,Mt,yt,C,Ct),rt=new Y_(x),dt=new v0(z,yt),q=new W_(z,At,dt,yt),mt=new Z_(z,dt,Ct,q),bt=new iv(z,mt,dt,Ct),Lt=new ev(z),$=new q_(Mt),ft=new lM(x,rt,At,yt,q,$),b=new SM(Mt),M=new dM(Mt),X=new yM(At,yt),nt=new V_(x,rt,ot,bt,o),tt=new nf(x,bt,yt),xt=new $_(z,At,Ct,yt),A=new J_(z,At,Ct,yt),Ct.programs=ft.programs,x.capabilities=yt,x.extensions=At,x.properties=Mt,x.renderLists=M,x.shadowMap=tt,x.state=ot,x.info=Ct}et();const k=new sf(x,z);this.xr=k,this.getContext=function(){return z},this.getContextAttributes=function(){return z.getContextAttributes()},this.forceContextLoss=function(){const v=At.get("WEBGL_lose_context");v&&v.loseContext()},this.forceContextRestore=function(){const v=At.get("WEBGL_lose_context");v&&v.restoreContext()},this.getPixelRatio=function(){return D},this.setPixelRatio=function(v){v!==void 0&&(D=v,this.setSize(N,G,!1))},this.getSize=function(v){return v===void 0&&(console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"),v=new lt),v.set(N,G)},this.setSize=function(v,O,I){if(k.isPresenting){console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");return}N=v,G=O,t.width=Math.floor(v*D),t.height=Math.floor(O*D),I!==!1&&(t.style.width=v+"px",t.style.height=O+"px"),this.setViewport(0,0,v,O)},this.getDrawingBufferSize=function(v){return v===void 0&&(console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"),v=new lt),v.set(N*D,G*D).floor()},this.setDrawingBufferSize=function(v,O,I){N=v,G=O,D=I,t.width=Math.floor(v*I),t.height=Math.floor(O*I),this.setViewport(0,0,v,O)},this.getCurrentViewport=function(v){return v===void 0&&(console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"),v=new Yt),v.copy(_)},this.getViewport=function(v){return v.copy(L)},this.setViewport=function(v,O,I,H){v.isVector4?L.set(v.x,v.y,v.z,v.w):L.set(v,O,I,H),ot.viewport(_.copy(L).multiplyScalar(D).floor())},this.getScissor=function(v){return v.copy(P)},this.setScissor=function(v,O,I,H){v.isVector4?P.set(v.x,v.y,v.z,v.w):P.set(v,O,I,H),ot.scissor(T.copy(P).multiplyScalar(D).floor())},this.getScissorTest=function(){return F},this.setScissorTest=function(v){ot.setScissorTest(F=v)},this.setOpaqueSort=function(v){V=v},this.setTransparentSort=function(v){R=v},this.getClearColor=function(v){return v===void 0&&(console.warn("WebGLRenderer: .getClearColor() now requires a Color as an argument"),v=new zt),v.copy(nt.getClearColor())},this.setClearColor=function(){nt.setClearColor.apply(nt,arguments)},this.getClearAlpha=function(){return nt.getClearAlpha()},this.setClearAlpha=function(){nt.setClearAlpha.apply(nt,arguments)},this.clear=function(v,O,I){let H=0;(v===void 0||v)&&(H|=16384),(O===void 0||O)&&(H|=256),(I===void 0||I)&&(H|=1024),z.clear(H)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){t.removeEventListener("webglcontextlost",at,!1),t.removeEventListener("webglcontextrestored",Rt,!1),M.dispose(),X.dispose(),Mt.dispose(),rt.dispose(),bt.dispose(),q.dispose(),k.dispose(),k.removeEventListener("sessionstart",ws),k.removeEventListener("sessionend",Ss),Oe.stop()};function at(v){v.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),y=!0}function Rt(){console.log("THREE.WebGLRenderer: Context Restored."),y=!1;const v=Ct.autoReset,O=tt.enabled,I=tt.autoUpdate,H=tt.needsUpdate,J=tt.type;et(),Ct.autoReset=v,tt.enabled=O,tt.autoUpdate=I,tt.needsUpdate=H,tt.type=J}function Nt(v){const O=v.target;O.removeEventListener("dispose",Nt),xe(O)}function xe(v){Ft(v),Mt.remove(v)}function Ft(v){const O=Mt.get(v).programs;O!==void 0&&O.forEach(function(I){ft.releaseProgram(I)})}function Xt(v,O){v.render(function(I){x.renderBufferImmediate(I,O)})}this.renderBufferImmediate=function(v,O){q.initAttributes();const I=Mt.get(v);v.hasPositions&&!I.position&&(I.position=z.createBuffer()),v.hasNormals&&!I.normal&&(I.normal=z.createBuffer()),v.hasUvs&&!I.uv&&(I.uv=z.createBuffer()),v.hasColors&&!I.color&&(I.color=z.createBuffer());const H=O.getAttributes();v.hasPositions&&(z.bindBuffer(34962,I.position),z.bufferData(34962,v.positionArray,35048),q.enableAttribute(H.position),z.vertexAttribPointer(H.position,3,5126,!1,0,0)),v.hasNormals&&(z.bindBuffer(34962,I.normal),z.bufferData(34962,v.normalArray,35048),q.enableAttribute(H.normal),z.vertexAttribPointer(H.normal,3,5126,!1,0,0)),v.hasUvs&&(z.bindBuffer(34962,I.uv),z.bufferData(34962,v.uvArray,35048),q.enableAttribute(H.uv),z.vertexAttribPointer(H.uv,2,5126,!1,0,0)),v.hasColors&&(z.bindBuffer(34962,I.color),z.bufferData(34962,v.colorArray,35048),q.enableAttribute(H.color),z.vertexAttribPointer(H.color,3,5126,!1,0,0)),q.disableUnusedAttributes(),z.drawArrays(4,0,v.count),v.count=0},this.renderBufferDirect=function(v,O,I,H,J,wt){O===null&&(O=st);const ht=J.isMesh&&J.matrixWorld.determinant()<0,gt=Rs(v,O,H,J);ot.setMaterial(H,ht);let Dt=I.index;const pt=I.attributes.position;if(Dt===null){if(pt===void 0||pt.count===0)return}else if(Dt.count===0)return;let Tt=1;H.wireframe===!0&&(Dt=mt.getWireframeAttribute(I),Tt=2),(H.morphTargets||H.morphNormals)&&Lt.update(J,I,H,gt),q.setup(J,H,gt,I,Dt);let ut,Pt=xt;Dt!==null&&(ut=dt.get(Dt),Pt=A,Pt.setIndex(ut));const oe=Dt!==null?Dt.count:pt.count,Wt=I.drawRange.start*Tt,Ue=I.drawRange.count*Tt,Ht=wt!==null?wt.start*Tt:0,He=wt!==null?wt.count*Tt:1/0,Ut=Math.max(Wt,Ht),Vn=Math.min(oe,Wt+Ue,Ht+He)-1,qt=Math.max(0,Vn-Ut+1);if(qt!==0){if(J.isMesh)H.wireframe===!0?(ot.setLineWidth(H.wireframeLinewidth*ct()),Pt.setMode(1)):Pt.setMode(4);else if(J.isLine){let fe=H.linewidth;fe===void 0&&(fe=1),ot.setLineWidth(fe*ct()),J.isLineSegments?Pt.setMode(1):J.isLineLoop?Pt.setMode(2):Pt.setMode(3)}else J.isPoints?Pt.setMode(0):J.isSprite&&Pt.setMode(4);if(J.isInstancedMesh)Pt.renderInstances(Ut,qt,J.count);else if(I.isInstancedBufferGeometry){const fe=Math.min(I.instanceCount,I._maxInstanceCount);Pt.renderInstances(Ut,qt,fe)}else Pt.render(Ut,qt)}},this.compile=function(v,O){d=X.get(v),d.init(),v.traverseVisible(function(I){I.isLight&&I.layers.test(O.layers)&&(d.pushLight(I),I.castShadow&&d.pushShadow(I))}),d.setupLights(),v.traverse(function(I){const H=I.material;if(H)if(Array.isArray(H))for(let J=0;J<H.length;J++){const wt=H[J];kn(wt,v,I)}else kn(H,v,I)})};let re=null;function Bl(v){re&&re(v)}function ws(){Oe.stop()}function Ss(){Oe.start()}const Oe=new Cd;Oe.setAnimationLoop(Bl),typeof window!="undefined"&&Oe.setContext(window),this.setAnimationLoop=function(v){re=v,k.setAnimationLoop(v),v===null?Oe.stop():Oe.start()},k.addEventListener("sessionstart",ws),k.addEventListener("sessionend",Ss),this.render=function(v,O){let I,H;if(arguments[2]!==void 0&&(console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."),I=arguments[2]),arguments[3]!==void 0&&(console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."),H=arguments[3]),O!==void 0&&O.isCamera!==!0){console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(y===!0)return;v.autoUpdate===!0&&v.updateMatrixWorld(),O.parent===null&&O.updateMatrixWorld(),k.enabled===!0&&k.isPresenting===!0&&(O=k.getCamera(O)),v.isScene===!0&&v.onBeforeRender(x,v,O,I||E),d=X.get(v,p.length),d.init(),p.push(d),Q.multiplyMatrices(O.projectionMatrix,O.matrixWorldInverse),W.setFromProjectionMatrix(Q),Y=this.localClippingEnabled,j=$.init(this.clippingPlanes,Y,O),u=M.get(v,f.length),u.init(),f.push(u),Es(v,O,0,x.sortObjects),u.finish(),x.sortObjects===!0&&u.sort(V,R),j===!0&&$.beginShadows();const J=d.state.shadowsArray;tt.render(J,v,O),d.setupLights(),d.setupLightsView(O),j===!0&&$.endShadows(),this.info.autoReset===!0&&this.info.reset(),I!==void 0&&this.setRenderTarget(I),nt.render(u,v,O,H);const wt=u.opaque,ht=u.transparent;wt.length>0&&As(wt,v,O),ht.length>0&&As(ht,v,O),E!==null&&(St.updateRenderTargetMipmap(E),St.updateMultisampleRenderTarget(E)),v.isScene===!0&&v.onAfterRender(x,v,O),ot.buffers.depth.setTest(!0),ot.buffers.depth.setMask(!0),ot.buffers.color.setMask(!0),ot.setPolygonOffset(!1),q.resetDefaultState(),w=-1,S=null,p.pop(),p.length>0?d=p[p.length-1]:d=null,f.pop(),f.length>0?u=f[f.length-1]:u=null};function Es(v,O,I,H){if(v.visible===!1)return;if(v.layers.test(O.layers)){if(v.isGroup)I=v.renderOrder;else if(v.isLOD)v.autoUpdate===!0&&v.update(O);else if(v.isLight)d.pushLight(v),v.castShadow&&d.pushShadow(v);else if(v.isSprite){if(!v.frustumCulled||W.intersectsSprite(v)){H&&K.setFromMatrixPosition(v.matrixWorld).applyMatrix4(Q);const ht=bt.update(v),gt=v.material;gt.visible&&u.push(v,ht,gt,I,K.z,null)}}else if(v.isImmediateRenderObject)H&&K.setFromMatrixPosition(v.matrixWorld).applyMatrix4(Q),u.push(v,null,v.material,I,K.z,null);else if((v.isMesh||v.isLine||v.isPoints)&&(v.isSkinnedMesh&&v.skeleton.frame!==Ct.render.frame&&(v.skeleton.update(),v.skeleton.frame=Ct.render.frame),!v.frustumCulled||W.intersectsObject(v))){H&&K.setFromMatrixPosition(v.matrixWorld).applyMatrix4(Q);const ht=bt.update(v),gt=v.material;if(Array.isArray(gt)){const Dt=ht.groups;for(let pt=0,Tt=Dt.length;pt<Tt;pt++){const ut=Dt[pt],Pt=gt[ut.materialIndex];Pt&&Pt.visible&&u.push(v,ht,Pt,I,K.z,ut)}}else gt.visible&&u.push(v,ht,gt,I,K.z,null)}}const wt=v.children;for(let ht=0,gt=wt.length;ht<gt;ht++)Es(wt[ht],O,I,H)}function As(v,O,I){const H=O.isScene===!0?O.overrideMaterial:null;for(let J=0,wt=v.length;J<wt;J++){const ht=v[J],gt=ht.object,Dt=ht.geometry,pt=H===null?ht.material:H,Tt=ht.group;if(I.isArrayCamera){const ut=I.cameras;for(let Pt=0,oe=ut.length;Pt<oe;Pt++){const Wt=ut[Pt];gt.layers.test(Wt.layers)&&(ot.viewport(_.copy(Wt.viewport)),d.setupLightsView(Wt),Ts(gt,O,Wt,Dt,pt,Tt))}}else Ts(gt,O,I,Dt,pt,Tt)}}function Ts(v,O,I,H,J,wt){if(v.onBeforeRender(x,O,I,H,J,wt),v.modelViewMatrix.multiplyMatrices(I.matrixWorldInverse,v.matrixWorld),v.normalMatrix.getNormalMatrix(v.modelViewMatrix),v.isImmediateRenderObject){const ht=Rs(I,O,J,v);ot.setMaterial(J),q.reset(),Xt(v,ht)}else x.renderBufferDirect(I,O,H,J,v,wt);v.onAfterRender(x,O,I,H,J,wt)}function kn(v,O,I){O.isScene!==!0&&(O=st);const H=Mt.get(v),J=d.state.lights,wt=d.state.shadowsArray,ht=J.state.version,gt=ft.getParameters(v,J.state,wt,O,I),Dt=ft.getProgramCacheKey(gt);let pt=H.programs;H.environment=v.isMeshStandardMaterial?O.environment:null,H.fog=O.fog,H.envMap=rt.get(v.envMap||H.environment),pt===void 0&&(v.addEventListener("dispose",Nt),pt=new Map,H.programs=pt);let Tt=pt.get(Dt);if(Tt!==void 0){if(H.currentProgram===Tt&&H.lightsStateVersion===ht)return Ls(v,gt),Tt}else gt.uniforms=ft.getUniforms(v),v.onBeforeCompile(gt,x),Tt=ft.acquireProgram(gt,Dt),pt.set(Dt,Tt),H.uniforms=gt.uniforms;const ut=H.uniforms;(!v.isShaderMaterial&&!v.isRawShaderMaterial||v.clipping===!0)&&(ut.clippingPlanes=$.uniform),Ls(v,gt),H.needsLights=Ul(v),H.lightsStateVersion=ht,H.needsLights&&(ut.ambientLightColor.value=J.state.ambient,ut.lightProbe.value=J.state.probe,ut.directionalLights.value=J.state.directional,ut.directionalLightShadows.value=J.state.directionalShadow,ut.spotLights.value=J.state.spot,ut.spotLightShadows.value=J.state.spotShadow,ut.rectAreaLights.value=J.state.rectArea,ut.ltc_1.value=J.state.rectAreaLTC1,ut.ltc_2.value=J.state.rectAreaLTC2,ut.pointLights.value=J.state.point,ut.pointLightShadows.value=J.state.pointShadow,ut.hemisphereLights.value=J.state.hemi,ut.directionalShadowMap.value=J.state.directionalShadowMap,ut.directionalShadowMatrix.value=J.state.directionalShadowMatrix,ut.spotShadowMap.value=J.state.spotShadowMap,ut.spotShadowMatrix.value=J.state.spotShadowMatrix,ut.pointShadowMap.value=J.state.pointShadowMap,ut.pointShadowMatrix.value=J.state.pointShadowMatrix);const Pt=Tt.getUniforms(),oe=_n.seqWithValue(Pt.seq,ut);return H.currentProgram=Tt,H.uniformsList=oe,Tt}function Ls(v,O){const I=Mt.get(v);I.outputEncoding=O.outputEncoding,I.instancing=O.instancing,I.numClippingPlanes=O.numClippingPlanes,I.numIntersection=O.numClipIntersection,I.vertexAlphas=O.vertexAlphas}function Rs(v,O,I,H){O.isScene!==!0&&(O=st),St.resetTextureUnits();const J=O.fog,wt=I.isMeshStandardMaterial?O.environment:null,ht=E===null?x.outputEncoding:E.texture.encoding,gt=rt.get(I.envMap||wt),Dt=I.vertexColors===!0&&H.geometry.attributes.color&&H.geometry.attributes.color.itemSize===4,pt=Mt.get(I),Tt=d.state.lights;if(j===!0&&(Y===!0||v!==S)){const Ut=v===S&&I.id===w;$.setState(I,v,Ut)}let ut=!1;I.version===pt.__version?(pt.needsLights&&pt.lightsStateVersion!==Tt.state.version||pt.outputEncoding!==ht||H.isInstancedMesh&&pt.instancing===!1||!H.isInstancedMesh&&pt.instancing===!0||pt.envMap!==gt||I.fog&&pt.fog!==J||pt.numClippingPlanes!==void 0&&(pt.numClippingPlanes!==$.numPlanes||pt.numIntersection!==$.numIntersection)||pt.vertexAlphas!==Dt)&&(ut=!0):(ut=!0,pt.__version=I.version);let Pt=pt.currentProgram;ut===!0&&(Pt=kn(I,O,H));let oe=!1,Wt=!1,Ue=!1;const Ht=Pt.getUniforms(),He=pt.uniforms;if(ot.useProgram(Pt.program)&&(oe=!0,Wt=!0,Ue=!0),I.id!==w&&(w=I.id,Wt=!0),oe||S!==v){if(Ht.setValue(z,"projectionMatrix",v.projectionMatrix),yt.logarithmicDepthBuffer&&Ht.setValue(z,"logDepthBufFC",2/(Math.log(v.far+1)/Math.LN2)),S!==v&&(S=v,Wt=!0,Ue=!0),I.isShaderMaterial||I.isMeshPhongMaterial||I.isMeshToonMaterial||I.isMeshStandardMaterial||I.envMap){const Ut=Ht.map.cameraPosition;Ut!==void 0&&Ut.setValue(z,K.setFromMatrixPosition(v.matrixWorld))}(I.isMeshPhongMaterial||I.isMeshToonMaterial||I.isMeshLambertMaterial||I.isMeshBasicMaterial||I.isMeshStandardMaterial||I.isShaderMaterial)&&Ht.setValue(z,"isOrthographic",v.isOrthographicCamera===!0),(I.isMeshPhongMaterial||I.isMeshToonMaterial||I.isMeshLambertMaterial||I.isMeshBasicMaterial||I.isMeshStandardMaterial||I.isShaderMaterial||I.isShadowMaterial||I.skinning)&&Ht.setValue(z,"viewMatrix",v.matrixWorldInverse)}if(I.skinning){Ht.setOptional(z,H,"bindMatrix"),Ht.setOptional(z,H,"bindMatrixInverse");const Ut=H.skeleton;if(Ut){const Vn=Ut.bones;if(yt.floatVertexTextures){if(Ut.boneTexture===null){let qt=Math.sqrt(Vn.length*4);qt=Ot.ceilPowerOfTwo(qt),qt=Math.max(qt,4);const fe=new Float32Array(qt*qt*4);fe.set(Ut.boneMatrices);const Hl=new Cc(fe,qt,qt,hi,un);Ut.boneMatrices=fe,Ut.boneTexture=Hl,Ut.boneTextureSize=qt}Ht.setValue(z,"boneTexture",Ut.boneTexture,St),Ht.setValue(z,"boneTextureSize",Ut.boneTextureSize)}else Ht.setOptional(z,Ut,"boneMatrices")}}return(Wt||pt.receiveShadow!==H.receiveShadow)&&(pt.receiveShadow=H.receiveShadow,Ht.setValue(z,"receiveShadow",H.receiveShadow)),Wt&&(Ht.setValue(z,"toneMappingExposure",x.toneMappingExposure),pt.needsLights&&Ol(He,Ue),J&&I.fog&&b.refreshFogUniforms(He,J),b.refreshMaterialUniforms(He,I,D,G),_n.upload(z,pt.uniformsList,He,St)),I.isShaderMaterial&&I.uniformsNeedUpdate===!0&&(_n.upload(z,pt.uniformsList,He,St),I.uniformsNeedUpdate=!1),I.isSpriteMaterial&&Ht.setValue(z,"center",H.center),Ht.setValue(z,"modelViewMatrix",H.modelViewMatrix),Ht.setValue(z,"normalMatrix",H.normalMatrix),Ht.setValue(z,"modelMatrix",H.matrixWorld),Pt}function Ol(v,O){v.ambientLightColor.needsUpdate=O,v.lightProbe.needsUpdate=O,v.directionalLights.needsUpdate=O,v.directionalLightShadows.needsUpdate=O,v.pointLights.needsUpdate=O,v.pointLightShadows.needsUpdate=O,v.spotLights.needsUpdate=O,v.spotLightShadows.needsUpdate=O,v.rectAreaLights.needsUpdate=O,v.hemisphereLights.needsUpdate=O}function Ul(v){return v.isMeshLambertMaterial||v.isMeshToonMaterial||v.isMeshPhongMaterial||v.isMeshStandardMaterial||v.isShadowMaterial||v.isShaderMaterial&&v.lights===!0}this.getActiveCubeFace=function(){return g},this.getActiveMipmapLevel=function(){return m},this.getRenderTarget=function(){return E},this.setRenderTarget=function(v,O=0,I=0){E=v,g=O,m=I,v&&Mt.get(v).__webglFramebuffer===void 0&&St.setupRenderTarget(v);let H=null,J=!1,wt=!1;if(v){const ht=v.texture;(ht.isDataTexture3D||ht.isDataTexture2DArray)&&(wt=!0);const gt=Mt.get(v).__webglFramebuffer;v.isWebGLCubeRenderTarget?(H=gt[O],J=!0):v.isWebGLMultisampleRenderTarget?H=Mt.get(v).__webglMultisampledFramebuffer:H=gt,_.copy(v.viewport),T.copy(v.scissor),B=v.scissorTest}else _.copy(L).multiplyScalar(D).floor(),T.copy(P).multiplyScalar(D).floor(),B=F;if(ot.bindFramebuffer(36160,H),ot.viewport(_),ot.scissor(T),ot.setScissorTest(B),J){const ht=Mt.get(v.texture);z.framebufferTexture2D(36160,36064,34069+O,ht.__webglTexture,I)}else if(wt){const ht=Mt.get(v.texture),gt=O||0;z.framebufferTextureLayer(36160,36064,ht.__webglTexture,I||0,gt)}},this.readRenderTargetPixels=function(v,O,I,H,J,wt,ht){if(!(v&&v.isWebGLRenderTarget)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let gt=Mt.get(v).__webglFramebuffer;if(v.isWebGLCubeRenderTarget&&ht!==void 0&&(gt=gt[ht]),gt){ot.bindFramebuffer(36160,gt);try{const Dt=v.texture,pt=Dt.format,Tt=Dt.type;if(pt!==hi&&C.convert(pt)!==z.getParameter(35739)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}const ut=Tt===Va&&(At.has("EXT_color_buffer_half_float")||yt.isWebGL2&&At.has("EXT_color_buffer_float"));if(Tt!==Yl&&C.convert(Tt)!==z.getParameter(35738)&&!(Tt===un&&(yt.isWebGL2||At.has("OES_texture_float")||At.has("WEBGL_color_buffer_float")))&&!ut){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}z.checkFramebufferStatus(36160)===36053?O>=0&&O<=v.width-H&&I>=0&&I<=v.height-J&&z.readPixels(O,I,H,J,C.convert(pt),C.convert(Tt),wt):console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")}finally{const Dt=E!==null?Mt.get(E).__webglFramebuffer:null;ot.bindFramebuffer(36160,Dt)}}},this.copyFramebufferToTexture=function(v,O,I=0){const H=Math.pow(2,-I),J=Math.floor(O.image.width*H),wt=Math.floor(O.image.height*H),ht=C.convert(O.format);St.setTexture2D(O,0),z.copyTexImage2D(3553,I,ht,v.x,v.y,J,wt,0),ot.unbindTexture()},this.copyTextureToTexture=function(v,O,I,H=0){const J=O.image.width,wt=O.image.height,ht=C.convert(I.format),gt=C.convert(I.type);St.setTexture2D(I,0),z.pixelStorei(37440,I.flipY),z.pixelStorei(37441,I.premultiplyAlpha),z.pixelStorei(3317,I.unpackAlignment),O.isDataTexture?z.texSubImage2D(3553,H,v.x,v.y,J,wt,ht,gt,O.image.data):O.isCompressedTexture?z.compressedTexSubImage2D(3553,H,v.x,v.y,O.mipmaps[0].width,O.mipmaps[0].height,ht,O.mipmaps[0].data):z.texSubImage2D(3553,H,v.x,v.y,ht,gt,O.image),H===0&&I.generateMipmaps&&z.generateMipmap(3553),ot.unbindTexture()},this.copyTextureToTexture3D=function(v,O,I,H,J=0){if(x.isWebGL1Renderer){console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");return}const{width:wt,height:ht,data:gt}=I.image,Dt=C.convert(H.format),pt=C.convert(H.type);let Tt;if(H.isDataTexture3D)St.setTexture3D(H,0),Tt=32879;else if(H.isDataTexture2DArray)St.setTexture2DArray(H,0),Tt=35866;else{console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");return}z.pixelStorei(37440,H.flipY),z.pixelStorei(37441,H.premultiplyAlpha),z.pixelStorei(3317,H.unpackAlignment);const ut=z.getParameter(3314),Pt=z.getParameter(32878),oe=z.getParameter(3316),Wt=z.getParameter(3315),Ue=z.getParameter(32877);z.pixelStorei(3314,wt),z.pixelStorei(32878,ht),z.pixelStorei(3316,v.min.x),z.pixelStorei(3315,v.min.y),z.pixelStorei(32877,v.min.z),z.texSubImage3D(Tt,J,O.x,O.y,O.z,v.max.x-v.min.x+1,v.max.y-v.min.y+1,v.max.z-v.min.z+1,Dt,pt,gt),z.pixelStorei(3314,ut),z.pixelStorei(32878,Pt),z.pixelStorei(3316,oe),z.pixelStorei(3315,Wt),z.pixelStorei(32877,Ue),J===0&&H.generateMipmaps&&z.generateMipmap(Tt),ot.unbindTexture()},this.initTexture=function(v){St.setTexture2D(v,0),ot.unbindTexture()},this.resetState=function(){g=0,m=0,E=null,ot.reset(),q.reset()},typeof __THREE_DEVTOOLS__!="undefined"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}class AM extends jt{}AM.prototype.isWebGL1Renderer=!0;class af extends Bt{constructor(){super();this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.overrideMaterial=null,this.autoUpdate=!0,typeof __THREE_DEVTOOLS__!="undefined"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(t,e){return super.copy(t,e),t.background!==null&&(this.background=t.background.clone()),t.environment!==null&&(this.environment=t.environment.clone()),t.fog!==null&&(this.fog=t.fog.clone()),t.overrideMaterial!==null&&(this.overrideMaterial=t.overrideMaterial.clone()),this.autoUpdate=t.autoUpdate,this.matrixAutoUpdate=t.matrixAutoUpdate,this}toJSON(t){const e=super.toJSON(t);return this.background!==null&&(e.object.background=this.background.toJSON(t)),this.environment!==null&&(e.object.environment=this.environment.toJSON(t)),this.fog!==null&&(e.object.fog=this.fog.toJSON()),e}}af.prototype.isScene=!0;function ri(i,t){this.array=i,this.stride=t,this.count=i!==void 0?i.length/t:0,this.usage=Bs,this.updateRange={offset:0,count:-1},this.version=0,this.uuid=Ot.generateUUID()}Object.defineProperty(ri.prototype,"needsUpdate",{set:function(i){i===!0&&this.version++}});Object.assign(ri.prototype,{isInterleavedBuffer:!0,onUploadCallback:function(){},setUsage:function(i){return this.usage=i,this},copy:function(i){return this.array=new i.array.constructor(i.array),this.count=i.count,this.stride=i.stride,this.usage=i.usage,this},copyAt:function(i,t,e){i*=this.stride,e*=t.stride;for(let n=0,r=this.stride;n<r;n++)this.array[i+n]=t.array[e+n];return this},set:function(i,t=0){return this.array.set(i,t),this},clone:function(i){i.arrayBuffers===void 0&&(i.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=Ot.generateUUID()),i.arrayBuffers[this.array.buffer._uuid]===void 0&&(i.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const t=new this.array.constructor(i.arrayBuffers[this.array.buffer._uuid]),e=new ri(t,this.stride);return e.setUsage(this.usage),e},onUpload:function(i){return this.onUploadCallback=i,this},toJSON:function(i){return i.arrayBuffers===void 0&&(i.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=Ot.generateUUID()),i.arrayBuffers[this.array.buffer._uuid]===void 0&&(i.arrayBuffers[this.array.buffer._uuid]=Array.prototype.slice.call(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}});const le=new U;function js(i,t,e,n){this.name="",this.data=i,this.itemSize=t,this.offset=e,this.normalized=n===!0}Object.defineProperties(js.prototype,{count:{get:function(){return this.data.count}},array:{get:function(){return this.data.array}},needsUpdate:{set:function(i){this.data.needsUpdate=i}}});Object.assign(js.prototype,{isInterleavedBufferAttribute:!0,applyMatrix4:function(i){for(let t=0,e=this.data.count;t<e;t++)le.x=this.getX(t),le.y=this.getY(t),le.z=this.getZ(t),le.applyMatrix4(i),this.setXYZ(t,le.x,le.y,le.z);return this},applyNormalMatrix:function(i){for(let t=0,e=this.count;t<e;t++)le.x=this.getX(t),le.y=this.getY(t),le.z=this.getZ(t),le.applyNormalMatrix(i),this.setXYZ(t,le.x,le.y,le.z);return this},transformDirection:function(i){for(let t=0,e=this.count;t<e;t++)le.x=this.getX(t),le.y=this.getY(t),le.z=this.getZ(t),le.transformDirection(i),this.setXYZ(t,le.x,le.y,le.z);return this},setX:function(i,t){return this.data.array[i*this.data.stride+this.offset]=t,this},setY:function(i,t){return this.data.array[i*this.data.stride+this.offset+1]=t,this},setZ:function(i,t){return this.data.array[i*this.data.stride+this.offset+2]=t,this},setW:function(i,t){return this.data.array[i*this.data.stride+this.offset+3]=t,this},getX:function(i){return this.data.array[i*this.data.stride+this.offset]},getY:function(i){return this.data.array[i*this.data.stride+this.offset+1]},getZ:function(i){return this.data.array[i*this.data.stride+this.offset+2]},getW:function(i){return this.data.array[i*this.data.stride+this.offset+3]},setXY:function(i,t,e){return i=i*this.data.stride+this.offset,this.data.array[i+0]=t,this.data.array[i+1]=e,this},setXYZ:function(i,t,e,n){return i=i*this.data.stride+this.offset,this.data.array[i+0]=t,this.data.array[i+1]=e,this.data.array[i+2]=n,this},setXYZW:function(i,t,e,n,r){return i=i*this.data.stride+this.offset,this.data.array[i+0]=t,this.data.array[i+1]=e,this.data.array[i+2]=n,this.data.array[i+3]=r,this},clone:function(i){if(i===void 0){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");const t=[];for(let e=0;e<this.count;e++){const n=e*this.data.stride+this.offset;for(let r=0;r<this.itemSize;r++)t.push(this.data.array[n+r])}return new Gt(new this.array.constructor(t),this.itemSize,this.normalized)}else return i.interleavedBuffers===void 0&&(i.interleavedBuffers={}),i.interleavedBuffers[this.data.uuid]===void 0&&(i.interleavedBuffers[this.data.uuid]=this.data.clone(i)),new js(i.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)},toJSON:function(i){if(i===void 0){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");const t=[];for(let e=0;e<this.count;e++){const n=e*this.data.stride+this.offset;for(let r=0;r<this.itemSize;r++)t.push(this.data.array[n+r])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:t,normalized:this.normalized}}else return i.interleavedBuffers===void 0&&(i.interleavedBuffers={}),i.interleavedBuffers[this.data.uuid]===void 0&&(i.interleavedBuffers[this.data.uuid]=this.data.toJSON(i)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}});class of extends se{constructor(t){super();this.type="SpriteMaterial",this.color=new zt(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.alphaMap=t.alphaMap,this.rotation=t.rotation,this.sizeAttenuation=t.sizeAttenuation,this}}of.prototype.isSpriteMaterial=!0;let Ir;const Zs=new U,zr=new U,Nr=new U,Br=new lt,Js=new lt,lf=new It,mo=new U,Qs=new U,go=new U,cf=new lt,Fc=new lt,hf=new lt;class TM extends Bt{constructor(t){super();if(this.type="Sprite",Ir===void 0){Ir=new $t;const e=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),n=new ri(e,5);Ir.setIndex([0,1,2,0,2,3]),Ir.setAttribute("position",new js(n,3,0,!1)),Ir.setAttribute("uv",new js(n,2,3,!1))}this.geometry=Ir,this.material=t!==void 0?t:new of,this.center=new lt(.5,.5)}raycast(t,e){t.camera===null&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),zr.setFromMatrixScale(this.matrixWorld),lf.copy(t.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse,this.matrixWorld),Nr.setFromMatrixPosition(this.modelViewMatrix),t.camera.isPerspectiveCamera&&this.material.sizeAttenuation===!1&&zr.multiplyScalar(-Nr.z);const n=this.material.rotation;let r,s;n!==0&&(s=Math.cos(n),r=Math.sin(n));const a=this.center;xo(mo.set(-.5,-.5,0),Nr,a,zr,r,s),xo(Qs.set(.5,-.5,0),Nr,a,zr,r,s),xo(go.set(.5,.5,0),Nr,a,zr,r,s),cf.set(0,0),Fc.set(1,0),hf.set(1,1);let o=t.ray.intersectTriangle(mo,Qs,go,!1,Zs);if(o===null&&(xo(Qs.set(-.5,.5,0),Nr,a,zr,r,s),Fc.set(0,1),o=t.ray.intersectTriangle(mo,go,Qs,!1,Zs),o===null))return;const l=t.ray.origin.distanceTo(Zs);l<t.near||l>t.far||e.push({distance:l,point:Zs.clone(),uv:ce.getUV(Zs,mo,Qs,go,cf,Fc,hf,new lt),face:null,object:this})}copy(t){return super.copy(t),t.center!==void 0&&this.center.copy(t.center),this.material=t.material,this}}TM.prototype.isSprite=!0;function xo(i,t,e,n,r,s){Br.subVectors(i,e).addScalar(.5).multiply(n),r!==void 0?(Js.x=s*Br.x-r*Br.y,Js.y=r*Br.x+s*Br.y):Js.copy(Br),i.copy(t),i.x+=Js.x,i.y+=Js.y,i.applyMatrix4(lf)}const uf=new U,df=new Yt,ff=new Yt,LM=new U,pf=new It;function Ic(i,t){Te.call(this,i,t),this.type="SkinnedMesh",this.bindMode="attached",this.bindMatrix=new It,this.bindMatrixInverse=new It}Ic.prototype=Object.assign(Object.create(Te.prototype),{constructor:Ic,isSkinnedMesh:!0,copy:function(i){return Te.prototype.copy.call(this,i),this.bindMode=i.bindMode,this.bindMatrix.copy(i.bindMatrix),this.bindMatrixInverse.copy(i.bindMatrixInverse),this.skeleton=i.skeleton,this},bind:function(i,t){this.skeleton=i,t===void 0&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),t=this.matrixWorld),this.bindMatrix.copy(t),this.bindMatrixInverse.copy(t).invert()},pose:function(){this.skeleton.pose()},normalizeSkinWeights:function(){const i=new Yt,t=this.geometry.attributes.skinWeight;for(let e=0,n=t.count;e<n;e++){i.x=t.getX(e),i.y=t.getY(e),i.z=t.getZ(e),i.w=t.getW(e);const r=1/i.manhattanLength();r!==1/0?i.multiplyScalar(r):i.set(1,0,0,0),t.setXYZW(e,i.x,i.y,i.z,i.w)}},updateMatrixWorld:function(i){Te.prototype.updateMatrixWorld.call(this,i),this.bindMode==="attached"?this.bindMatrixInverse.copy(this.matrixWorld).invert():this.bindMode==="detached"?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)},boneTransform:function(i,t){const e=this.skeleton,n=this.geometry;df.fromBufferAttribute(n.attributes.skinIndex,i),ff.fromBufferAttribute(n.attributes.skinWeight,i),uf.fromBufferAttribute(n.attributes.position,i).applyMatrix4(this.bindMatrix),t.set(0,0,0);for(let r=0;r<4;r++){const s=ff.getComponent(r);if(s!==0){const a=df.getComponent(r);pf.multiplyMatrices(e.bones[a].matrixWorld,e.boneInverses[a]),t.addScaledVector(LM.copy(uf).applyMatrix4(pf),s)}}return t.applyMatrix4(this.bindMatrixInverse)}});function mf(){Bt.call(this),this.type="Bone"}mf.prototype=Object.assign(Object.create(Bt.prototype),{constructor:mf,isBone:!0});const gf=new It,xf=new It,yo=[],Ks=new Te;function yf(i,t,e){Te.call(this,i,t),this.instanceMatrix=new Gt(new Float32Array(e*16),16),this.instanceColor=null,this.count=e,this.frustumCulled=!1}yf.prototype=Object.assign(Object.create(Te.prototype),{constructor:yf,isInstancedMesh:!0,copy:function(i){return Te.prototype.copy.call(this,i),this.instanceMatrix.copy(i.instanceMatrix),i.instanceColor!==null&&(this.instanceColor=i.instanceColor.clone()),this.count=i.count,this},getColorAt:function(i,t){t.fromArray(this.instanceColor.array,i*3)},getMatrixAt:function(i,t){t.fromArray(this.instanceMatrix.array,i*16)},raycast:function(i,t){const e=this.matrixWorld,n=this.count;if(Ks.geometry=this.geometry,Ks.material=this.material,Ks.material!==void 0)for(let r=0;r<n;r++){this.getMatrixAt(r,gf),xf.multiplyMatrices(e,gf),Ks.matrixWorld=xf,Ks.raycast(i,yo);for(let s=0,a=yo.length;s<a;s++){const o=yo[s];o.instanceId=r,o.object=this,t.push(o)}yo.length=0}},setColorAt:function(i,t){this.instanceColor===null&&(this.instanceColor=new Gt(new Float32Array(this.count*3),3)),t.toArray(this.instanceColor.array,i*3)},setMatrixAt:function(i,t){t.toArray(this.instanceMatrix.array,i*16)},updateMorphTargets:function(){},dispose:function(){this.dispatchEvent({type:"dispose"})}});class ta extends se{constructor(t){super();this.type="LineBasicMaterial",this.color=new zt(16777215),this.linewidth=1,this.linecap="round",this.linejoin="round",this.morphTargets=!1,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.linewidth=t.linewidth,this.linecap=t.linecap,this.linejoin=t.linejoin,this.morphTargets=t.morphTargets,this}}ta.prototype.isLineBasicMaterial=!0;const _f=new U,vf=new U,Mf=new It,zc=new Yn,_o=new vr;function ea(i=new $t,t=new ta){Bt.call(this),this.type="Line",this.geometry=i,this.material=t,this.updateMorphTargets()}ea.prototype=Object.assign(Object.create(Bt.prototype),{constructor:ea,isLine:!0,copy:function(i){return Bt.prototype.copy.call(this,i),this.material=i.material,this.geometry=i.geometry,this},computeLineDistances:function(){const i=this.geometry;if(i.isBufferGeometry)if(i.index===null){const t=i.attributes.position,e=[0];for(let n=1,r=t.count;n<r;n++)_f.fromBufferAttribute(t,n-1),vf.fromBufferAttribute(t,n),e[n]=e[n-1],e[n]+=_f.distanceTo(vf);i.setAttribute("lineDistance",new ie(e,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else i.isGeometry&&console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this},raycast:function(i,t){const e=this.geometry,n=this.matrixWorld,r=i.params.Line.threshold,s=e.drawRange;if(e.boundingSphere===null&&e.computeBoundingSphere(),_o.copy(e.boundingSphere),_o.applyMatrix4(n),_o.radius+=r,i.ray.intersectsSphere(_o)===!1)return;Mf.copy(n).invert(),zc.copy(i.ray).applyMatrix4(Mf);const a=r/((this.scale.x+this.scale.y+this.scale.z)/3),o=a*a,l=new U,c=new U,h=new U,u=new U,d=this.isLineSegments?2:1;if(e.isBufferGeometry){const f=e.index,x=e.attributes.position;if(f!==null){const y=Math.max(0,s.start),g=Math.min(f.count,s.start+s.count);for(let m=y,E=g-1;m<E;m+=d){const w=f.getX(m),S=f.getX(m+1);if(l.fromBufferAttribute(x,w),c.fromBufferAttribute(x,S),zc.distanceSqToSegment(l,c,u,h)>o)continue;u.applyMatrix4(this.matrixWorld);const T=i.ray.origin.distanceTo(u);T<i.near||T>i.far||t.push({distance:T,point:h.clone().applyMatrix4(this.matrixWorld),index:m,face:null,faceIndex:null,object:this})}}else{const y=Math.max(0,s.start),g=Math.min(x.count,s.start+s.count);for(let m=y,E=g-1;m<E;m+=d){if(l.fromBufferAttribute(x,m),c.fromBufferAttribute(x,m+1),zc.distanceSqToSegment(l,c,u,h)>o)continue;u.applyMatrix4(this.matrixWorld);const S=i.ray.origin.distanceTo(u);S<i.near||S>i.far||t.push({distance:S,point:h.clone().applyMatrix4(this.matrixWorld),index:m,face:null,faceIndex:null,object:this})}}}else e.isGeometry&&console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")},updateMorphTargets:function(){const i=this.geometry;if(i.isBufferGeometry){const t=i.morphAttributes,e=Object.keys(t);if(e.length>0){const n=t[e[0]];if(n!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,s=n.length;r<s;r++){const a=n[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=r}}}}else{const t=i.morphTargets;t!==void 0&&t.length>0&&console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}});const bf=new U,wf=new U;function vo(i,t){ea.call(this,i,t),this.type="LineSegments"}vo.prototype=Object.assign(Object.create(ea.prototype),{constructor:vo,isLineSegments:!0,computeLineDistances:function(){const i=this.geometry;if(i.isBufferGeometry)if(i.index===null){const t=i.attributes.position,e=[];for(let n=0,r=t.count;n<r;n+=2)bf.fromBufferAttribute(t,n),wf.fromBufferAttribute(t,n+1),e[n]=n===0?0:e[n-1],e[n+1]=e[n]+bf.distanceTo(wf);i.setAttribute("lineDistance",new ie(e,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else i.isGeometry&&console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this}});class RM extends ea{constructor(t,e){super(t,e);this.type="LineLoop"}}RM.prototype.isLineLoop=!0;class Sf extends se{constructor(t){super();this.type="PointsMaterial",this.color=new zt(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.morphTargets=!1,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.alphaMap=t.alphaMap,this.size=t.size,this.sizeAttenuation=t.sizeAttenuation,this.morphTargets=t.morphTargets,this}}Sf.prototype.isPointsMaterial=!0;const Ef=new It,Nc=new Yn,Mo=new vr,bo=new U;function Af(i=new $t,t=new Sf){Bt.call(this),this.type="Points",this.geometry=i,this.material=t,this.updateMorphTargets()}Af.prototype=Object.assign(Object.create(Bt.prototype),{constructor:Af,isPoints:!0,copy:function(i){return Bt.prototype.copy.call(this,i),this.material=i.material,this.geometry=i.geometry,this},raycast:function(i,t){const e=this.geometry,n=this.matrixWorld,r=i.params.Points.threshold,s=e.drawRange;if(e.boundingSphere===null&&e.computeBoundingSphere(),Mo.copy(e.boundingSphere),Mo.applyMatrix4(n),Mo.radius+=r,i.ray.intersectsSphere(Mo)===!1)return;Ef.copy(n).invert(),Nc.copy(i.ray).applyMatrix4(Ef);const a=r/((this.scale.x+this.scale.y+this.scale.z)/3),o=a*a;if(e.isBufferGeometry){const l=e.index,h=e.attributes.position;if(l!==null){const u=Math.max(0,s.start),d=Math.min(l.count,s.start+s.count);for(let f=u,p=d;f<p;f++){const x=l.getX(f);bo.fromBufferAttribute(h,x),Tf(bo,x,o,n,i,t,this)}}else{const u=Math.max(0,s.start),d=Math.min(h.count,s.start+s.count);for(let f=u,p=d;f<p;f++)bo.fromBufferAttribute(h,f),Tf(bo,f,o,n,i,t,this)}}else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")},updateMorphTargets:function(){const i=this.geometry;if(i.isBufferGeometry){const t=i.morphAttributes,e=Object.keys(t);if(e.length>0){const n=t[e[0]];if(n!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,s=n.length;r<s;r++){const a=n[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=r}}}}else{const t=i.morphTargets;t!==void 0&&t.length>0&&console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}});function Tf(i,t,e,n,r,s,a){const o=Nc.distanceSqToPoint(i);if(o<e){const l=new U;Nc.closestPointToPoint(i,l),l.applyMatrix4(n);const c=r.ray.origin.distanceTo(l);if(c<r.near||c>r.far)return;s.push({distance:c,distanceToRay:Math.sqrt(o),point:l,index:t,face:null,object:a})}}class CM extends Ee{constructor(t,e,n,r,s,a,o,l,c){super(t,e,n,r,s,a,o,l,c);this.format=o!==void 0?o:Wn,this.minFilter=a!==void 0?a:be,this.magFilter=s!==void 0?s:be,this.generateMipmaps=!1;const h=this;function u(){h.needsUpdate=!0,t.requestVideoFrameCallback(u)}"requestVideoFrameCallback"in t&&t.requestVideoFrameCallback(u)}clone(){return new this.constructor(this.image).copy(this)}update(){const t=this.image;"requestVideoFrameCallback"in t===!1&&t.readyState>=t.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}}CM.prototype.isVideoTexture=!0;class Lf extends Ee{constructor(t,e,n,r,s,a,o,l,c,h,u,d){super(null,a,o,l,c,h,r,s,u,d);this.image={width:e,height:n},this.mipmaps=t,this.flipY=!1,this.generateMipmaps=!1}}Lf.prototype.isCompressedTexture=!0;class PM extends Ee{constructor(t,e,n,r,s,a,o,l,c){super(t,e,n,r,s,a,o,l,c);this.needsUpdate=!0}}PM.prototype.isCanvasTexture=!0;class DM extends Ee{constructor(t,e,n,r,s,a,o,l,c,h){if(h=h!==void 0?h:ur,h!==ur&&h!==zs)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");n===void 0&&h===ur&&(n=Ga),n===void 0&&h===zs&&(n=Is);super(null,r,s,a,o,l,h,n,c);this.image={width:t,height:e},this.magFilter=o!==void 0?o:Ge,this.minFilter=l!==void 0?l:Ge,this.flipY=!1,this.generateMipmaps=!1}}DM.prototype.isDepthTexture=!0;new U;new U;new U;new ce;const FM={triangulate:function(i,t,e){e=e||2;const n=t&&t.length,r=n?t[0]*e:i.length;let s=Rf(i,0,r,e,!0);const a=[];if(!s||s.next===s.prev)return a;let o,l,c,h,u,d,f;if(n&&(s=OM(i,t,s,e)),i.length>80*e){o=c=i[0],l=h=i[1];for(let p=e;p<r;p+=e)u=i[p],d=i[p+1],u<o&&(o=u),d<l&&(l=d),u>c&&(c=u),d>h&&(h=d);f=Math.max(c-o,h-l),f=f!==0?1/f:0}return ia(s,a,e,o,l,f),a}};function Rf(i,t,e,n,r){let s,a;if(r===jM(i,t,e,n)>0)for(s=t;s<e;s+=n)a=Df(s,i[s],i[s+1],a);else for(s=e-n;s>=t;s-=n)a=Df(s,i[s],i[s+1],a);return a&&wo(a,a.next)&&(ra(a),a=a.next),a}function vn(i,t){if(!i)return i;t||(t=i);let e=i,n;do if(n=!1,!e.steiner&&(wo(e,e.next)||ae(e.prev,e,e.next)===0)){if(ra(e),e=t=e.prev,e===e.next)break;n=!0}else e=e.next;while(n||e!==t);return t}function ia(i,t,e,n,r,s,a){if(!i)return;!a&&s&&VM(i,n,r,s);let o=i,l,c;for(;i.prev!==i.next;){if(l=i.prev,c=i.next,s?zM(i,n,r,s):IM(i)){t.push(l.i/e),t.push(i.i/e),t.push(c.i/e),ra(i),i=c.next,o=c.next;continue}if(i=c,i===o){a?a===1?(i=NM(vn(i),t,e),ia(i,t,e,n,r,s,2)):a===2&&BM(i,t,e,n,r,s):ia(vn(i),t,e,n,r,s,1);break}}}function IM(i){const t=i.prev,e=i,n=i.next;if(ae(t,e,n)>=0)return!1;let r=i.next.next;for(;r!==i.prev;){if(Or(t.x,t.y,e.x,e.y,n.x,n.y,r.x,r.y)&&ae(r.prev,r,r.next)>=0)return!1;r=r.next}return!0}function zM(i,t,e,n){const r=i.prev,s=i,a=i.next;if(ae(r,s,a)>=0)return!1;const o=r.x<s.x?r.x<a.x?r.x:a.x:s.x<a.x?s.x:a.x,l=r.y<s.y?r.y<a.y?r.y:a.y:s.y<a.y?s.y:a.y,c=r.x>s.x?r.x>a.x?r.x:a.x:s.x>a.x?s.x:a.x,h=r.y>s.y?r.y>a.y?r.y:a.y:s.y>a.y?s.y:a.y,u=Bc(o,l,t,e,n),d=Bc(c,h,t,e,n);let f=i.prevZ,p=i.nextZ;for(;f&&f.z>=u&&p&&p.z<=d;){if(f!==i.prev&&f!==i.next&&Or(r.x,r.y,s.x,s.y,a.x,a.y,f.x,f.y)&&ae(f.prev,f,f.next)>=0||(f=f.prevZ,p!==i.prev&&p!==i.next&&Or(r.x,r.y,s.x,s.y,a.x,a.y,p.x,p.y)&&ae(p.prev,p,p.next)>=0))return!1;p=p.nextZ}for(;f&&f.z>=u;){if(f!==i.prev&&f!==i.next&&Or(r.x,r.y,s.x,s.y,a.x,a.y,f.x,f.y)&&ae(f.prev,f,f.next)>=0)return!1;f=f.prevZ}for(;p&&p.z<=d;){if(p!==i.prev&&p!==i.next&&Or(r.x,r.y,s.x,s.y,a.x,a.y,p.x,p.y)&&ae(p.prev,p,p.next)>=0)return!1;p=p.nextZ}return!0}function NM(i,t,e){let n=i;do{const r=n.prev,s=n.next.next;!wo(r,s)&&Cf(r,n,n.next,s)&&na(r,s)&&na(s,r)&&(t.push(r.i/e),t.push(n.i/e),t.push(s.i/e),ra(n),ra(n.next),n=i=s),n=n.next}while(n!==i);return vn(n)}function BM(i,t,e,n,r,s){let a=i;do{let o=a.next.next;for(;o!==a.prev;){if(a.i!==o.i&&XM(a,o)){let l=Pf(a,o);a=vn(a,a.next),l=vn(l,l.next),ia(a,t,e,n,r,s),ia(l,t,e,n,r,s);return}o=o.next}a=a.next}while(a!==i)}function OM(i,t,e,n){const r=[];let s,a,o,l,c;for(s=0,a=t.length;s<a;s++)o=t[s]*n,l=s<a-1?t[s+1]*n:i.length,c=Rf(i,o,l,n,!1),c===c.next&&(c.steiner=!0),r.push($M(c));for(r.sort(UM),s=0;s<r.length;s++)HM(r[s],e),e=vn(e,e.next);return e}function UM(i,t){return i.x-t.x}function HM(i,t){if(t=GM(i,t),t){const e=Pf(t,i);vn(t,t.next),vn(e,e.next)}}function GM(i,t){let e=t;const n=i.x,r=i.y;let s=-1/0,a;do{if(r<=e.y&&r>=e.next.y&&e.next.y!==e.y){const d=e.x+(r-e.y)*(e.next.x-e.x)/(e.next.y-e.y);if(d<=n&&d>s){if(s=d,d===n){if(r===e.y)return e;if(r===e.next.y)return e.next}a=e.x<e.next.x?e:e.next}}e=e.next}while(e!==t);if(!a)return null;if(n===s)return a;const o=a,l=a.x,c=a.y;let h=1/0,u;e=a;do n>=e.x&&e.x>=l&&n!==e.x&&Or(r<c?n:s,r,l,c,r<c?s:n,r,e.x,e.y)&&(u=Math.abs(r-e.y)/(n-e.x),na(e,i)&&(u<h||u===h&&(e.x>a.x||e.x===a.x&&kM(a,e)))&&(a=e,h=u)),e=e.next;while(e!==o);return a}function kM(i,t){return ae(i.prev,i,t.prev)<0&&ae(t.next,i,i.next)<0}function VM(i,t,e,n){let r=i;do r.z===null&&(r.z=Bc(r.x,r.y,t,e,n)),r.prevZ=r.prev,r.nextZ=r.next,r=r.next;while(r!==i);r.prevZ.nextZ=null,r.prevZ=null,WM(r)}function WM(i){let t,e,n,r,s,a,o,l,c=1;do{for(e=i,i=null,s=null,a=0;e;){for(a++,n=e,o=0,t=0;t<c&&(o++,n=n.nextZ,!!n);t++);for(l=c;o>0||l>0&&n;)o!==0&&(l===0||!n||e.z<=n.z)?(r=e,e=e.nextZ,o--):(r=n,n=n.nextZ,l--),s?s.nextZ=r:i=r,r.prevZ=s,s=r;e=n}s.nextZ=null,c*=2}while(a>1);return i}function Bc(i,t,e,n,r){return i=32767*(i-e)*r,t=32767*(t-n)*r,i=(i|i<<8)&16711935,i=(i|i<<4)&252645135,i=(i|i<<2)&858993459,i=(i|i<<1)&1431655765,t=(t|t<<8)&16711935,t=(t|t<<4)&252645135,t=(t|t<<2)&858993459,t=(t|t<<1)&1431655765,i|t<<1}function $M(i){let t=i,e=i;do(t.x<e.x||t.x===e.x&&t.y<e.y)&&(e=t),t=t.next;while(t!==i);return e}function Or(i,t,e,n,r,s,a,o){return(r-a)*(t-o)-(i-a)*(s-o)>=0&&(i-a)*(n-o)-(e-a)*(t-o)>=0&&(e-a)*(s-o)-(r-a)*(n-o)>=0}function XM(i,t){return i.next.i!==t.i&&i.prev.i!==t.i&&!qM(i,t)&&(na(i,t)&&na(t,i)&&YM(i,t)&&(ae(i.prev,i,t.prev)||ae(i,t.prev,t))||wo(i,t)&&ae(i.prev,i,i.next)>0&&ae(t.prev,t,t.next)>0)}function ae(i,t,e){return(t.y-i.y)*(e.x-t.x)-(t.x-i.x)*(e.y-t.y)}function wo(i,t){return i.x===t.x&&i.y===t.y}function Cf(i,t,e,n){const r=Eo(ae(i,t,e)),s=Eo(ae(i,t,n)),a=Eo(ae(e,n,i)),o=Eo(ae(e,n,t));return!!(r!==s&&a!==o||r===0&&So(i,e,t)||s===0&&So(i,n,t)||a===0&&So(e,i,n)||o===0&&So(e,t,n))}function So(i,t,e){return t.x<=Math.max(i.x,e.x)&&t.x>=Math.min(i.x,e.x)&&t.y<=Math.max(i.y,e.y)&&t.y>=Math.min(i.y,e.y)}function Eo(i){return i>0?1:i<0?-1:0}function qM(i,t){let e=i;do{if(e.i!==i.i&&e.next.i!==i.i&&e.i!==t.i&&e.next.i!==t.i&&Cf(e,e.next,i,t))return!0;e=e.next}while(e!==i);return!1}function na(i,t){return ae(i.prev,i,i.next)<0?ae(i,t,i.next)>=0&&ae(i,i.prev,t)>=0:ae(i,t,i.prev)<0||ae(i,i.next,t)<0}function YM(i,t){let e=i,n=!1;const r=(i.x+t.x)/2,s=(i.y+t.y)/2;do e.y>s!=e.next.y>s&&e.next.y!==e.y&&r<(e.next.x-e.x)*(s-e.y)/(e.next.y-e.y)+e.x&&(n=!n),e=e.next;while(e!==i);return n}function Pf(i,t){const e=new Oc(i.i,i.x,i.y),n=new Oc(t.i,t.x,t.y),r=i.next,s=t.prev;return i.next=t,t.prev=i,e.next=r,r.prev=e,n.next=e,e.prev=n,s.next=n,n.prev=s,n}function Df(i,t,e,n){const r=new Oc(i,t,e);return n?(r.next=n.next,r.prev=n,n.next.prev=r,n.next=r):(r.prev=r,r.next=r),r}function ra(i){i.next.prev=i.prev,i.prev.next=i.next,i.prevZ&&(i.prevZ.nextZ=i.nextZ),i.nextZ&&(i.nextZ.prevZ=i.prevZ)}function Oc(i,t,e){this.i=i,this.x=t,this.y=e,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}function jM(i,t,e,n){let r=0;for(let s=t,a=e-n;s<e;s+=n)r+=(i[a]-i[s])*(i[s+1]+i[a+1]),a=s;return r}const jn={area:function(i){const t=i.length;let e=0;for(let n=t-1,r=0;r<t;n=r++)e+=i[n].x*i[r].y-i[r].x*i[n].y;return e*.5},isClockWise:function(i){return jn.area(i)<0},triangulateShape:function(i,t){const e=[],n=[],r=[];Ff(i),If(e,i);let s=i.length;t.forEach(Ff);for(let o=0;o<t.length;o++)n.push(s),s+=t[o].length,If(e,t[o]);const a=FM.triangulate(e,n);for(let o=0;o<a.length;o+=3)r.push(a.slice(o,o+3));return r}};function Ff(i){const t=i.length;t>2&&i[t-1].equals(i[0])&&i.pop()}function If(i,t){for(let e=0;e<t.length;e++)i.push(t[e].x),i.push(t[e].y)}class Ao extends $t{constructor(t,e){super();this.type="ExtrudeGeometry",this.parameters={shapes:t,options:e},t=Array.isArray(t)?t:[t];const n=this,r=[],s=[];for(let o=0,l=t.length;o<l;o++){const c=t[o];a(c)}this.setAttribute("position",new ie(r,3)),this.setAttribute("uv",new ie(s,2)),this.computeVertexNormals();function a(o){const l=[],c=e.curveSegments!==void 0?e.curveSegments:12,h=e.steps!==void 0?e.steps:1;let u=e.depth!==void 0?e.depth:100,d=e.bevelEnabled!==void 0?e.bevelEnabled:!0,f=e.bevelThickness!==void 0?e.bevelThickness:6,p=e.bevelSize!==void 0?e.bevelSize:f-2,x=e.bevelOffset!==void 0?e.bevelOffset:0,y=e.bevelSegments!==void 0?e.bevelSegments:3;const g=e.extrudePath,m=e.UVGenerator!==void 0?e.UVGenerator:ZM;e.amount!==void 0&&(console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."),u=e.amount);let E,w=!1,S,_,T,B;g&&(E=g.getSpacedPoints(h),w=!0,d=!1,S=g.computeFrenetFrames(h,!1),_=new U,T=new U,B=new U),d||(y=0,f=0,p=0,x=0);const N=o.extractPoints(c);let G=N.shape;const D=N.holes;if(!jn.isClockWise(G)){G=G.reverse();for(let rt=0,dt=D.length;rt<dt;rt++){const mt=D[rt];jn.isClockWise(mt)&&(D[rt]=mt.reverse())}}const R=jn.triangulateShape(G,D),L=G;for(let rt=0,dt=D.length;rt<dt;rt++){const mt=D[rt];G=G.concat(mt)}function P(rt,dt,mt){return dt||console.error("THREE.ExtrudeGeometry: vec does not exist"),dt.clone().multiplyScalar(mt).add(rt)}const F=G.length,W=R.length;function j(rt,dt,mt){let bt,ft,b;const M=rt.x-dt.x,X=rt.y-dt.y,$=mt.x-rt.x,tt=mt.y-rt.y,nt=M*M+X*X,Lt=M*tt-X*$;if(Math.abs(Lt)>Number.EPSILON){const xt=Math.sqrt(nt),A=Math.sqrt($*$+tt*tt),C=dt.x-X/xt,q=dt.y+M/xt,et=mt.x-tt/A,k=mt.y+$/A,at=((et-C)*tt-(k-q)*$)/(M*tt-X*$);bt=C+M*at-rt.x,ft=q+X*at-rt.y;const Rt=bt*bt+ft*ft;if(Rt<=2)return new lt(bt,ft);b=Math.sqrt(Rt/2)}else{let xt=!1;M>Number.EPSILON?$>Number.EPSILON&&(xt=!0):M<-Number.EPSILON?$<-Number.EPSILON&&(xt=!0):Math.sign(X)===Math.sign(tt)&&(xt=!0),xt?(bt=-X,ft=M,b=Math.sqrt(nt)):(bt=M,ft=X,b=Math.sqrt(nt/2))}return new lt(bt/b,ft/b)}const Y=[];for(let rt=0,dt=L.length,mt=dt-1,bt=rt+1;rt<dt;rt++,mt++,bt++)mt===dt&&(mt=0),bt===dt&&(bt=0),Y[rt]=j(L[rt],L[mt],L[bt]);const Q=[];let K,st=Y.concat();for(let rt=0,dt=D.length;rt<dt;rt++){const mt=D[rt];K=[];for(let bt=0,ft=mt.length,b=ft-1,M=bt+1;bt<ft;bt++,b++,M++)b===ft&&(b=0),M===ft&&(M=0),K[bt]=j(mt[bt],mt[b],mt[M]);Q.push(K),st=st.concat(K)}for(let rt=0;rt<y;rt++){const dt=rt/y,mt=f*Math.cos(dt*Math.PI/2),bt=p*Math.sin(dt*Math.PI/2)+x;for(let ft=0,b=L.length;ft<b;ft++){const M=P(L[ft],Y[ft],bt);yt(M.x,M.y,-mt)}for(let ft=0,b=D.length;ft<b;ft++){const M=D[ft];K=Q[ft];for(let X=0,$=M.length;X<$;X++){const tt=P(M[X],K[X],bt);yt(tt.x,tt.y,-mt)}}}const ct=p+x;for(let rt=0;rt<F;rt++){const dt=d?P(G[rt],st[rt],ct):G[rt];w?(T.copy(S.normals[0]).multiplyScalar(dt.x),_.copy(S.binormals[0]).multiplyScalar(dt.y),B.copy(E[0]).add(T).add(_),yt(B.x,B.y,B.z)):yt(dt.x,dt.y,0)}for(let rt=1;rt<=h;rt++)for(let dt=0;dt<F;dt++){const mt=d?P(G[dt],st[dt],ct):G[dt];w?(T.copy(S.normals[rt]).multiplyScalar(mt.x),_.copy(S.binormals[rt]).multiplyScalar(mt.y),B.copy(E[rt]).add(T).add(_),yt(B.x,B.y,B.z)):yt(mt.x,mt.y,u/h*rt)}for(let rt=y-1;rt>=0;rt--){const dt=rt/y,mt=f*Math.cos(dt*Math.PI/2),bt=p*Math.sin(dt*Math.PI/2)+x;for(let ft=0,b=L.length;ft<b;ft++){const M=P(L[ft],Y[ft],bt);yt(M.x,M.y,u+mt)}for(let ft=0,b=D.length;ft<b;ft++){const M=D[ft];K=Q[ft];for(let X=0,$=M.length;X<$;X++){const tt=P(M[X],K[X],bt);w?yt(tt.x,tt.y+E[h-1].y,E[h-1].x+mt):yt(tt.x,tt.y,u+mt)}}}z(),Et();function z(){const rt=r.length/3;if(d){let dt=0,mt=F*dt;for(let bt=0;bt<W;bt++){const ft=R[bt];ot(ft[2]+mt,ft[1]+mt,ft[0]+mt)}dt=h+y*2,mt=F*dt;for(let bt=0;bt<W;bt++){const ft=R[bt];ot(ft[0]+mt,ft[1]+mt,ft[2]+mt)}}else{for(let dt=0;dt<W;dt++){const mt=R[dt];ot(mt[2],mt[1],mt[0])}for(let dt=0;dt<W;dt++){const mt=R[dt];ot(mt[0]+F*h,mt[1]+F*h,mt[2]+F*h)}}n.addGroup(rt,r.length/3-rt,0)}function Et(){const rt=r.length/3;let dt=0;At(L,dt),dt+=L.length;for(let mt=0,bt=D.length;mt<bt;mt++){const ft=D[mt];At(ft,dt),dt+=ft.length}n.addGroup(rt,r.length/3-rt,1)}function At(rt,dt){let mt=rt.length;for(;--mt>=0;){const bt=mt;let ft=mt-1;ft<0&&(ft=rt.length-1);for(let b=0,M=h+y*2;b<M;b++){const X=F*b,$=F*(b+1),tt=dt+bt+X,nt=dt+ft+X,Lt=dt+ft+$,xt=dt+bt+$;Ct(tt,nt,Lt,xt)}}}function yt(rt,dt,mt){l.push(rt),l.push(dt),l.push(mt)}function ot(rt,dt,mt){Mt(rt),Mt(dt),Mt(mt);const bt=r.length/3,ft=m.generateTopUV(n,r,bt-3,bt-2,bt-1);St(ft[0]),St(ft[1]),St(ft[2])}function Ct(rt,dt,mt,bt){Mt(rt),Mt(dt),Mt(bt),Mt(dt),Mt(mt),Mt(bt);const ft=r.length/3,b=m.generateSideWallUV(n,r,ft-6,ft-3,ft-2,ft-1);St(b[0]),St(b[1]),St(b[3]),St(b[1]),St(b[2]),St(b[3])}function Mt(rt){r.push(l[rt*3+0]),r.push(l[rt*3+1]),r.push(l[rt*3+2])}function St(rt){s.push(rt.x),s.push(rt.y)}}}toJSON(){const t=$t.prototype.toJSON.call(this),e=this.parameters.shapes,n=this.parameters.options;return JM(e,n,t)}}const ZM={generateTopUV:function(i,t,e,n,r){const s=t[e*3],a=t[e*3+1],o=t[n*3],l=t[n*3+1],c=t[r*3],h=t[r*3+1];return[new lt(s,a),new lt(o,l),new lt(c,h)]},generateSideWallUV:function(i,t,e,n,r,s){const a=t[e*3],o=t[e*3+1],l=t[e*3+2],c=t[n*3],h=t[n*3+1],u=t[n*3+2],d=t[r*3],f=t[r*3+1],p=t[r*3+2],x=t[s*3],y=t[s*3+1],g=t[s*3+2];return Math.abs(o-h)<.01?[new lt(a,1-l),new lt(c,1-u),new lt(d,1-p),new lt(x,1-g)]:[new lt(o,1-l),new lt(h,1-u),new lt(f,1-p),new lt(y,1-g)]}};function JM(i,t,e){if(e.shapes=[],Array.isArray(i))for(let n=0,r=i.length;n<r;n++){const s=i[n];e.shapes.push(s.uuid)}else e.shapes.push(i.uuid);return t.extrudePath!==void 0&&(e.options.extrudePath=t.extrudePath.toJSON()),e}function Uc(i,t,e){$t.call(this),this.type="ParametricGeometry",this.parameters={func:i,slices:t,stacks:e};const n=[],r=[],s=[],a=[],o=1e-5,l=new U,c=new U,h=new U,u=new U,d=new U;i.length<3&&console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");const f=t+1;for(let p=0;p<=e;p++){const x=p/e;for(let y=0;y<=t;y++){const g=y/t;i(g,x,c),r.push(c.x,c.y,c.z),g-o>=0?(i(g-o,x,h),u.subVectors(c,h)):(i(g+o,x,h),u.subVectors(h,c)),x-o>=0?(i(g,x-o,h),d.subVectors(c,h)):(i(g,x+o,h),d.subVectors(h,c)),l.crossVectors(u,d).normalize(),s.push(l.x,l.y,l.z),a.push(g,x)}}for(let p=0;p<e;p++)for(let x=0;x<t;x++){const y=p*f+x,g=p*f+x+1,m=(p+1)*f+x+1,E=(p+1)*f+x;n.push(y,g,E),n.push(g,m,E)}this.setIndex(n),this.setAttribute("position",new ie(r,3)),this.setAttribute("normal",new ie(s,3)),this.setAttribute("uv",new ie(a,2))}Uc.prototype=Object.create($t.prototype);Uc.prototype.constructor=Uc;class QM extends $t{constructor(t,e=12){super();this.type="ShapeGeometry",this.parameters={shapes:t,curveSegments:e};const n=[],r=[],s=[],a=[];let o=0,l=0;if(Array.isArray(t)===!1)c(t);else for(let h=0;h<t.length;h++)c(t[h]),this.addGroup(o,l,h),o+=l,l=0;this.setIndex(n),this.setAttribute("position",new ie(r,3)),this.setAttribute("normal",new ie(s,3)),this.setAttribute("uv",new ie(a,2));function c(h){const u=r.length/3,d=h.extractPoints(e);let f=d.shape;const p=d.holes;jn.isClockWise(f)===!1&&(f=f.reverse());for(let y=0,g=p.length;y<g;y++){const m=p[y];jn.isClockWise(m)===!0&&(p[y]=m.reverse())}const x=jn.triangulateShape(f,p);for(let y=0,g=p.length;y<g;y++){const m=p[y];f=f.concat(m)}for(let y=0,g=f.length;y<g;y++){const m=f[y];r.push(m.x,m.y,0),s.push(0,0,1),a.push(m.x,m.y)}for(let y=0,g=x.length;y<g;y++){const m=x[y],E=m[0]+u,w=m[1]+u,S=m[2]+u;n.push(E,w,S),l+=3}}}toJSON(){const t=$t.prototype.toJSON.call(this),e=this.parameters.shapes;return KM(e,t)}}function KM(i,t){if(t.shapes=[],Array.isArray(i))for(let e=0,n=i.length;e<n;e++){const r=i[e];t.shapes.push(r.uuid)}else t.shapes.push(i.uuid);return t}class tb extends se{constructor(t){super();this.type="ShadowMaterial",this.color=new zt(0),this.transparent=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this}}tb.prototype.isShadowMaterial=!0;class eb extends ni{constructor(t){super(t);this.type="RawShaderMaterial"}}eb.prototype.isRawShaderMaterial=!0;function Mn(i){se.call(this),this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new zt(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new zt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=pr,this.normalScale=new lt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.flatShading=!1,this.vertexTangents=!1,this.setValues(i)}Mn.prototype=Object.create(se.prototype);Mn.prototype.constructor=Mn;Mn.prototype.isMeshStandardMaterial=!0;Mn.prototype.copy=function(i){return se.prototype.copy.call(this,i),this.defines={STANDARD:""},this.color.copy(i.color),this.roughness=i.roughness,this.metalness=i.metalness,this.map=i.map,this.lightMap=i.lightMap,this.lightMapIntensity=i.lightMapIntensity,this.aoMap=i.aoMap,this.aoMapIntensity=i.aoMapIntensity,this.emissive.copy(i.emissive),this.emissiveMap=i.emissiveMap,this.emissiveIntensity=i.emissiveIntensity,this.bumpMap=i.bumpMap,this.bumpScale=i.bumpScale,this.normalMap=i.normalMap,this.normalMapType=i.normalMapType,this.normalScale.copy(i.normalScale),this.displacementMap=i.displacementMap,this.displacementScale=i.displacementScale,this.displacementBias=i.displacementBias,this.roughnessMap=i.roughnessMap,this.metalnessMap=i.metalnessMap,this.alphaMap=i.alphaMap,this.envMap=i.envMap,this.envMapIntensity=i.envMapIntensity,this.refractionRatio=i.refractionRatio,this.wireframe=i.wireframe,this.wireframeLinewidth=i.wireframeLinewidth,this.wireframeLinecap=i.wireframeLinecap,this.wireframeLinejoin=i.wireframeLinejoin,this.skinning=i.skinning,this.morphTargets=i.morphTargets,this.morphNormals=i.morphNormals,this.flatShading=i.flatShading,this.vertexTangents=i.vertexTangents,this};function Ur(i){Mn.call(this),this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.clearcoat=0,this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new lt(1,1),this.clearcoatNormalMap=null,this.reflectivity=.5,Object.defineProperty(this,"ior",{get:function(){return(1+.4*this.reflectivity)/(1-.4*this.reflectivity)},set:function(t){this.reflectivity=Ot.clamp(2.5*(t-1)/(t+1),0,1)}}),this.sheen=null,this.transmission=0,this.transmissionMap=null,this.setValues(i)}Ur.prototype=Object.create(Mn.prototype);Ur.prototype.constructor=Ur;Ur.prototype.isMeshPhysicalMaterial=!0;Ur.prototype.copy=function(i){return Mn.prototype.copy.call(this,i),this.defines={STANDARD:"",PHYSICAL:""},this.clearcoat=i.clearcoat,this.clearcoatMap=i.clearcoatMap,this.clearcoatRoughness=i.clearcoatRoughness,this.clearcoatRoughnessMap=i.clearcoatRoughnessMap,this.clearcoatNormalMap=i.clearcoatNormalMap,this.clearcoatNormalScale.copy(i.clearcoatNormalScale),this.reflectivity=i.reflectivity,i.sheen?this.sheen=(this.sheen||new zt).copy(i.sheen):this.sheen=null,this.transmission=i.transmission,this.transmissionMap=i.transmissionMap,this};class ib extends se{constructor(t){super();this.type="MeshPhongMaterial",this.color=new zt(16777215),this.specular=new zt(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new zt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=pr,this.normalScale=new lt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=Ua,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.flatShading=!1,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.specular.copy(t.specular),this.shininess=t.shininess,this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.skinning=t.skinning,this.morphTargets=t.morphTargets,this.morphNormals=t.morphNormals,this.flatShading=t.flatShading,this}}ib.prototype.isMeshPhongMaterial=!0;class nb extends se{constructor(t){super();this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new zt(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new zt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=pr,this.normalScale=new lt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.gradientMap=t.gradientMap,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.alphaMap=t.alphaMap,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.skinning=t.skinning,this.morphTargets=t.morphTargets,this.morphNormals=t.morphNormals,this}}nb.prototype.isMeshToonMaterial=!0;class rb extends se{constructor(t){super();this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=pr,this.normalScale=new lt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.flatShading=!1,this.setValues(t)}copy(t){return super.copy(t),this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.skinning=t.skinning,this.morphTargets=t.morphTargets,this.morphNormals=t.morphNormals,this.flatShading=t.flatShading,this}}rb.prototype.isMeshNormalMaterial=!0;class sb extends se{constructor(t){super();this.type="MeshLambertMaterial",this.color=new zt(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new zt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=Ua,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.skinning=t.skinning,this.morphTargets=t.morphTargets,this.morphNormals=t.morphNormals,this}}sb.prototype.isMeshLambertMaterial=!0;class ab extends se{constructor(t){super();this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new zt(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=pr,this.normalScale=new lt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.flatShading=!1,this.setValues(t)}copy(t){return super.copy(t),this.defines={MATCAP:""},this.color.copy(t.color),this.matcap=t.matcap,this.map=t.map,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.alphaMap=t.alphaMap,this.skinning=t.skinning,this.morphTargets=t.morphTargets,this.morphNormals=t.morphNormals,this.flatShading=t.flatShading,this}}ab.prototype.isMeshMatcapMaterial=!0;class ob extends ta{constructor(t){super();this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(t)}copy(t){return super.copy(t),this.scale=t.scale,this.dashSize=t.dashSize,this.gapSize=t.gapSize,this}}ob.prototype.isLineDashedMaterial=!0;const ne={arraySlice:function(i,t,e){return ne.isTypedArray(i)?new i.constructor(i.subarray(t,e!==void 0?e:i.length)):i.slice(t,e)},convertArray:function(i,t,e){return!i||!e&&i.constructor===t?i:typeof t.BYTES_PER_ELEMENT=="number"?new t(i):Array.prototype.slice.call(i)},isTypedArray:function(i){return ArrayBuffer.isView(i)&&!(i instanceof DataView)},getKeyframeOrder:function(i){function t(r,s){return i[r]-i[s]}const e=i.length,n=new Array(e);for(let r=0;r!==e;++r)n[r]=r;return n.sort(t),n},sortedArray:function(i,t,e){const n=i.length,r=new i.constructor(n);for(let s=0,a=0;a!==n;++s){const o=e[s]*t;for(let l=0;l!==t;++l)r[a++]=i[o+l]}return r},flattenJSON:function(i,t,e,n){let r=1,s=i[0];for(;s!==void 0&&s[n]===void 0;)s=i[r++];if(s===void 0)return;let a=s[n];if(a!==void 0)if(Array.isArray(a))do a=s[n],a!==void 0&&(t.push(s.time),e.push.apply(e,a)),s=i[r++];while(s!==void 0);else if(a.toArray!==void 0)do a=s[n],a!==void 0&&(t.push(s.time),a.toArray(e,e.length)),s=i[r++];while(s!==void 0);else do a=s[n],a!==void 0&&(t.push(s.time),e.push(a)),s=i[r++];while(s!==void 0)},subclip:function(i,t,e,n,r=30){const s=i.clone();s.name=t;const a=[];for(let l=0;l<s.tracks.length;++l){const c=s.tracks[l],h=c.getValueSize(),u=[],d=[];for(let f=0;f<c.times.length;++f){const p=c.times[f]*r;if(!(p<e||p>=n)){u.push(c.times[f]);for(let x=0;x<h;++x)d.push(c.values[f*h+x])}}u.length!==0&&(c.times=ne.convertArray(u,c.times.constructor),c.values=ne.convertArray(d,c.values.constructor),a.push(c))}s.tracks=a;let o=1/0;for(let l=0;l<s.tracks.length;++l)o>s.tracks[l].times[0]&&(o=s.tracks[l].times[0]);for(let l=0;l<s.tracks.length;++l)s.tracks[l].shift(-1*o);return s.resetDuration(),s},makeClipAdditive:function(i,t=0,e=i,n=30){n<=0&&(n=30);const r=e.tracks.length,s=t/n;for(let a=0;a<r;++a){const o=e.tracks[a],l=o.ValueTypeName;if(l==="bool"||l==="string")continue;const c=i.tracks.find(function(g){return g.name===o.name&&g.ValueTypeName===l});if(c===void 0)continue;let h=0;const u=o.getValueSize();o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(h=u/3);let d=0;const f=c.getValueSize();c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(d=f/3);const p=o.times.length-1;let x;if(s<=o.times[0]){const g=h,m=u-h;x=ne.arraySlice(o.values,g,m)}else if(s>=o.times[p]){const g=p*u+h,m=g+u-h;x=ne.arraySlice(o.values,g,m)}else{const g=o.createInterpolant(),m=h,E=u-h;g.evaluate(s),x=ne.arraySlice(g.resultBuffer,m,E)}l==="quaternion"&&new Ae().fromArray(x).normalize().conjugate().toArray(x);const y=c.times.length;for(let g=0;g<y;++g){const m=g*f+d;if(l==="quaternion")Ae.multiplyQuaternionsFlat(c.values,m,x,0,c.values,m);else{const E=f-d*2;for(let w=0;w<E;++w)c.values[m+w]-=x[w]}}}return i.blendMode=dd,i}};function si(i,t,e,n){this.parameterPositions=i,this._cachedIndex=0,this.resultBuffer=n!==void 0?n:new t.constructor(e),this.sampleValues=t,this.valueSize=e}Object.assign(si.prototype,{evaluate:function(i){const t=this.parameterPositions;let e=this._cachedIndex,n=t[e],r=t[e-1];t:{e:{let s;i:{n:if(!(i<n)){for(let a=e+2;;){if(n===void 0){if(i<r)break n;return e=t.length,this._cachedIndex=e,this.afterEnd_(e-1,i,r)}if(e===a)break;if(r=n,n=t[++e],i<n)break e}s=t.length;break i}if(!(i>=r)){const a=t[1];i<a&&(e=2,r=a);for(let o=e-2;;){if(r===void 0)return this._cachedIndex=0,this.beforeStart_(0,i,n);if(e===o)break;if(n=r,r=t[--e-1],i>=r)break e}s=e,e=0;break i}break t}for(;e<s;){const a=e+s>>>1;i<t[a]?s=a:e=a+1}if(n=t[e],r=t[e-1],r===void 0)return this._cachedIndex=0,this.beforeStart_(0,i,n);if(n===void 0)return e=t.length,this._cachedIndex=e,this.afterEnd_(e-1,r,i)}this._cachedIndex=e,this.intervalChanged_(e,r,n)}return this.interpolate_(e,r,i,n)},settings:null,DefaultSettings_:{},getSettings_:function(){return this.settings||this.DefaultSettings_},copySampleValue_:function(i){const t=this.resultBuffer,e=this.sampleValues,n=this.valueSize,r=i*n;for(let s=0;s!==n;++s)t[s]=e[r+s];return t},interpolate_:function(){throw new Error("call to abstract method")},intervalChanged_:function(){}});Object.assign(si.prototype,{beforeStart_:si.prototype.copySampleValue_,afterEnd_:si.prototype.copySampleValue_});function Hc(i,t,e,n){si.call(this,i,t,e,n),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0}Hc.prototype=Object.assign(Object.create(si.prototype),{constructor:Hc,DefaultSettings_:{endingStart:dr,endingEnd:dr},intervalChanged_:function(i,t,e){const n=this.parameterPositions;let r=i-2,s=i+1,a=n[r],o=n[s];if(a===void 0)switch(this.getSettings_().endingStart){case fr:r=i,a=2*t-e;break;case Xa:r=n.length-2,a=t+n[r]-n[r+1];break;default:r=i,a=e}if(o===void 0)switch(this.getSettings_().endingEnd){case fr:s=i,o=2*e-t;break;case Xa:s=1,o=e+n[1]-n[0];break;default:s=i-1,o=t}const l=(e-t)*.5,c=this.valueSize;this._weightPrev=l/(t-a),this._weightNext=l/(o-e),this._offsetPrev=r*c,this._offsetNext=s*c},interpolate_:function(i,t,e,n){const r=this.resultBuffer,s=this.sampleValues,a=this.valueSize,o=i*a,l=o-a,c=this._offsetPrev,h=this._offsetNext,u=this._weightPrev,d=this._weightNext,f=(e-t)/(n-t),p=f*f,x=p*f,y=-u*x+2*u*p-u*f,g=(1+u)*x+(-1.5-2*u)*p+(-.5+u)*f+1,m=(-1-d)*x+(1.5+d)*p+.5*f,E=d*x-d*p;for(let w=0;w!==a;++w)r[w]=y*s[c+w]+g*s[l+w]+m*s[o+w]+E*s[h+w];return r}});function To(i,t,e,n){si.call(this,i,t,e,n)}To.prototype=Object.assign(Object.create(si.prototype),{constructor:To,interpolate_:function(i,t,e,n){const r=this.resultBuffer,s=this.sampleValues,a=this.valueSize,o=i*a,l=o-a,c=(e-t)/(n-t),h=1-c;for(let u=0;u!==a;++u)r[u]=s[l+u]*h+s[o+u]*c;return r}});function Gc(i,t,e,n){si.call(this,i,t,e,n)}Gc.prototype=Object.assign(Object.create(si.prototype),{constructor:Gc,interpolate_:function(i){return this.copySampleValue_(i-1)}});class Pi{constructor(t,e,n,r){if(t===void 0)throw new Error("THREE.KeyframeTrack: track name is undefined");if(e===void 0||e.length===0)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+t);this.name=t,this.times=ne.convertArray(e,this.TimeBufferType),this.values=ne.convertArray(n,this.ValueBufferType),this.setInterpolation(r||this.DefaultInterpolation)}static toJSON(t){const e=t.constructor;let n;if(e.toJSON!==this.toJSON)n=e.toJSON(t);else{n={name:t.name,times:ne.convertArray(t.times,Array),values:ne.convertArray(t.values,Array)};const r=t.getInterpolation();r!==t.DefaultInterpolation&&(n.interpolation=r)}return n.type=t.ValueTypeName,n}InterpolantFactoryMethodDiscrete(t){return new Gc(this.times,this.values,this.getValueSize(),t)}InterpolantFactoryMethodLinear(t){return new To(this.times,this.values,this.getValueSize(),t)}InterpolantFactoryMethodSmooth(t){return new Hc(this.times,this.values,this.getValueSize(),t)}setInterpolation(t){let e;switch(t){case Wa:e=this.InterpolantFactoryMethodDiscrete;break;case $a:e=this.InterpolantFactoryMethodLinear;break;case jl:e=this.InterpolantFactoryMethodSmooth;break}if(e===void 0){const n="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(this.createInterpolant===void 0)if(t!==this.DefaultInterpolation)this.setInterpolation(this.DefaultInterpolation);else throw new Error(n);return console.warn("THREE.KeyframeTrack:",n),this}return this.createInterpolant=e,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return Wa;case this.InterpolantFactoryMethodLinear:return $a;case this.InterpolantFactoryMethodSmooth:return jl}}getValueSize(){return this.values.length/this.times.length}shift(t){if(t!==0){const e=this.times;for(let n=0,r=e.length;n!==r;++n)e[n]+=t}return this}scale(t){if(t!==1){const e=this.times;for(let n=0,r=e.length;n!==r;++n)e[n]*=t}return this}trim(t,e){const n=this.times,r=n.length;let s=0,a=r-1;for(;s!==r&&n[s]<t;)++s;for(;a!==-1&&n[a]>e;)--a;if(++a,s!==0||a!==r){s>=a&&(a=Math.max(a,1),s=a-1);const o=this.getValueSize();this.times=ne.arraySlice(n,s,a),this.values=ne.arraySlice(this.values,s*o,a*o)}return this}validate(){let t=!0;const e=this.getValueSize();e-Math.floor(e)!=0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),t=!1);const n=this.times,r=this.values,s=n.length;s===0&&(console.error("THREE.KeyframeTrack: Track is empty.",this),t=!1);let a=null;for(let o=0;o!==s;o++){const l=n[o];if(typeof l=="number"&&isNaN(l)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,o,l),t=!1;break}if(a!==null&&a>l){console.error("THREE.KeyframeTrack: Out of order keys.",this,o,l,a),t=!1;break}a=l}if(r!==void 0&&ne.isTypedArray(r))for(let o=0,l=r.length;o!==l;++o){const c=r[o];if(isNaN(c)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,o,c),t=!1;break}}return t}optimize(){const t=ne.arraySlice(this.times),e=ne.arraySlice(this.values),n=this.getValueSize(),r=this.getInterpolation()===jl,s=t.length-1;let a=1;for(let o=1;o<s;++o){let l=!1;const c=t[o],h=t[o+1];if(c!==h&&(o!==1||c!==t[0]))if(r)l=!0;else{const u=o*n,d=u-n,f=u+n;for(let p=0;p!==n;++p){const x=e[u+p];if(x!==e[d+p]||x!==e[f+p]){l=!0;break}}}if(l){if(o!==a){t[a]=t[o];const u=o*n,d=a*n;for(let f=0;f!==n;++f)e[d+f]=e[u+f]}++a}}if(s>0){t[a]=t[s];for(let o=s*n,l=a*n,c=0;c!==n;++c)e[l+c]=e[o+c];++a}return a!==t.length?(this.times=ne.arraySlice(t,0,a),this.values=ne.arraySlice(e,0,a*n)):(this.times=t,this.values=e),this}clone(){const t=ne.arraySlice(this.times,0),e=ne.arraySlice(this.values,0),n=this.constructor,r=new n(this.name,t,e);return r.createInterpolant=this.createInterpolant,r}}Pi.prototype.TimeBufferType=Float32Array;Pi.prototype.ValueBufferType=Float32Array;Pi.prototype.DefaultInterpolation=$a;class Hr extends Pi{}Hr.prototype.ValueTypeName="bool";Hr.prototype.ValueBufferType=Array;Hr.prototype.DefaultInterpolation=Wa;Hr.prototype.InterpolantFactoryMethodLinear=void 0;Hr.prototype.InterpolantFactoryMethodSmooth=void 0;class zf extends Pi{}zf.prototype.ValueTypeName="color";class Lo extends Pi{}Lo.prototype.ValueTypeName="number";function kc(i,t,e,n){si.call(this,i,t,e,n)}kc.prototype=Object.assign(Object.create(si.prototype),{constructor:kc,interpolate_:function(i,t,e,n){const r=this.resultBuffer,s=this.sampleValues,a=this.valueSize,o=(e-t)/(n-t);let l=i*a;for(let c=l+a;l!==c;l+=4)Ae.slerpFlat(r,0,s,l-a,s,l,o);return r}});class sa extends Pi{InterpolantFactoryMethodLinear(t){return new kc(this.times,this.values,this.getValueSize(),t)}}sa.prototype.ValueTypeName="quaternion";sa.prototype.DefaultInterpolation=$a;sa.prototype.InterpolantFactoryMethodSmooth=void 0;class Gr extends Pi{}Gr.prototype.ValueTypeName="string";Gr.prototype.ValueBufferType=Array;Gr.prototype.DefaultInterpolation=Wa;Gr.prototype.InterpolantFactoryMethodLinear=void 0;Gr.prototype.InterpolantFactoryMethodSmooth=void 0;class Ro extends Pi{}Ro.prototype.ValueTypeName="vector";class Nf{constructor(t,e=-1,n,r=Zl){this.name=t,this.tracks=n,this.duration=e,this.blendMode=r,this.uuid=Ot.generateUUID(),this.duration<0&&this.resetDuration()}static parse(t){const e=[],n=t.tracks,r=1/(t.fps||1);for(let a=0,o=n.length;a!==o;++a)e.push(cb(n[a]).scale(r));const s=new this(t.name,t.duration,e,t.blendMode);return s.uuid=t.uuid,s}static toJSON(t){const e=[],n=t.tracks,r={name:t.name,duration:t.duration,tracks:e,uuid:t.uuid,blendMode:t.blendMode};for(let s=0,a=n.length;s!==a;++s)e.push(Pi.toJSON(n[s]));return r}static CreateFromMorphTargetSequence(t,e,n,r){const s=e.length,a=[];for(let o=0;o<s;o++){let l=[],c=[];l.push((o+s-1)%s,o,(o+1)%s),c.push(0,1,0);const h=ne.getKeyframeOrder(l);l=ne.sortedArray(l,1,h),c=ne.sortedArray(c,1,h),!r&&l[0]===0&&(l.push(s),c.push(c[0])),a.push(new Lo(".morphTargetInfluences["+e[o].name+"]",l,c).scale(1/n))}return new this(t,-1,a)}static findByName(t,e){let n=t;if(!Array.isArray(t)){const r=t;n=r.geometry&&r.geometry.animations||r.animations}for(let r=0;r<n.length;r++)if(n[r].name===e)return n[r];return null}static CreateClipsFromMorphTargetSequences(t,e,n){const r={},s=/^([\w-]*?)([\d]+)$/;for(let o=0,l=t.length;o<l;o++){const c=t[o],h=c.name.match(s);if(h&&h.length>1){const u=h[1];let d=r[u];d||(r[u]=d=[]),d.push(c)}}const a=[];for(const o in r)a.push(this.CreateFromMorphTargetSequence(o,r[o],e,n));return a}static parseAnimation(t,e){if(!t)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const n=function(u,d,f,p,x){if(f.length!==0){const y=[],g=[];ne.flattenJSON(f,y,g,p),y.length!==0&&x.push(new u(d,y,g))}},r=[],s=t.name||"default",a=t.fps||30,o=t.blendMode;let l=t.length||-1;const c=t.hierarchy||[];for(let u=0;u<c.length;u++){const d=c[u].keys;if(!(!d||d.length===0))if(d[0].morphTargets){const f={};let p;for(p=0;p<d.length;p++)if(d[p].morphTargets)for(let x=0;x<d[p].morphTargets.length;x++)f[d[p].morphTargets[x]]=-1;for(const x in f){const y=[],g=[];for(let m=0;m!==d[p].morphTargets.length;++m){const E=d[p];y.push(E.time),g.push(E.morphTarget===x?1:0)}r.push(new Lo(".morphTargetInfluence["+x+"]",y,g))}l=f.length*(a||1)}else{const f=".bones["+e[u].name+"]";n(Ro,f+".position",d,"pos",r),n(sa,f+".quaternion",d,"rot",r),n(Ro,f+".scale",d,"scl",r)}}return r.length===0?null:new this(s,l,r,o)}resetDuration(){const t=this.tracks;let e=0;for(let n=0,r=t.length;n!==r;++n){const s=this.tracks[n];e=Math.max(e,s.times[s.times.length-1])}return this.duration=e,this}trim(){for(let t=0;t<this.tracks.length;t++)this.tracks[t].trim(0,this.duration);return this}validate(){let t=!0;for(let e=0;e<this.tracks.length;e++)t=t&&this.tracks[e].validate();return t}optimize(){for(let t=0;t<this.tracks.length;t++)this.tracks[t].optimize();return this}clone(){const t=[];for(let e=0;e<this.tracks.length;e++)t.push(this.tracks[e].clone());return new this.constructor(this.name,this.duration,t,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}}function lb(i){switch(i.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return Lo;case"vector":case"vector2":case"vector3":case"vector4":return Ro;case"color":return zf;case"quaternion":return sa;case"bool":case"boolean":return Hr;case"string":return Gr}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+i)}function cb(i){if(i.type===void 0)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const t=lb(i.type);if(i.times===void 0){const e=[],n=[];ne.flattenJSON(i.keys,e,n,"value"),i.times=e,i.values=n}return t.parse!==void 0?t.parse(i):new t(i.name,i.times,i.values,i.interpolation)}const kr={enabled:!1,files:{},add:function(i,t){this.enabled!==!1&&(this.files[i]=t)},get:function(i){if(this.enabled!==!1)return this.files[i]},remove:function(i){delete this.files[i]},clear:function(){this.files={}}};function hb(i,t,e){const n=this;let r=!1,s=0,a=0,o;const l=[];this.onStart=void 0,this.onLoad=i,this.onProgress=t,this.onError=e,this.itemStart=function(c){a++,r===!1&&n.onStart!==void 0&&n.onStart(c,s,a),r=!0},this.itemEnd=function(c){s++,n.onProgress!==void 0&&n.onProgress(c,s,a),s===a&&(r=!1,n.onLoad!==void 0&&n.onLoad())},this.itemError=function(c){n.onError!==void 0&&n.onError(c)},this.resolveURL=function(c){return o?o(c):c},this.setURLModifier=function(c){return o=c,this},this.addHandler=function(c,h){return l.push(c,h),this},this.removeHandler=function(c){const h=l.indexOf(c);return h!==-1&&l.splice(h,2),this},this.getHandler=function(c){for(let h=0,u=l.length;h<u;h+=2){const d=l[h],f=l[h+1];if(d.global&&(d.lastIndex=0),d.test(c))return f}return null}}const ub=new hb;function Fe(i){this.manager=i!==void 0?i:ub,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}Object.assign(Fe.prototype,{load:function(){},loadAsync:function(i,t){const e=this;return new Promise(function(n,r){e.load(i,n,t,r)})},parse:function(){},setCrossOrigin:function(i){return this.crossOrigin=i,this},setWithCredentials:function(i){return this.withCredentials=i,this},setPath:function(i){return this.path=i,this},setResourcePath:function(i){return this.resourcePath=i,this},setRequestHeader:function(i){return this.requestHeader=i,this}});const pi={};function aa(i){Fe.call(this,i)}aa.prototype=Object.assign(Object.create(Fe.prototype),{constructor:aa,load:function(i,t,e,n){i===void 0&&(i=""),this.path!==void 0&&(i=this.path+i),i=this.manager.resolveURL(i);const r=this,s=kr.get(i);if(s!==void 0)return r.manager.itemStart(i),setTimeout(function(){t&&t(s),r.manager.itemEnd(i)},0),s;if(pi[i]!==void 0){pi[i].push({onLoad:t,onProgress:e,onError:n});return}const a=/^data:(.*?)(;base64)?,(.*)$/,o=i.match(a);let l;if(o){const c=o[1],h=!!o[2];let u=o[3];u=decodeURIComponent(u),h&&(u=atob(u));try{let d;const f=(this.responseType||"").toLowerCase();switch(f){case"arraybuffer":case"blob":const p=new Uint8Array(u.length);for(let y=0;y<u.length;y++)p[y]=u.charCodeAt(y);f==="blob"?d=new Blob([p.buffer],{type:c}):d=p.buffer;break;case"document":d=new DOMParser().parseFromString(u,c);break;case"json":d=JSON.parse(u);break;default:d=u;break}setTimeout(function(){t&&t(d),r.manager.itemEnd(i)},0)}catch(d){setTimeout(function(){n&&n(d),r.manager.itemError(i),r.manager.itemEnd(i)},0)}}else{pi[i]=[],pi[i].push({onLoad:t,onProgress:e,onError:n}),l=new XMLHttpRequest,l.open("GET",i,!0),l.addEventListener("load",function(c){const h=this.response,u=pi[i];if(delete pi[i],this.status===200||this.status===0){this.status===0&&console.warn("THREE.FileLoader: HTTP Status 0 received."),kr.add(i,h);for(let d=0,f=u.length;d<f;d++){const p=u[d];p.onLoad&&p.onLoad(h)}r.manager.itemEnd(i)}else{for(let d=0,f=u.length;d<f;d++){const p=u[d];p.onError&&p.onError(c)}r.manager.itemError(i),r.manager.itemEnd(i)}},!1),l.addEventListener("progress",function(c){const h=pi[i];for(let u=0,d=h.length;u<d;u++){const f=h[u];f.onProgress&&f.onProgress(c)}},!1),l.addEventListener("error",function(c){const h=pi[i];delete pi[i];for(let u=0,d=h.length;u<d;u++){const f=h[u];f.onError&&f.onError(c)}r.manager.itemError(i),r.manager.itemEnd(i)},!1),l.addEventListener("abort",function(c){const h=pi[i];delete pi[i];for(let u=0,d=h.length;u<d;u++){const f=h[u];f.onError&&f.onError(c)}r.manager.itemError(i),r.manager.itemEnd(i)},!1),this.responseType!==void 0&&(l.responseType=this.responseType),this.withCredentials!==void 0&&(l.withCredentials=this.withCredentials),l.overrideMimeType&&l.overrideMimeType(this.mimeType!==void 0?this.mimeType:"text/plain");for(const c in this.requestHeader)l.setRequestHeader(c,this.requestHeader[c]);l.send(null)}return r.manager.itemStart(i),l},setResponseType:function(i){return this.responseType=i,this},setMimeType:function(i){return this.mimeType=i,this}});function Bf(i){Fe.call(this,i)}Bf.prototype=Object.assign(Object.create(Fe.prototype),{constructor:Bf,load:function(i,t,e,n){const r=this,s=[],a=new Lf,o=new aa(this.manager);o.setPath(this.path),o.setResponseType("arraybuffer"),o.setRequestHeader(this.requestHeader),o.setWithCredentials(r.withCredentials);let l=0;function c(h){o.load(i[h],function(u){const d=r.parse(u,!0);s[h]={width:d.width,height:d.height,format:d.format,mipmaps:d.mipmaps},l+=1,l===6&&(d.mipmapCount===1&&(a.minFilter=be),a.image=s,a.format=d.format,a.needsUpdate=!0,t&&t(a))},e,n)}if(Array.isArray(i))for(let h=0,u=i.length;h<u;++h)c(h);else o.load(i,function(h){const u=r.parse(h,!0);if(u.isCubemap){const d=u.mipmaps.length/u.mipmapCount;for(let f=0;f<d;f++){s[f]={mipmaps:[]};for(let p=0;p<u.mipmapCount;p++)s[f].mipmaps.push(u.mipmaps[f*u.mipmapCount+p]),s[f].format=u.format,s[f].width=u.width,s[f].height=u.height}a.image=s}else a.image.width=u.width,a.image.height=u.height,a.mipmaps=u.mipmaps;u.mipmapCount===1&&(a.minFilter=be),a.format=u.format,a.needsUpdate=!0,t&&t(a)},e,n);return a}});class Of extends Fe{constructor(t){super(t)}load(t,e,n,r){this.path!==void 0&&(t=this.path+t),t=this.manager.resolveURL(t);const s=this,a=kr.get(t);if(a!==void 0)return s.manager.itemStart(t),setTimeout(function(){e&&e(a),s.manager.itemEnd(t)},0),a;const o=document.createElementNS("http://www.w3.org/1999/xhtml","img");function l(){o.removeEventListener("load",l,!1),o.removeEventListener("error",c,!1),kr.add(t,this),e&&e(this),s.manager.itemEnd(t)}function c(h){o.removeEventListener("load",l,!1),o.removeEventListener("error",c,!1),r&&r(h),s.manager.itemError(t),s.manager.itemEnd(t)}return o.addEventListener("load",l,!1),o.addEventListener("error",c,!1),t.substr(0,5)!=="data:"&&this.crossOrigin!==void 0&&(o.crossOrigin=this.crossOrigin),s.manager.itemStart(t),o.src=t,o}}class db extends Fe{constructor(t){super(t)}load(t,e,n,r){const s=new uo,a=new Of(this.manager);a.setCrossOrigin(this.crossOrigin),a.setPath(this.path);let o=0;function l(c){a.load(t[c],function(h){s.images[c]=h,o++,o===6&&(s.needsUpdate=!0,e&&e(s))},void 0,r)}for(let c=0;c<t.length;++c)l(c);return s}}function Uf(i){Fe.call(this,i)}Uf.prototype=Object.assign(Object.create(Fe.prototype),{constructor:Uf,load:function(i,t,e,n){const r=this,s=new Cc,a=new aa(this.manager);return a.setResponseType("arraybuffer"),a.setRequestHeader(this.requestHeader),a.setPath(this.path),a.setWithCredentials(r.withCredentials),a.load(i,function(o){const l=r.parse(o);!l||(l.image!==void 0?s.image=l.image:l.data!==void 0&&(s.image.width=l.width,s.image.height=l.height,s.image.data=l.data),s.wrapS=l.wrapS!==void 0?l.wrapS:Xe,s.wrapT=l.wrapT!==void 0?l.wrapT:Xe,s.magFilter=l.magFilter!==void 0?l.magFilter:be,s.minFilter=l.minFilter!==void 0?l.minFilter:be,s.anisotropy=l.anisotropy!==void 0?l.anisotropy:1,l.encoding!==void 0&&(s.encoding=l.encoding),l.flipY!==void 0&&(s.flipY=l.flipY),l.format!==void 0&&(s.format=l.format),l.type!==void 0&&(s.type=l.type),l.mipmaps!==void 0&&(s.mipmaps=l.mipmaps,s.minFilter=Ha),l.mipmapCount===1&&(s.minFilter=be),l.generateMipmaps!==void 0&&(s.generateMipmaps=l.generateMipmaps),s.needsUpdate=!0,t&&t(s,l))},e,n),s}});function Vc(i){Fe.call(this,i)}Vc.prototype=Object.assign(Object.create(Fe.prototype),{constructor:Vc,load:function(i,t,e,n){const r=new Ee,s=new Of(this.manager);return s.setCrossOrigin(this.crossOrigin),s.setPath(this.path),s.load(i,function(a){r.image=a;const o=i.search(/\.jpe?g($|\?)/i)>0||i.search(/^data\:image\/jpeg/)===0;r.format=o?Wn:hi,r.needsUpdate=!0,t!==void 0&&t(r)},e,n),r}});function $e(){this.type="Curve",this.arcLengthDivisions=200}Object.assign($e.prototype,{getPoint:function(){return console.warn("THREE.Curve: .getPoint() not implemented."),null},getPointAt:function(i,t){const e=this.getUtoTmapping(i);return this.getPoint(e,t)},getPoints:function(i=5){const t=[];for(let e=0;e<=i;e++)t.push(this.getPoint(e/i));return t},getSpacedPoints:function(i=5){const t=[];for(let e=0;e<=i;e++)t.push(this.getPointAt(e/i));return t},getLength:function(){const i=this.getLengths();return i[i.length-1]},getLengths:function(i){if(i===void 0&&(i=this.arcLengthDivisions),this.cacheArcLengths&&this.cacheArcLengths.length===i+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const t=[];let e,n=this.getPoint(0),r=0;t.push(0);for(let s=1;s<=i;s++)e=this.getPoint(s/i),r+=e.distanceTo(n),t.push(r),n=e;return this.cacheArcLengths=t,t},updateArcLengths:function(){this.needsUpdate=!0,this.getLengths()},getUtoTmapping:function(i,t){const e=this.getLengths();let n=0;const r=e.length;let s;t?s=t:s=i*e[r-1];let a=0,o=r-1,l;for(;a<=o;)if(n=Math.floor(a+(o-a)/2),l=e[n]-s,l<0)a=n+1;else if(l>0)o=n-1;else{o=n;break}if(n=o,e[n]===s)return n/(r-1);const c=e[n],u=e[n+1]-c,d=(s-c)/u;return(n+d)/(r-1)},getTangent:function(i,t){const e=1e-4;let n=i-e,r=i+e;n<0&&(n=0),r>1&&(r=1);const s=this.getPoint(n),a=this.getPoint(r),o=t||(s.isVector2?new lt:new U);return o.copy(a).sub(s).normalize(),o},getTangentAt:function(i,t){const e=this.getUtoTmapping(i);return this.getTangent(e,t)},computeFrenetFrames:function(i,t){const e=new U,n=[],r=[],s=[],a=new U,o=new It;for(let d=0;d<=i;d++){const f=d/i;n[d]=this.getTangentAt(f,new U),n[d].normalize()}r[0]=new U,s[0]=new U;let l=Number.MAX_VALUE;const c=Math.abs(n[0].x),h=Math.abs(n[0].y),u=Math.abs(n[0].z);c<=l&&(l=c,e.set(1,0,0)),h<=l&&(l=h,e.set(0,1,0)),u<=l&&e.set(0,0,1),a.crossVectors(n[0],e).normalize(),r[0].crossVectors(n[0],a),s[0].crossVectors(n[0],r[0]);for(let d=1;d<=i;d++){if(r[d]=r[d-1].clone(),s[d]=s[d-1].clone(),a.crossVectors(n[d-1],n[d]),a.length()>Number.EPSILON){a.normalize();const f=Math.acos(Ot.clamp(n[d-1].dot(n[d]),-1,1));r[d].applyMatrix4(o.makeRotationAxis(a,f))}s[d].crossVectors(n[d],r[d])}if(t===!0){let d=Math.acos(Ot.clamp(r[0].dot(r[i]),-1,1));d/=i,n[0].dot(a.crossVectors(r[0],r[i]))>0&&(d=-d);for(let f=1;f<=i;f++)r[f].applyMatrix4(o.makeRotationAxis(n[f],d*f)),s[f].crossVectors(n[f],r[f])}return{tangents:n,normals:r,binormals:s}},clone:function(){return new this.constructor().copy(this)},copy:function(i){return this.arcLengthDivisions=i.arcLengthDivisions,this},toJSON:function(){const i={metadata:{version:4.5,type:"Curve",generator:"Curve.toJSON"}};return i.arcLengthDivisions=this.arcLengthDivisions,i.type=this.type,i},fromJSON:function(i){return this.arcLengthDivisions=i.arcLengthDivisions,this}});class Co extends $e{constructor(t=0,e=0,n=1,r=1,s=0,a=Math.PI*2,o=!1,l=0){super();this.type="EllipseCurve",this.aX=t,this.aY=e,this.xRadius=n,this.yRadius=r,this.aStartAngle=s,this.aEndAngle=a,this.aClockwise=o,this.aRotation=l}getPoint(t,e){const n=e||new lt,r=Math.PI*2;let s=this.aEndAngle-this.aStartAngle;const a=Math.abs(s)<Number.EPSILON;for(;s<0;)s+=r;for(;s>r;)s-=r;s<Number.EPSILON&&(a?s=0:s=r),this.aClockwise===!0&&!a&&(s===r?s=-r:s=s-r);const o=this.aStartAngle+t*s;let l=this.aX+this.xRadius*Math.cos(o),c=this.aY+this.yRadius*Math.sin(o);if(this.aRotation!==0){const h=Math.cos(this.aRotation),u=Math.sin(this.aRotation),d=l-this.aX,f=c-this.aY;l=d*h-f*u+this.aX,c=d*u+f*h+this.aY}return n.set(l,c)}copy(t){return super.copy(t),this.aX=t.aX,this.aY=t.aY,this.xRadius=t.xRadius,this.yRadius=t.yRadius,this.aStartAngle=t.aStartAngle,this.aEndAngle=t.aEndAngle,this.aClockwise=t.aClockwise,this.aRotation=t.aRotation,this}toJSON(){const t=super.toJSON();return t.aX=this.aX,t.aY=this.aY,t.xRadius=this.xRadius,t.yRadius=this.yRadius,t.aStartAngle=this.aStartAngle,t.aEndAngle=this.aEndAngle,t.aClockwise=this.aClockwise,t.aRotation=this.aRotation,t}fromJSON(t){return super.fromJSON(t),this.aX=t.aX,this.aY=t.aY,this.xRadius=t.xRadius,this.yRadius=t.yRadius,this.aStartAngle=t.aStartAngle,this.aEndAngle=t.aEndAngle,this.aClockwise=t.aClockwise,this.aRotation=t.aRotation,this}}Co.prototype.isEllipseCurve=!0;class Hf extends Co{constructor(t,e,n,r,s,a){super(t,e,n,n,r,s,a);this.type="ArcCurve"}}Hf.prototype.isArcCurve=!0;function Wc(){let i=0,t=0,e=0,n=0;function r(s,a,o,l){i=s,t=o,e=-3*s+3*a-2*o-l,n=2*s-2*a+o+l}return{initCatmullRom:function(s,a,o,l,c){r(a,o,c*(o-s),c*(l-a))},initNonuniformCatmullRom:function(s,a,o,l,c,h,u){let d=(a-s)/c-(o-s)/(c+h)+(o-a)/h,f=(o-a)/h-(l-a)/(h+u)+(l-o)/u;d*=h,f*=h,r(a,o,d,f)},calc:function(s){const a=s*s,o=a*s;return i+t*s+e*a+n*o}}}const Po=new U,$c=new Wc,Xc=new Wc,qc=new Wc;class Gf extends $e{constructor(t=[],e=!1,n="centripetal",r=.5){super();this.type="CatmullRomCurve3",this.points=t,this.closed=e,this.curveType=n,this.tension=r}getPoint(t,e=new U){const n=e,r=this.points,s=r.length,a=(s-(this.closed?0:1))*t;let o=Math.floor(a),l=a-o;this.closed?o+=o>0?0:(Math.floor(Math.abs(o)/s)+1)*s:l===0&&o===s-1&&(o=s-2,l=1);let c,h;this.closed||o>0?c=r[(o-1)%s]:(Po.subVectors(r[0],r[1]).add(r[0]),c=Po);const u=r[o%s],d=r[(o+1)%s];if(this.closed||o+2<s?h=r[(o+2)%s]:(Po.subVectors(r[s-1],r[s-2]).add(r[s-1]),h=Po),this.curveType==="centripetal"||this.curveType==="chordal"){const f=this.curveType==="chordal"?.5:.25;let p=Math.pow(c.distanceToSquared(u),f),x=Math.pow(u.distanceToSquared(d),f),y=Math.pow(d.distanceToSquared(h),f);x<1e-4&&(x=1),p<1e-4&&(p=x),y<1e-4&&(y=x),$c.initNonuniformCatmullRom(c.x,u.x,d.x,h.x,p,x,y),Xc.initNonuniformCatmullRom(c.y,u.y,d.y,h.y,p,x,y),qc.initNonuniformCatmullRom(c.z,u.z,d.z,h.z,p,x,y)}else this.curveType==="catmullrom"&&($c.initCatmullRom(c.x,u.x,d.x,h.x,this.tension),Xc.initCatmullRom(c.y,u.y,d.y,h.y,this.tension),qc.initCatmullRom(c.z,u.z,d.z,h.z,this.tension));return n.set($c.calc(l),Xc.calc(l),qc.calc(l)),n}copy(t){super.copy(t),this.points=[];for(let e=0,n=t.points.length;e<n;e++){const r=t.points[e];this.points.push(r.clone())}return this.closed=t.closed,this.curveType=t.curveType,this.tension=t.tension,this}toJSON(){const t=super.toJSON();t.points=[];for(let e=0,n=this.points.length;e<n;e++){const r=this.points[e];t.points.push(r.toArray())}return t.closed=this.closed,t.curveType=this.curveType,t.tension=this.tension,t}fromJSON(t){super.fromJSON(t),this.points=[];for(let e=0,n=t.points.length;e<n;e++){const r=t.points[e];this.points.push(new U().fromArray(r))}return this.closed=t.closed,this.curveType=t.curveType,this.tension=t.tension,this}}Gf.prototype.isCatmullRomCurve3=!0;function kf(i,t,e,n,r){const s=(n-t)*.5,a=(r-e)*.5,o=i*i,l=i*o;return(2*e-2*n+s+a)*l+(-3*e+3*n-2*s-a)*o+s*i+e}function fb(i,t){const e=1-i;return e*e*t}function pb(i,t){return 2*(1-i)*i*t}function mb(i,t){return i*i*t}function oa(i,t,e,n){return fb(i,t)+pb(i,e)+mb(i,n)}function gb(i,t){const e=1-i;return e*e*e*t}function xb(i,t){const e=1-i;return 3*e*e*i*t}function yb(i,t){return 3*(1-i)*i*i*t}function _b(i,t){return i*i*i*t}function la(i,t,e,n,r){return gb(i,t)+xb(i,e)+yb(i,n)+_b(i,r)}class Yc extends $e{constructor(t=new lt,e=new lt,n=new lt,r=new lt){super();this.type="CubicBezierCurve",this.v0=t,this.v1=e,this.v2=n,this.v3=r}getPoint(t,e=new lt){const n=e,r=this.v0,s=this.v1,a=this.v2,o=this.v3;return n.set(la(t,r.x,s.x,a.x,o.x),la(t,r.y,s.y,a.y,o.y)),n}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this.v3.copy(t.v3),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t.v3=this.v3.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this.v3.fromArray(t.v3),this}}Yc.prototype.isCubicBezierCurve=!0;class Vf extends $e{constructor(t=new U,e=new U,n=new U,r=new U){super();this.type="CubicBezierCurve3",this.v0=t,this.v1=e,this.v2=n,this.v3=r}getPoint(t,e=new U){const n=e,r=this.v0,s=this.v1,a=this.v2,o=this.v3;return n.set(la(t,r.x,s.x,a.x,o.x),la(t,r.y,s.y,a.y,o.y),la(t,r.z,s.z,a.z,o.z)),n}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this.v3.copy(t.v3),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t.v3=this.v3.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this.v3.fromArray(t.v3),this}}Vf.prototype.isCubicBezierCurve3=!0;class Do extends $e{constructor(t=new lt,e=new lt){super();this.type="LineCurve",this.v1=t,this.v2=e}getPoint(t,e=new lt){const n=e;return t===1?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(t).add(this.v1)),n}getPointAt(t,e){return this.getPoint(t,e)}getTangent(t,e){const n=e||new lt;return n.copy(this.v2).sub(this.v1).normalize(),n}copy(t){return super.copy(t),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}Do.prototype.isLineCurve=!0;class vb extends $e{constructor(t=new U,e=new U){super();this.type="LineCurve3",this.isLineCurve3=!0,this.v1=t,this.v2=e}getPoint(t,e=new U){const n=e;return t===1?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(t).add(this.v1)),n}getPointAt(t,e){return this.getPoint(t,e)}copy(t){return super.copy(t),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}class jc extends $e{constructor(t=new lt,e=new lt,n=new lt){super();this.type="QuadraticBezierCurve",this.v0=t,this.v1=e,this.v2=n}getPoint(t,e=new lt){const n=e,r=this.v0,s=this.v1,a=this.v2;return n.set(oa(t,r.x,s.x,a.x),oa(t,r.y,s.y,a.y)),n}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}jc.prototype.isQuadraticBezierCurve=!0;class Wf extends $e{constructor(t=new U,e=new U,n=new U){super();this.type="QuadraticBezierCurve3",this.v0=t,this.v1=e,this.v2=n}getPoint(t,e=new U){const n=e,r=this.v0,s=this.v1,a=this.v2;return n.set(oa(t,r.x,s.x,a.x),oa(t,r.y,s.y,a.y),oa(t,r.z,s.z,a.z)),n}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}Wf.prototype.isQuadraticBezierCurve3=!0;class Zc extends $e{constructor(t=[]){super();this.type="SplineCurve",this.points=t}getPoint(t,e=new lt){const n=e,r=this.points,s=(r.length-1)*t,a=Math.floor(s),o=s-a,l=r[a===0?a:a-1],c=r[a],h=r[a>r.length-2?r.length-1:a+1],u=r[a>r.length-3?r.length-1:a+2];return n.set(kf(o,l.x,c.x,h.x,u.x),kf(o,l.y,c.y,h.y,u.y)),n}copy(t){super.copy(t),this.points=[];for(let e=0,n=t.points.length;e<n;e++){const r=t.points[e];this.points.push(r.clone())}return this}toJSON(){const t=super.toJSON();t.points=[];for(let e=0,n=this.points.length;e<n;e++){const r=this.points[e];t.points.push(r.toArray())}return t}fromJSON(t){super.fromJSON(t),this.points=[];for(let e=0,n=t.points.length;e<n;e++){const r=t.points[e];this.points.push(new lt().fromArray(r))}return this}}Zc.prototype.isSplineCurve=!0;var Mb=Object.freeze({__proto__:null,ArcCurve:Hf,CatmullRomCurve3:Gf,CubicBezierCurve:Yc,CubicBezierCurve3:Vf,EllipseCurve:Co,LineCurve:Do,LineCurve3:vb,QuadraticBezierCurve:jc,QuadraticBezierCurve3:Wf,SplineCurve:Zc});class bb extends $e{constructor(){super();this.type="CurvePath",this.curves=[],this.autoClose=!1}add(t){this.curves.push(t)}closePath(){const t=this.curves[0].getPoint(0),e=this.curves[this.curves.length-1].getPoint(1);t.equals(e)||this.curves.push(new Do(e,t))}getPoint(t){const e=t*this.getLength(),n=this.getCurveLengths();let r=0;for(;r<n.length;){if(n[r]>=e){const s=n[r]-e,a=this.curves[r],o=a.getLength(),l=o===0?0:1-s/o;return a.getPointAt(l)}r++}return null}getLength(){const t=this.getCurveLengths();return t[t.length-1]}updateArcLengths(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()}getCurveLengths(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const t=[];let e=0;for(let n=0,r=this.curves.length;n<r;n++)e+=this.curves[n].getLength(),t.push(e);return this.cacheLengths=t,t}getSpacedPoints(t=40){const e=[];for(let n=0;n<=t;n++)e.push(this.getPoint(n/t));return this.autoClose&&e.push(e[0]),e}getPoints(t=12){const e=[];let n;for(let r=0,s=this.curves;r<s.length;r++){const a=s[r],o=a&&a.isEllipseCurve?t*2:a&&(a.isLineCurve||a.isLineCurve3)?1:a&&a.isSplineCurve?t*a.points.length:t,l=a.getPoints(o);for(let c=0;c<l.length;c++){const h=l[c];n&&n.equals(h)||(e.push(h),n=h)}}return this.autoClose&&e.length>1&&!e[e.length-1].equals(e[0])&&e.push(e[0]),e}copy(t){super.copy(t),this.curves=[];for(let e=0,n=t.curves.length;e<n;e++){const r=t.curves[e];this.curves.push(r.clone())}return this.autoClose=t.autoClose,this}toJSON(){const t=super.toJSON();t.autoClose=this.autoClose,t.curves=[];for(let e=0,n=this.curves.length;e<n;e++){const r=this.curves[e];t.curves.push(r.toJSON())}return t}fromJSON(t){super.fromJSON(t),this.autoClose=t.autoClose,this.curves=[];for(let e=0,n=t.curves.length;e<n;e++){const r=t.curves[e];this.curves.push(new Mb[r.type]().fromJSON(r))}return this}}class Jc extends bb{constructor(t){super();this.type="Path",this.currentPoint=new lt,t&&this.setFromPoints(t)}setFromPoints(t){this.moveTo(t[0].x,t[0].y);for(let e=1,n=t.length;e<n;e++)this.lineTo(t[e].x,t[e].y);return this}moveTo(t,e){return this.currentPoint.set(t,e),this}lineTo(t,e){const n=new Do(this.currentPoint.clone(),new lt(t,e));return this.curves.push(n),this.currentPoint.set(t,e),this}quadraticCurveTo(t,e,n,r){const s=new jc(this.currentPoint.clone(),new lt(t,e),new lt(n,r));return this.curves.push(s),this.currentPoint.set(n,r),this}bezierCurveTo(t,e,n,r,s,a){const o=new Yc(this.currentPoint.clone(),new lt(t,e),new lt(n,r),new lt(s,a));return this.curves.push(o),this.currentPoint.set(s,a),this}splineThru(t){const e=[this.currentPoint.clone()].concat(t),n=new Zc(e);return this.curves.push(n),this.currentPoint.copy(t[t.length-1]),this}arc(t,e,n,r,s,a){const o=this.currentPoint.x,l=this.currentPoint.y;return this.absarc(t+o,e+l,n,r,s,a),this}absarc(t,e,n,r,s,a){return this.absellipse(t,e,n,n,r,s,a),this}ellipse(t,e,n,r,s,a,o,l){const c=this.currentPoint.x,h=this.currentPoint.y;return this.absellipse(t+c,e+h,n,r,s,a,o,l),this}absellipse(t,e,n,r,s,a,o,l){const c=new Co(t,e,n,r,s,a,o,l);if(this.curves.length>0){const u=c.getPoint(0);u.equals(this.currentPoint)||this.lineTo(u.x,u.y)}this.curves.push(c);const h=c.getPoint(1);return this.currentPoint.copy(h),this}copy(t){return super.copy(t),this.currentPoint.copy(t.currentPoint),this}toJSON(){const t=super.toJSON();return t.currentPoint=this.currentPoint.toArray(),t}fromJSON(t){return super.fromJSON(t),this.currentPoint.fromArray(t.currentPoint),this}}class Qc extends Jc{constructor(t){super(t);this.uuid=Ot.generateUUID(),this.type="Shape",this.holes=[]}getPointsHoles(t){const e=[];for(let n=0,r=this.holes.length;n<r;n++)e[n]=this.holes[n].getPoints(t);return e}extractPoints(t){return{shape:this.getPoints(t),holes:this.getPointsHoles(t)}}copy(t){super.copy(t),this.holes=[];for(let e=0,n=t.holes.length;e<n;e++){const r=t.holes[e];this.holes.push(r.clone())}return this}toJSON(){const t=super.toJSON();t.uuid=this.uuid,t.holes=[];for(let e=0,n=this.holes.length;e<n;e++){const r=this.holes[e];t.holes.push(r.toJSON())}return t}fromJSON(t){super.fromJSON(t),this.uuid=t.uuid,this.holes=[];for(let e=0,n=t.holes.length;e<n;e++){const r=t.holes[e];this.holes.push(new Jc().fromJSON(r))}return this}}class Di extends Bt{constructor(t,e=1){super();this.type="Light",this.color=new zt(t),this.intensity=e}copy(t){return super.copy(t),this.color.copy(t.color),this.intensity=t.intensity,this}toJSON(t){const e=super.toJSON(t);return e.object.color=this.color.getHex(),e.object.intensity=this.intensity,this.groundColor!==void 0&&(e.object.groundColor=this.groundColor.getHex()),this.distance!==void 0&&(e.object.distance=this.distance),this.angle!==void 0&&(e.object.angle=this.angle),this.decay!==void 0&&(e.object.decay=this.decay),this.penumbra!==void 0&&(e.object.penumbra=this.penumbra),this.shadow!==void 0&&(e.object.shadow=this.shadow.toJSON()),e}}Di.prototype.isLight=!0;class wb extends Di{constructor(t,e,n){super(t,n);this.type="HemisphereLight",this.position.copy(Bt.DefaultUp),this.updateMatrix(),this.groundColor=new zt(e)}copy(t){return Di.prototype.copy.call(this,t),this.groundColor.copy(t.groundColor),this}}wb.prototype.isHemisphereLight=!0;const $f=new It,Xf=new U,qf=new U;class Kc{constructor(t){this.camera=t,this.bias=0,this.normalBias=0,this.radius=1,this.mapSize=new lt(512,512),this.map=null,this.mapPass=null,this.matrix=new It,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new po,this._frameExtents=new lt(1,1),this._viewportCount=1,this._viewports=[new Yt(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(t){const e=this.camera,n=this.matrix;Xf.setFromMatrixPosition(t.matrixWorld),e.position.copy(Xf),qf.setFromMatrixPosition(t.target.matrixWorld),e.lookAt(qf),e.updateMatrixWorld(),$f.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),this._frustum.setFromProjectionMatrix($f),n.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),n.multiply(e.projectionMatrix),n.multiply(e.matrixWorldInverse)}getViewport(t){return this._viewports[t]}getFrameExtents(){return this._frameExtents}copy(t){return this.camera=t.camera.clone(),this.bias=t.bias,this.radius=t.radius,this.mapSize.copy(t.mapSize),this}clone(){return new this.constructor().copy(this)}toJSON(){const t={};return this.bias!==0&&(t.bias=this.bias),this.normalBias!==0&&(t.normalBias=this.normalBias),this.radius!==1&&(t.radius=this.radius),(this.mapSize.x!==512||this.mapSize.y!==512)&&(t.mapSize=this.mapSize.toArray()),t.camera=this.camera.toJSON(!1).object,delete t.camera.matrix,t}}class Yf extends Kc{constructor(){super(new We(50,1,.5,500));this.focus=1}updateMatrices(t){const e=this.camera,n=Ot.RAD2DEG*2*t.angle*this.focus,r=this.mapSize.width/this.mapSize.height,s=t.distance||e.far;(n!==e.fov||r!==e.aspect||s!==e.far)&&(e.fov=n,e.aspect=r,e.far=s,e.updateProjectionMatrix()),super.updateMatrices(t)}copy(t){return super.copy(t),this.focus=t.focus,this}}Yf.prototype.isSpotLightShadow=!0;class Sb extends Di{constructor(t,e,n=0,r=Math.PI/3,s=0,a=1){super(t,e);this.type="SpotLight",this.position.copy(Bt.DefaultUp),this.updateMatrix(),this.target=new Bt,this.distance=n,this.angle=r,this.penumbra=s,this.decay=a,this.shadow=new Yf}get power(){return this.intensity*Math.PI}set power(t){this.intensity=t/Math.PI}copy(t){return super.copy(t),this.distance=t.distance,this.angle=t.angle,this.penumbra=t.penumbra,this.decay=t.decay,this.target=t.target.clone(),this.shadow=t.shadow.clone(),this}}Sb.prototype.isSpotLight=!0;const jf=new It,ca=new U,th=new U;class Zf extends Kc{constructor(){super(new We(90,1,.5,500));this._frameExtents=new lt(4,2),this._viewportCount=6,this._viewports=[new Yt(2,1,1,1),new Yt(0,1,1,1),new Yt(3,1,1,1),new Yt(1,1,1,1),new Yt(3,0,1,1),new Yt(1,0,1,1)],this._cubeDirections=[new U(1,0,0),new U(-1,0,0),new U(0,0,1),new U(0,0,-1),new U(0,1,0),new U(0,-1,0)],this._cubeUps=[new U(0,1,0),new U(0,1,0),new U(0,1,0),new U(0,1,0),new U(0,0,1),new U(0,0,-1)]}updateMatrices(t,e=0){const n=this.camera,r=this.matrix,s=t.distance||n.far;s!==n.far&&(n.far=s,n.updateProjectionMatrix()),ca.setFromMatrixPosition(t.matrixWorld),n.position.copy(ca),th.copy(n.position),th.add(this._cubeDirections[e]),n.up.copy(this._cubeUps[e]),n.lookAt(th),n.updateMatrixWorld(),r.makeTranslation(-ca.x,-ca.y,-ca.z),jf.multiplyMatrices(n.projectionMatrix,n.matrixWorldInverse),this._frustum.setFromProjectionMatrix(jf)}}Zf.prototype.isPointLightShadow=!0;class Eb extends Di{constructor(t,e,n=0,r=1){super(t,e);this.type="PointLight",this.distance=n,this.decay=r,this.shadow=new Zf}get power(){return this.intensity*4*Math.PI}set power(t){this.intensity=t/(4*Math.PI)}copy(t){return super.copy(t),this.distance=t.distance,this.decay=t.decay,this.shadow=t.shadow.clone(),this}}Eb.prototype.isPointLight=!0;class Jf extends Rr{constructor(t=-1,e=1,n=1,r=-1,s=.1,a=2e3){super();this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=t,this.right=e,this.top=n,this.bottom=r,this.near=s,this.far=a,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.left=t.left,this.right=t.right,this.top=t.top,this.bottom=t.bottom,this.near=t.near,this.far=t.far,this.zoom=t.zoom,this.view=t.view===null?null:Object.assign({},t.view),this}setViewOffset(t,e,n,r,s,a){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=n,this.view.offsetY=r,this.view.width=s,this.view.height=a,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=(this.right-this.left)/(2*this.zoom),e=(this.top-this.bottom)/(2*this.zoom),n=(this.right+this.left)/2,r=(this.top+this.bottom)/2;let s=n-t,a=n+t,o=r+e,l=r-e;if(this.view!==null&&this.view.enabled){const c=(this.right-this.left)/this.view.fullWidth/this.zoom,h=(this.top-this.bottom)/this.view.fullHeight/this.zoom;s+=c*this.view.offsetX,a=s+c*this.view.width,o-=h*this.view.offsetY,l=o-h*this.view.height}this.projectionMatrix.makeOrthographic(s,a,o,l,this.near,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const e=Bt.prototype.toJSON.call(this,t);return e.object.zoom=this.zoom,e.object.left=this.left,e.object.right=this.right,e.object.top=this.top,e.object.bottom=this.bottom,e.object.near=this.near,e.object.far=this.far,this.view!==null&&(e.object.view=Object.assign({},this.view)),e}}Jf.prototype.isOrthographicCamera=!0;class Qf extends Kc{constructor(){super(new Jf(-5,5,5,-5,.5,500))}}Qf.prototype.isDirectionalLightShadow=!0;class Ab extends Di{constructor(t,e){super(t,e);this.type="DirectionalLight",this.position.copy(Bt.DefaultUp),this.updateMatrix(),this.target=new Bt,this.shadow=new Qf}copy(t){return super.copy(t),this.target=t.target.clone(),this.shadow=t.shadow.clone(),this}}Ab.prototype.isDirectionalLight=!0;class Tb extends Di{constructor(t,e){super(t,e);this.type="AmbientLight"}}Tb.prototype.isAmbientLight=!0;class Lb extends Di{constructor(t,e,n=10,r=10){super(t,e);this.type="RectAreaLight",this.width=n,this.height=r}copy(t){return super.copy(t),this.width=t.width,this.height=t.height,this}toJSON(t){const e=super.toJSON(t);return e.object.width=this.width,e.object.height=this.height,e}}Lb.prototype.isRectAreaLight=!0;class Kf{constructor(){this.coefficients=[];for(let t=0;t<9;t++)this.coefficients.push(new U)}set(t){for(let e=0;e<9;e++)this.coefficients[e].copy(t[e]);return this}zero(){for(let t=0;t<9;t++)this.coefficients[t].set(0,0,0);return this}getAt(t,e){const n=t.x,r=t.y,s=t.z,a=this.coefficients;return e.copy(a[0]).multiplyScalar(.282095),e.addScaledVector(a[1],.488603*r),e.addScaledVector(a[2],.488603*s),e.addScaledVector(a[3],.488603*n),e.addScaledVector(a[4],1.092548*(n*r)),e.addScaledVector(a[5],1.092548*(r*s)),e.addScaledVector(a[6],.315392*(3*s*s-1)),e.addScaledVector(a[7],1.092548*(n*s)),e.addScaledVector(a[8],.546274*(n*n-r*r)),e}getIrradianceAt(t,e){const n=t.x,r=t.y,s=t.z,a=this.coefficients;return e.copy(a[0]).multiplyScalar(.886227),e.addScaledVector(a[1],2*.511664*r),e.addScaledVector(a[2],2*.511664*s),e.addScaledVector(a[3],2*.511664*n),e.addScaledVector(a[4],2*.429043*n*r),e.addScaledVector(a[5],2*.429043*r*s),e.addScaledVector(a[6],.743125*s*s-.247708),e.addScaledVector(a[7],2*.429043*n*s),e.addScaledVector(a[8],.429043*(n*n-r*r)),e}add(t){for(let e=0;e<9;e++)this.coefficients[e].add(t.coefficients[e]);return this}addScaledSH(t,e){for(let n=0;n<9;n++)this.coefficients[n].addScaledVector(t.coefficients[n],e);return this}scale(t){for(let e=0;e<9;e++)this.coefficients[e].multiplyScalar(t);return this}lerp(t,e){for(let n=0;n<9;n++)this.coefficients[n].lerp(t.coefficients[n],e);return this}equals(t){for(let e=0;e<9;e++)if(!this.coefficients[e].equals(t.coefficients[e]))return!1;return!0}copy(t){return this.set(t.coefficients)}clone(){return new this.constructor().copy(this)}fromArray(t,e=0){const n=this.coefficients;for(let r=0;r<9;r++)n[r].fromArray(t,e+r*3);return this}toArray(t=[],e=0){const n=this.coefficients;for(let r=0;r<9;r++)n[r].toArray(t,e+r*3);return t}static getBasisAt(t,e){const n=t.x,r=t.y,s=t.z;e[0]=.282095,e[1]=.488603*r,e[2]=.488603*s,e[3]=.488603*n,e[4]=1.092548*n*r,e[5]=1.092548*r*s,e[6]=.315392*(3*s*s-1),e[7]=1.092548*n*s,e[8]=.546274*(n*n-r*r)}}Kf.prototype.isSphericalHarmonics3=!0;class eh extends Di{constructor(t=new Kf,e=1){super(void 0,e);this.sh=t}copy(t){return super.copy(t),this.sh.copy(t.sh),this}fromJSON(t){return this.intensity=t.intensity,this.sh.fromArray(t.sh),this}toJSON(t){const e=super.toJSON(t);return e.object.sh=this.sh.toArray(),e}}eh.prototype.isLightProbe=!0;const Rb={decodeText:function(i){if(typeof TextDecoder!="undefined")return new TextDecoder().decode(i);let t="";for(let e=0,n=i.length;e<n;e++)t+=String.fromCharCode(i[e]);try{return decodeURIComponent(escape(t))}catch(e){return t}},extractUrlBase:function(i){const t=i.lastIndexOf("/");return t===-1?"./":i.substr(0,t+1)}};function ih(){$t.call(this),this.type="InstancedBufferGeometry",this.instanceCount=1/0}ih.prototype=Object.assign(Object.create($t.prototype),{constructor:ih,isInstancedBufferGeometry:!0,copy:function(i){return $t.prototype.copy.call(this,i),this.instanceCount=i.instanceCount,this},clone:function(){return new this.constructor().copy(this)},toJSON:function(){const i=$t.prototype.toJSON.call(this);return i.instanceCount=this.instanceCount,i.isInstancedBufferGeometry=!0,i}});function tp(i,t,e,n){typeof e=="number"&&(n=e,e=!1,console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")),Gt.call(this,i,t,e),this.meshPerAttribute=n||1}tp.prototype=Object.assign(Object.create(Gt.prototype),{constructor:tp,isInstancedBufferAttribute:!0,copy:function(i){return Gt.prototype.copy.call(this,i),this.meshPerAttribute=i.meshPerAttribute,this},toJSON:function(){const i=Gt.prototype.toJSON.call(this);return i.meshPerAttribute=this.meshPerAttribute,i.isInstancedBufferAttribute=!0,i}});function ep(i){typeof createImageBitmap=="undefined"&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),typeof fetch=="undefined"&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),Fe.call(this,i),this.options={premultiplyAlpha:"none"}}ep.prototype=Object.assign(Object.create(Fe.prototype),{constructor:ep,isImageBitmapLoader:!0,setOptions:function(t){return this.options=t,this},load:function(i,t,e,n){i===void 0&&(i=""),this.path!==void 0&&(i=this.path+i),i=this.manager.resolveURL(i);const r=this,s=kr.get(i);if(s!==void 0)return r.manager.itemStart(i),setTimeout(function(){t&&t(s),r.manager.itemEnd(i)},0),s;const a={};a.credentials=this.crossOrigin==="anonymous"?"same-origin":"include",a.headers=this.requestHeader,fetch(i,a).then(function(o){return o.blob()}).then(function(o){return createImageBitmap(o,Object.assign(r.options,{colorSpaceConversion:"none"}))}).then(function(o){kr.add(i,o),t&&t(o),r.manager.itemEnd(i)}).catch(function(o){n&&n(o),r.manager.itemError(i),r.manager.itemEnd(i)}),r.manager.itemStart(i)}});let Fo;const Cb={getContext:function(){return Fo===void 0&&(Fo=new(window.AudioContext||window.webkitAudioContext)),Fo},setContext:function(i){Fo=i}};class Pb extends Fe{constructor(t){super(t)}load(t,e,n,r){const s=this,a=new aa(this.manager);a.setResponseType("arraybuffer"),a.setPath(this.path),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(t,function(o){try{const l=o.slice(0);Cb.getContext().decodeAudioData(l,function(h){e(h)})}catch(l){r?r(l):console.error(l),s.manager.itemError(t)}},n,r)}}class Db extends eh{constructor(t,e,n=1){super(void 0,n);const r=new zt().set(t),s=new zt().set(e),a=new U(r.r,r.g,r.b),o=new U(s.r,s.g,s.b),l=Math.sqrt(Math.PI),c=l*Math.sqrt(.75);this.sh.coefficients[0].copy(a).add(o).multiplyScalar(l),this.sh.coefficients[1].copy(a).sub(o).multiplyScalar(c)}}Db.prototype.isHemisphereLightProbe=!0;class Fb extends eh{constructor(t,e=1){super(void 0,e);const n=new zt().set(t);this.sh.coefficients[0].set(n.r,n.g,n.b).multiplyScalar(2*Math.sqrt(Math.PI))}}Fb.prototype.isAmbientLightProbe=!0;new It;new It;class Ib extends Bt{constructor(t){super();this.type="Audio",this.listener=t,this.context=t.context,this.gain=this.context.createGain(),this.gain.connect(t.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(t){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=t,this.connect(),this}setMediaElementSource(t){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(t),this.connect(),this}setMediaStreamSource(t){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(t),this.connect(),this}setBuffer(t){return this.buffer=t,this.sourceType="buffer",this.autoplay&&this.play(),this}play(t=0){if(this.isPlaying===!0){console.warn("THREE.Audio: Audio is already playing.");return}if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}this._startedAt=this.context.currentTime+t;const e=this.context.createBufferSource();return e.buffer=this.buffer,e.loop=this.loop,e.loopStart=this.loopStart,e.loopEnd=this.loopEnd,e.onended=this.onEnded.bind(this),e.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=e,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.isPlaying===!0&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,this.loop===!0&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this}stop(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this._progress=0,this.source.stop(),this.source.onended=null,this.isPlaying=!1,this}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let t=1,e=this.filters.length;t<e;t++)this.filters[t-1].connect(this.filters[t]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let t=1,e=this.filters.length;t<e;t++)this.filters[t-1].disconnect(this.filters[t]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}getFilters(){return this.filters}setFilters(t){return t||(t=[]),this._connected===!0?(this.disconnect(),this.filters=t.slice(),this.connect()):this.filters=t.slice(),this}setDetune(t){if(this.detune=t,this.source.detune!==void 0)return this.isPlaying===!0&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(t){return this.setFilters(t?[t]:[])}setPlaybackRate(t){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.playbackRate=t,this.isPlaying===!0&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1}getLoop(){return this.hasPlaybackControl===!1?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop}setLoop(t){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.loop=t,this.isPlaying===!0&&(this.source.loop=this.loop),this}setLoopStart(t){return this.loopStart=t,this}setLoopEnd(t){return this.loopEnd=t,this}getVolume(){return this.gain.gain.value}setVolume(t){return this.gain.gain.setTargetAtTime(t,this.context.currentTime,.01),this}}class zb{constructor(t,e,n){this.binding=t,this.valueSize=n;let r,s,a;switch(e){case"quaternion":r=this._slerp,s=this._slerpAdditive,a=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(n*6),this._workIndex=5;break;case"string":case"bool":r=this._select,s=this._select,a=this._setAdditiveIdentityOther,this.buffer=new Array(n*5);break;default:r=this._lerp,s=this._lerpAdditive,a=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(n*5)}this._mixBufferRegion=r,this._mixBufferRegionAdditive=s,this._setIdentity=a,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}accumulate(t,e){const n=this.buffer,r=this.valueSize,s=t*r+r;let a=this.cumulativeWeight;if(a===0){for(let o=0;o!==r;++o)n[s+o]=n[o];a=e}else{a+=e;const o=e/a;this._mixBufferRegion(n,s,0,o,r)}this.cumulativeWeight=a}accumulateAdditive(t){const e=this.buffer,n=this.valueSize,r=n*this._addIndex;this.cumulativeWeightAdditive===0&&this._setIdentity(),this._mixBufferRegionAdditive(e,r,0,t,n),this.cumulativeWeightAdditive+=t}apply(t){const e=this.valueSize,n=this.buffer,r=t*e+e,s=this.cumulativeWeight,a=this.cumulativeWeightAdditive,o=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,s<1){const l=e*this._origIndex;this._mixBufferRegion(n,r,l,1-s,e)}a>0&&this._mixBufferRegionAdditive(n,r,this._addIndex*e,1,e);for(let l=e,c=e+e;l!==c;++l)if(n[l]!==n[l+e]){o.setValue(n,r);break}}saveOriginalState(){const t=this.binding,e=this.buffer,n=this.valueSize,r=n*this._origIndex;t.getValue(e,r);for(let s=n,a=r;s!==a;++s)e[s]=e[r+s%n];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}restoreOriginalState(){const t=this.valueSize*3;this.binding.setValue(this.buffer,t)}_setAdditiveIdentityNumeric(){const t=this._addIndex*this.valueSize,e=t+this.valueSize;for(let n=t;n<e;n++)this.buffer[n]=0}_setAdditiveIdentityQuaternion(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1}_setAdditiveIdentityOther(){const t=this._origIndex*this.valueSize,e=this._addIndex*this.valueSize;for(let n=0;n<this.valueSize;n++)this.buffer[e+n]=this.buffer[t+n]}_select(t,e,n,r,s){if(r>=.5)for(let a=0;a!==s;++a)t[e+a]=t[n+a]}_slerp(t,e,n,r){Ae.slerpFlat(t,e,t,e,t,n,r)}_slerpAdditive(t,e,n,r,s){const a=this._workIndex*s;Ae.multiplyQuaternionsFlat(t,a,t,e,t,n),Ae.slerpFlat(t,e,t,e,t,a,r)}_lerp(t,e,n,r,s){const a=1-r;for(let o=0;o!==s;++o){const l=e+o;t[l]=t[l]*a+t[n+o]*r}}_lerpAdditive(t,e,n,r,s){for(let a=0;a!==s;++a){const o=e+a;t[o]=t[o]+t[n+a]*r}}}const nh="\\[\\]\\.:\\/",Nb=new RegExp("["+nh+"]","g"),rh="[^"+nh+"]",Bb="[^"+nh.replace("\\.","")+"]",Ob=/((?:WC+[\/:])*)/.source.replace("WC",rh),Ub=/(WCOD+)?/.source.replace("WCOD",Bb),Hb=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",rh),Gb=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",rh),kb=new RegExp("^"+Ob+Ub+Hb+Gb+"$"),Vb=["material","materials","bones"];function ip(i,t,e){const n=e||ai.parseTrackName(t);this._targetGroup=i,this._bindings=i.subscribe_(t,n)}Object.assign(ip.prototype,{getValue:function(i,t){this.bind();const e=this._targetGroup.nCachedObjects_,n=this._bindings[e];n!==void 0&&n.getValue(i,t)},setValue:function(i,t){const e=this._bindings;for(let n=this._targetGroup.nCachedObjects_,r=e.length;n!==r;++n)e[n].setValue(i,t)},bind:function(){const i=this._bindings;for(let t=this._targetGroup.nCachedObjects_,e=i.length;t!==e;++t)i[t].bind()},unbind:function(){const i=this._bindings;for(let t=this._targetGroup.nCachedObjects_,e=i.length;t!==e;++t)i[t].unbind()}});function ai(i,t,e){this.path=t,this.parsedPath=e||ai.parseTrackName(t),this.node=ai.findNode(i,this.parsedPath.nodeName)||i,this.rootNode=i}Object.assign(ai,{Composite:ip,create:function(i,t,e){return i&&i.isAnimationObjectGroup?new ai.Composite(i,t,e):new ai(i,t,e)},sanitizeNodeName:function(i){return i.replace(/\s/g,"_").replace(Nb,"")},parseTrackName:function(i){const t=kb.exec(i);if(!t)throw new Error("PropertyBinding: Cannot parse trackName: "+i);const e={nodeName:t[2],objectName:t[3],objectIndex:t[4],propertyName:t[5],propertyIndex:t[6]},n=e.nodeName&&e.nodeName.lastIndexOf(".");if(n!==void 0&&n!==-1){const r=e.nodeName.substring(n+1);Vb.indexOf(r)!==-1&&(e.nodeName=e.nodeName.substring(0,n),e.objectName=r)}if(e.propertyName===null||e.propertyName.length===0)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+i);return e},findNode:function(i,t){if(!t||t===""||t==="."||t===-1||t===i.name||t===i.uuid)return i;if(i.skeleton){const e=i.skeleton.getBoneByName(t);if(e!==void 0)return e}if(i.children){const e=function(r){for(let s=0;s<r.length;s++){const a=r[s];if(a.name===t||a.uuid===t)return a;const o=e(a.children);if(o)return o}return null},n=e(i.children);if(n)return n}return null}});Object.assign(ai.prototype,{_getValue_unavailable:function(){},_setValue_unavailable:function(){},BindingType:{Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3},Versioning:{None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2},GetterByBindingType:[function(t,e){t[e]=this.node[this.propertyName]},function(t,e){const n=this.resolvedProperty;for(let r=0,s=n.length;r!==s;++r)t[e++]=n[r]},function(t,e){t[e]=this.resolvedProperty[this.propertyIndex]},function(t,e){this.resolvedProperty.toArray(t,e)}],SetterByBindingTypeAndVersioning:[[function(t,e){this.targetObject[this.propertyName]=t[e]},function(t,e){this.targetObject[this.propertyName]=t[e],this.targetObject.needsUpdate=!0},function(t,e){this.targetObject[this.propertyName]=t[e],this.targetObject.matrixWorldNeedsUpdate=!0}],[function(t,e){const n=this.resolvedProperty;for(let r=0,s=n.length;r!==s;++r)n[r]=t[e++]},function(t,e){const n=this.resolvedProperty;for(let r=0,s=n.length;r!==s;++r)n[r]=t[e++];this.targetObject.needsUpdate=!0},function(t,e){const n=this.resolvedProperty;for(let r=0,s=n.length;r!==s;++r)n[r]=t[e++];this.targetObject.matrixWorldNeedsUpdate=!0}],[function(t,e){this.resolvedProperty[this.propertyIndex]=t[e]},function(t,e){this.resolvedProperty[this.propertyIndex]=t[e],this.targetObject.needsUpdate=!0},function(t,e){this.resolvedProperty[this.propertyIndex]=t[e],this.targetObject.matrixWorldNeedsUpdate=!0}],[function(t,e){this.resolvedProperty.fromArray(t,e)},function(t,e){this.resolvedProperty.fromArray(t,e),this.targetObject.needsUpdate=!0},function(t,e){this.resolvedProperty.fromArray(t,e),this.targetObject.matrixWorldNeedsUpdate=!0}]],getValue:function(t,e){this.bind(),this.getValue(t,e)},setValue:function(t,e){this.bind(),this.setValue(t,e)},bind:function(){let i=this.node;const t=this.parsedPath,e=t.objectName,n=t.propertyName;let r=t.propertyIndex;if(i||(i=ai.findNode(this.rootNode,t.nodeName)||this.rootNode,this.node=i),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!i){console.error("THREE.PropertyBinding: Trying to update node for track: "+this.path+" but it wasn't found.");return}if(e){let l=t.objectIndex;switch(e){case"materials":if(!i.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!i.material.materials){console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);return}i=i.material.materials;break;case"bones":if(!i.skeleton){console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);return}i=i.skeleton.bones;for(let c=0;c<i.length;c++)if(i[c].name===l){l=c;break}break;default:if(i[e]===void 0){console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);return}i=i[e]}if(l!==void 0){if(i[l]===void 0){console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,i);return}i=i[l]}}const s=i[n];if(s===void 0){const l=t.nodeName;console.error("THREE.PropertyBinding: Trying to update property for track: "+l+"."+n+" but it wasn't found.",i);return}let a=this.Versioning.None;this.targetObject=i,i.needsUpdate!==void 0?a=this.Versioning.NeedsUpdate:i.matrixWorldNeedsUpdate!==void 0&&(a=this.Versioning.MatrixWorldNeedsUpdate);let o=this.BindingType.Direct;if(r!==void 0){if(n==="morphTargetInfluences"){if(!i.geometry){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);return}if(i.geometry.isBufferGeometry){if(!i.geometry.morphAttributes){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);return}i.morphTargetDictionary[r]!==void 0&&(r=i.morphTargetDictionary[r])}else{console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",this);return}}o=this.BindingType.ArrayElement,this.resolvedProperty=s,this.propertyIndex=r}else s.fromArray!==void 0&&s.toArray!==void 0?(o=this.BindingType.HasFromToArray,this.resolvedProperty=s):Array.isArray(s)?(o=this.BindingType.EntireArray,this.resolvedProperty=s):this.propertyName=n;this.getValue=this.GetterByBindingType[o],this.setValue=this.SetterByBindingTypeAndVersioning[o][a]},unbind:function(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}});Object.assign(ai.prototype,{_getValue_unbound:ai.prototype.getValue,_setValue_unbound:ai.prototype.setValue});class Wb{constructor(t,e,n=null,r=e.blendMode){this._mixer=t,this._clip=e,this._localRoot=n,this.blendMode=r;const s=e.tracks,a=s.length,o=new Array(a),l={endingStart:dr,endingEnd:dr};for(let c=0;c!==a;++c){const h=s[c].createInterpolant(null);o[c]=h,h.settings=l}this._interpolantSettings=l,this._interpolants=o,this._propertyBindings=new Array(a),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=Wx,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&this.timeScale!==0&&this._startTime===null&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(t){return this._startTime=t,this}setLoop(t,e){return this.loop=t,this.repetitions=e,this}setEffectiveWeight(t){return this.weight=t,this._effectiveWeight=this.enabled?t:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(t){return this._scheduleFading(t,0,1)}fadeOut(t){return this._scheduleFading(t,1,0)}crossFadeFrom(t,e,n){if(t.fadeOut(e),this.fadeIn(e),n){const r=this._clip.duration,s=t._clip.duration,a=s/r,o=r/s;t.warp(1,a,e),this.warp(o,1,e)}return this}crossFadeTo(t,e,n){return t.crossFadeFrom(this,e,n)}stopFading(){const t=this._weightInterpolant;return t!==null&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(t)),this}setEffectiveTimeScale(t){return this.timeScale=t,this._effectiveTimeScale=this.paused?0:t,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(t){return this.timeScale=this._clip.duration/t,this.stopWarping()}syncWith(t){return this.time=t.time,this.timeScale=t.timeScale,this.stopWarping()}halt(t){return this.warp(this._effectiveTimeScale,0,t)}warp(t,e,n){const r=this._mixer,s=r.time,a=this.timeScale;let o=this._timeScaleInterpolant;o===null&&(o=r._lendControlInterpolant(),this._timeScaleInterpolant=o);const l=o.parameterPositions,c=o.sampleValues;return l[0]=s,l[1]=s+n,c[0]=t/a,c[1]=e/a,this}stopWarping(){const t=this._timeScaleInterpolant;return t!==null&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(t)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(t,e,n,r){if(!this.enabled){this._updateWeight(t);return}const s=this._startTime;if(s!==null){const l=(t-s)*n;if(l<0||n===0)return;this._startTime=null,e=n*l}e*=this._updateTimeScale(t);const a=this._updateTime(e),o=this._updateWeight(t);if(o>0){const l=this._interpolants,c=this._propertyBindings;switch(this.blendMode){case dd:for(let h=0,u=l.length;h!==u;++h)l[h].evaluate(a),c[h].accumulateAdditive(o);break;case Zl:default:for(let h=0,u=l.length;h!==u;++h)l[h].evaluate(a),c[h].accumulate(r,o)}}}_updateWeight(t){let e=0;if(this.enabled){e=this.weight;const n=this._weightInterpolant;if(n!==null){const r=n.evaluate(t)[0];e*=r,t>n.parameterPositions[1]&&(this.stopFading(),r===0&&(this.enabled=!1))}}return this._effectiveWeight=e,e}_updateTimeScale(t){let e=0;if(!this.paused){e=this.timeScale;const n=this._timeScaleInterpolant;n!==null&&(e*=n.evaluate(t)[0],t>n.parameterPositions[1]&&(this.stopWarping(),e===0?this.paused=!0:this.timeScale=e))}return this._effectiveTimeScale=e,e}_updateTime(t){const e=this._clip.duration,n=this.loop;let r=this.time+t,s=this._loopCount;const a=n===$x;if(t===0)return s===-1?r:a&&(s&1)==1?e-r:r;if(n===Vx){s===-1&&(this._loopCount=0,this._setEndings(!0,!0,!1));t:{if(r>=e)r=e;else if(r<0)r=0;else{this.time=r;break t}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=r,this._mixer.dispatchEvent({type:"finished",action:this,direction:t<0?-1:1})}}else{if(s===-1&&(t>=0?(s=0,this._setEndings(!0,this.repetitions===0,a)):this._setEndings(this.repetitions===0,!0,a)),r>=e||r<0){const o=Math.floor(r/e);r-=e*o,s+=Math.abs(o);const l=this.repetitions-s;if(l<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,r=t>0?e:0,this.time=r,this._mixer.dispatchEvent({type:"finished",action:this,direction:t>0?1:-1});else{if(l===1){const c=t<0;this._setEndings(c,!c,a)}else this._setEndings(!1,!1,a);this._loopCount=s,this.time=r,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:o})}}else this.time=r;if(a&&(s&1)==1)return e-r}return r}_setEndings(t,e,n){const r=this._interpolantSettings;n?(r.endingStart=fr,r.endingEnd=fr):(t?r.endingStart=this.zeroSlopeAtStart?fr:dr:r.endingStart=Xa,e?r.endingEnd=this.zeroSlopeAtEnd?fr:dr:r.endingEnd=Xa)}_scheduleFading(t,e,n){const r=this._mixer,s=r.time;let a=this._weightInterpolant;a===null&&(a=r._lendControlInterpolant(),this._weightInterpolant=a);const o=a.parameterPositions,l=a.sampleValues;return o[0]=s,l[0]=e,o[1]=s+t,l[1]=n,this}}class $b extends Ti{constructor(t){super();this._root=t,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}_bindAction(t,e){const n=t._localRoot||this._root,r=t._clip.tracks,s=r.length,a=t._propertyBindings,o=t._interpolants,l=n.uuid,c=this._bindingsByRootAndName;let h=c[l];h===void 0&&(h={},c[l]=h);for(let u=0;u!==s;++u){const d=r[u],f=d.name;let p=h[f];if(p!==void 0)a[u]=p;else{if(p=a[u],p!==void 0){p._cacheIndex===null&&(++p.referenceCount,this._addInactiveBinding(p,l,f));continue}const x=e&&e._propertyBindings[u].binding.parsedPath;p=new zb(ai.create(n,f,x),d.ValueTypeName,d.getValueSize()),++p.referenceCount,this._addInactiveBinding(p,l,f),a[u]=p}o[u].resultBuffer=p.buffer}}_activateAction(t){if(!this._isActiveAction(t)){if(t._cacheIndex===null){const n=(t._localRoot||this._root).uuid,r=t._clip.uuid,s=this._actionsByClip[r];this._bindAction(t,s&&s.knownActions[0]),this._addInactiveAction(t,r,n)}const e=t._propertyBindings;for(let n=0,r=e.length;n!==r;++n){const s=e[n];s.useCount++==0&&(this._lendBinding(s),s.saveOriginalState())}this._lendAction(t)}}_deactivateAction(t){if(this._isActiveAction(t)){const e=t._propertyBindings;for(let n=0,r=e.length;n!==r;++n){const s=e[n];--s.useCount==0&&(s.restoreOriginalState(),this._takeBackBinding(s))}this._takeBackAction(t)}}_initMemoryManager(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const t=this;this.stats={actions:{get total(){return t._actions.length},get inUse(){return t._nActiveActions}},bindings:{get total(){return t._bindings.length},get inUse(){return t._nActiveBindings}},controlInterpolants:{get total(){return t._controlInterpolants.length},get inUse(){return t._nActiveControlInterpolants}}}}_isActiveAction(t){const e=t._cacheIndex;return e!==null&&e<this._nActiveActions}_addInactiveAction(t,e,n){const r=this._actions,s=this._actionsByClip;let a=s[e];if(a===void 0)a={knownActions:[t],actionByRoot:{}},t._byClipCacheIndex=0,s[e]=a;else{const o=a.knownActions;t._byClipCacheIndex=o.length,o.push(t)}t._cacheIndex=r.length,r.push(t),a.actionByRoot[n]=t}_removeInactiveAction(t){const e=this._actions,n=e[e.length-1],r=t._cacheIndex;n._cacheIndex=r,e[r]=n,e.pop(),t._cacheIndex=null;const s=t._clip.uuid,a=this._actionsByClip,o=a[s],l=o.knownActions,c=l[l.length-1],h=t._byClipCacheIndex;c._byClipCacheIndex=h,l[h]=c,l.pop(),t._byClipCacheIndex=null;const u=o.actionByRoot,d=(t._localRoot||this._root).uuid;delete u[d],l.length===0&&delete a[s],this._removeInactiveBindingsForAction(t)}_removeInactiveBindingsForAction(t){const e=t._propertyBindings;for(let n=0,r=e.length;n!==r;++n){const s=e[n];--s.referenceCount==0&&this._removeInactiveBinding(s)}}_lendAction(t){const e=this._actions,n=t._cacheIndex,r=this._nActiveActions++,s=e[r];t._cacheIndex=r,e[r]=t,s._cacheIndex=n,e[n]=s}_takeBackAction(t){const e=this._actions,n=t._cacheIndex,r=--this._nActiveActions,s=e[r];t._cacheIndex=r,e[r]=t,s._cacheIndex=n,e[n]=s}_addInactiveBinding(t,e,n){const r=this._bindingsByRootAndName,s=this._bindings;let a=r[e];a===void 0&&(a={},r[e]=a),a[n]=t,t._cacheIndex=s.length,s.push(t)}_removeInactiveBinding(t){const e=this._bindings,n=t.binding,r=n.rootNode.uuid,s=n.path,a=this._bindingsByRootAndName,o=a[r],l=e[e.length-1],c=t._cacheIndex;l._cacheIndex=c,e[c]=l,e.pop(),delete o[s],Object.keys(o).length===0&&delete a[r]}_lendBinding(t){const e=this._bindings,n=t._cacheIndex,r=this._nActiveBindings++,s=e[r];t._cacheIndex=r,e[r]=t,s._cacheIndex=n,e[n]=s}_takeBackBinding(t){const e=this._bindings,n=t._cacheIndex,r=--this._nActiveBindings,s=e[r];t._cacheIndex=r,e[r]=t,s._cacheIndex=n,e[n]=s}_lendControlInterpolant(){const t=this._controlInterpolants,e=this._nActiveControlInterpolants++;let n=t[e];return n===void 0&&(n=new To(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer),n.__cacheIndex=e,t[e]=n),n}_takeBackControlInterpolant(t){const e=this._controlInterpolants,n=t.__cacheIndex,r=--this._nActiveControlInterpolants,s=e[r];t.__cacheIndex=r,e[r]=t,s.__cacheIndex=n,e[n]=s}clipAction(t,e,n){const r=e||this._root,s=r.uuid;let a=typeof t=="string"?Nf.findByName(r,t):t;const o=a!==null?a.uuid:t,l=this._actionsByClip[o];let c=null;if(n===void 0&&(a!==null?n=a.blendMode:n=Zl),l!==void 0){const u=l.actionByRoot[s];if(u!==void 0&&u.blendMode===n)return u;c=l.knownActions[0],a===null&&(a=c._clip)}if(a===null)return null;const h=new Wb(this,a,e,n);return this._bindAction(h,c),this._addInactiveAction(h,o,s),h}existingAction(t,e){const n=e||this._root,r=n.uuid,s=typeof t=="string"?Nf.findByName(n,t):t,a=s?s.uuid:t,o=this._actionsByClip[a];return o!==void 0&&o.actionByRoot[r]||null}stopAllAction(){const t=this._actions,e=this._nActiveActions;for(let n=e-1;n>=0;--n)t[n].stop();return this}update(t){t*=this.timeScale;const e=this._actions,n=this._nActiveActions,r=this.time+=t,s=Math.sign(t),a=this._accuIndex^=1;for(let c=0;c!==n;++c)e[c]._update(r,t,s,a);const o=this._bindings,l=this._nActiveBindings;for(let c=0;c!==l;++c)o[c].apply(a);return this}setTime(t){this.time=0;for(let e=0;e<this._actions.length;e++)this._actions[e].time=0;return this.update(t)}getRoot(){return this._root}uncacheClip(t){const e=this._actions,n=t.uuid,r=this._actionsByClip,s=r[n];if(s!==void 0){const a=s.knownActions;for(let o=0,l=a.length;o!==l;++o){const c=a[o];this._deactivateAction(c);const h=c._cacheIndex,u=e[e.length-1];c._cacheIndex=null,c._byClipCacheIndex=null,u._cacheIndex=h,e[h]=u,e.pop(),this._removeInactiveBindingsForAction(c)}delete r[n]}}uncacheRoot(t){const e=t.uuid,n=this._actionsByClip;for(const a in n){const o=n[a].actionByRoot,l=o[e];l!==void 0&&(this._deactivateAction(l),this._removeInactiveAction(l))}const r=this._bindingsByRootAndName,s=r[e];if(s!==void 0)for(const a in s){const o=s[a];o.restoreOriginalState(),this._removeInactiveBinding(o)}}uncacheAction(t,e){const n=this.existingAction(t,e);n!==null&&(this._deactivateAction(n),this._removeInactiveAction(n))}}$b.prototype._controlInterpolantsResultBuffer=new Float32Array(1);function np(i,t,e){ri.call(this,i,t),this.meshPerAttribute=e||1}np.prototype=Object.assign(Object.create(ri.prototype),{constructor:np,isInstancedInterleavedBuffer:!0,copy:function(i){return ri.prototype.copy.call(this,i),this.meshPerAttribute=i.meshPerAttribute,this},clone:function(i){const t=ri.prototype.clone.call(this,i);return t.meshPerAttribute=this.meshPerAttribute,t},toJSON:function(i){const t=ri.prototype.toJSON.call(this,i);return t.isInstancedInterleavedBuffer=!0,t.meshPerAttribute=this.meshPerAttribute,t}});function rp(i,t,e,n,r){this.buffer=i,this.type=t,this.itemSize=e,this.elementSize=n,this.count=r,this.version=0}Object.defineProperty(rp.prototype,"needsUpdate",{set:function(i){i===!0&&this.version++}});Object.assign(rp.prototype,{isGLBufferAttribute:!0,setBuffer:function(i){return this.buffer=i,this},setType:function(i,t){return this.type=i,this.elementSize=t,this},setItemSize:function(i){return this.itemSize=i,this},setCount:function(i){return this.count=i,this}});function sp(i,t,e=0,n=1/0){this.ray=new Yn(i,t),this.near=e,this.far=n,this.camera=null,this.layers=new _d,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}},Object.defineProperties(this.params,{PointCloud:{get:function(){return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."),this.Points}}})}function ap(i,t){return i.distance-t.distance}function sh(i,t,e,n){if(i.layers.test(t.layers)&&i.raycast(t,e),n===!0){const r=i.children;for(let s=0,a=r.length;s<a;s++)sh(r[s],t,e,!0)}}Object.assign(sp.prototype,{set:function(i,t){this.ray.set(i,t)},setFromCamera:function(i,t){t&&t.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(t.matrixWorld),this.ray.direction.set(i.x,i.y,.5).unproject(t).sub(this.ray.origin).normalize(),this.camera=t):t&&t.isOrthographicCamera?(this.ray.origin.set(i.x,i.y,(t.near+t.far)/(t.near-t.far)).unproject(t),this.ray.direction.set(0,0,-1).transformDirection(t.matrixWorld),this.camera=t):console.error("THREE.Raycaster: Unsupported camera type: "+t.type)},intersectObject:function(i,t=!1,e=[]){return sh(i,this,e,t),e.sort(ap),e},intersectObjects:function(i,t=!1,e=[]){for(let n=0,r=i.length;n<r;n++)sh(i[n],this,e,t);return e.sort(ap),e}});class op{constructor(t=1,e=0,n=0){return this.radius=t,this.phi=e,this.theta=n,this}set(t,e,n){return this.radius=t,this.phi=e,this.theta=n,this}copy(t){return this.radius=t.radius,this.phi=t.phi,this.theta=t.theta,this}makeSafe(){const t=1e-6;return this.phi=Math.max(t,Math.min(Math.PI-t,this.phi)),this}setFromVector3(t){return this.setFromCartesianCoords(t.x,t.y,t.z)}setFromCartesianCoords(t,e,n){return this.radius=Math.sqrt(t*t+e*e+n*n),this.radius===0?(this.theta=0,this.phi=0):(this.theta=Math.atan2(t,n),this.phi=Math.acos(Ot.clamp(e/this.radius,-1,1))),this}clone(){return new this.constructor().copy(this)}}function Io(i){Bt.call(this),this.material=i,this.render=function(){},this.hasPositions=!1,this.hasNormals=!1,this.hasColors=!1,this.hasUvs=!1,this.positionArray=null,this.normalArray=null,this.colorArray=null,this.uvArray=null,this.count=0}Io.prototype=Object.create(Bt.prototype);Io.prototype.constructor=Io;Io.prototype.isImmediateRenderObject=!0;const bn=new U,zo=new It,ah=new It;class Xb extends vo{constructor(t){const e=lp(t),n=new $t,r=[],s=[],a=new zt(0,0,1),o=new zt(0,1,0);for(let c=0;c<e.length;c++){const h=e[c];h.parent&&h.parent.isBone&&(r.push(0,0,0),r.push(0,0,0),s.push(a.r,a.g,a.b),s.push(o.r,o.g,o.b))}n.setAttribute("position",new ie(r,3)),n.setAttribute("color",new ie(s,3));const l=new ta({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0});super(n,l);this.type="SkeletonHelper",this.isSkeletonHelper=!0,this.root=t,this.bones=e,this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1}updateMatrixWorld(t){const e=this.bones,n=this.geometry,r=n.getAttribute("position");ah.copy(this.root.matrixWorld).invert();for(let s=0,a=0;s<e.length;s++){const o=e[s];o.parent&&o.parent.isBone&&(zo.multiplyMatrices(ah,o.matrixWorld),bn.setFromMatrixPosition(zo),r.setXYZ(a,bn.x,bn.y,bn.z),zo.multiplyMatrices(ah,o.parent.matrixWorld),bn.setFromMatrixPosition(zo),r.setXYZ(a+1,bn.x,bn.y,bn.z),a+=2)}n.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(t)}}function lp(i){const t=[];i&&i.isBone&&t.push(i);for(let e=0;e<i.children.length;e++)t.push.apply(t,lp(i.children[e]));return t}class qb extends vo{constructor(t=10,e=10,n=4473924,r=8947848){n=new zt(n),r=new zt(r);const s=e/2,a=t/e,o=t/2,l=[],c=[];for(let d=0,f=0,p=-o;d<=e;d++,p+=a){l.push(-o,0,p,o,0,p),l.push(p,0,-o,p,0,o);const x=d===s?n:r;x.toArray(c,f),f+=3,x.toArray(c,f),f+=3,x.toArray(c,f),f+=3,x.toArray(c,f),f+=3}const h=new $t;h.setAttribute("position",new ie(l,3)),h.setAttribute("color",new ie(c,3));const u=new ta({vertexColors:!0,toneMapped:!1});super(h,u);this.type="GridHelper"}}const Yb=new Float32Array(1);new Int32Array(Yb.buffer);const jb=new mc({side:ye,depthWrite:!1,depthTest:!1});new Te(new Lc,jb);$e.create=function(i,t){return console.log("THREE.Curve.create() has been deprecated"),i.prototype=Object.create($e.prototype),i.prototype.constructor=i,i.prototype.getPoint=t,i};Jc.prototype.fromPoints=function(i){return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."),this.setFromPoints(i)};qb.prototype.setColors=function(){console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")};Xb.prototype.update=function(){console.error("THREE.SkeletonHelper: update() no longer needs to be called.")};Fe.prototype.extractUrlBase=function(i){return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."),Rb.extractUrlBase(i)};Fe.Handlers={add:function(){console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")},get:function(){console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")}};ii.prototype.center=function(i){return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."),this.getCenter(i)};ii.prototype.empty=function(){return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),this.isEmpty()};ii.prototype.isIntersectionBox=function(i){return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(i)};ii.prototype.isIntersectionSphere=function(i){return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(i)};ii.prototype.size=function(i){return console.warn("THREE.Box3: .size() has been renamed to .getSize()."),this.getSize(i)};vr.prototype.empty=function(){return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."),this.isEmpty()};po.prototype.setFromMatrix=function(i){return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."),this.setFromProjectionMatrix(i)};Ot.random16=function(){return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."),Math.random()};Ot.nearestPowerOfTwo=function(i){return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."),Ot.floorPowerOfTwo(i)};Ot.nextPowerOfTwo=function(i){return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."),Ot.ceilPowerOfTwo(i)};Se.prototype.flattenToArrayOffset=function(i,t){return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(i,t)};Se.prototype.multiplyVector3=function(i){return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."),i.applyMatrix3(this)};Se.prototype.multiplyVector3Array=function(){console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")};Se.prototype.applyToBufferAttribute=function(i){return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."),i.applyMatrix3(this)};Se.prototype.applyToVector3Array=function(){console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")};Se.prototype.getInverse=function(i){return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(i).invert()};It.prototype.extractPosition=function(i){return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."),this.copyPosition(i)};It.prototype.flattenToArrayOffset=function(i,t){return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(i,t)};It.prototype.getPosition=function(){return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."),new U().setFromMatrixColumn(this,3)};It.prototype.setRotationFromQuaternion=function(i){return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."),this.makeRotationFromQuaternion(i)};It.prototype.multiplyToArray=function(){console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")};It.prototype.multiplyVector3=function(i){return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."),i.applyMatrix4(this)};It.prototype.multiplyVector4=function(i){return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."),i.applyMatrix4(this)};It.prototype.multiplyVector3Array=function(){console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")};It.prototype.rotateAxis=function(i){console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."),i.transformDirection(this)};It.prototype.crossVector=function(i){return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."),i.applyMatrix4(this)};It.prototype.translate=function(){console.error("THREE.Matrix4: .translate() has been removed.")};It.prototype.rotateX=function(){console.error("THREE.Matrix4: .rotateX() has been removed.")};It.prototype.rotateY=function(){console.error("THREE.Matrix4: .rotateY() has been removed.")};It.prototype.rotateZ=function(){console.error("THREE.Matrix4: .rotateZ() has been removed.")};It.prototype.rotateByAxis=function(){console.error("THREE.Matrix4: .rotateByAxis() has been removed.")};It.prototype.applyToBufferAttribute=function(i){return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."),i.applyMatrix4(this)};It.prototype.applyToVector3Array=function(){console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")};It.prototype.makeFrustum=function(i,t,e,n,r,s){return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."),this.makePerspective(i,t,n,e,r,s)};It.prototype.getInverse=function(i){return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(i).invert()};Li.prototype.isIntersectionLine=function(i){return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."),this.intersectsLine(i)};Ae.prototype.multiplyVector3=function(i){return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."),i.applyQuaternion(this)};Ae.prototype.inverse=function(){return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."),this.invert()};Yn.prototype.isIntersectionBox=function(i){return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(i)};Yn.prototype.isIntersectionPlane=function(i){return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."),this.intersectsPlane(i)};Yn.prototype.isIntersectionSphere=function(i){return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(i)};ce.prototype.area=function(){return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."),this.getArea()};ce.prototype.barycoordFromPoint=function(i,t){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),this.getBarycoord(i,t)};ce.prototype.midpoint=function(i){return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."),this.getMidpoint(i)};ce.prototypenormal=function(i){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),this.getNormal(i)};ce.prototype.plane=function(i){return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."),this.getPlane(i)};ce.barycoordFromPoint=function(i,t,e,n,r){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),ce.getBarycoord(i,t,e,n,r)};ce.normal=function(i,t,e,n){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),ce.getNormal(i,t,e,n)};Qc.prototype.extractAllPoints=function(i){return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."),this.extractPoints(i)};Qc.prototype.extrude=function(i){return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."),new Ao(this,i)};Qc.prototype.makeGeometry=function(i){return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."),new QM(this,i)};lt.prototype.fromAttribute=function(i,t,e){return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(i,t,e)};lt.prototype.distanceToManhattan=function(i){return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(i)};lt.prototype.lengthManhattan=function(){return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()};U.prototype.setEulerFromRotationMatrix=function(){console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")};U.prototype.setEulerFromQuaternion=function(){console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")};U.prototype.getPositionFromMatrix=function(i){return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."),this.setFromMatrixPosition(i)};U.prototype.getScaleFromMatrix=function(i){return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."),this.setFromMatrixScale(i)};U.prototype.getColumnFromMatrix=function(i,t){return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."),this.setFromMatrixColumn(t,i)};U.prototype.applyProjection=function(i){return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."),this.applyMatrix4(i)};U.prototype.fromAttribute=function(i,t,e){return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(i,t,e)};U.prototype.distanceToManhattan=function(i){return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(i)};U.prototype.lengthManhattan=function(){return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()};Yt.prototype.fromAttribute=function(i,t,e){return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(i,t,e)};Yt.prototype.lengthManhattan=function(){return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()};Bt.prototype.getChildByName=function(i){return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."),this.getObjectByName(i)};Bt.prototype.renderDepth=function(){console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")};Bt.prototype.translate=function(i,t){return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."),this.translateOnAxis(t,i)};Bt.prototype.getWorldRotation=function(){console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")};Bt.prototype.applyMatrix=function(i){return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(i)};Object.defineProperties(Bt.prototype,{eulerOrder:{get:function(){return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order},set:function(i){console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order=i}},useQuaternion:{get:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")},set:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")}}});Te.prototype.setDrawMode=function(){console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")};Object.defineProperties(Te.prototype,{drawMode:{get:function(){return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."),Xx},set:function(){console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")}}});Ic.prototype.initBones=function(){console.error("THREE.SkinnedMesh: initBones() has been removed.")};Object.defineProperty($e.prototype,"__arcLengthDivisions",{get:function(){return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."),this.arcLengthDivisions},set:function(i){console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."),this.arcLengthDivisions=i}});We.prototype.setLens=function(i,t){console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."),t!==void 0&&(this.filmGauge=t),this.setFocalLength(i)};Object.defineProperties(Di.prototype,{onlyShadow:{set:function(){console.warn("THREE.Light: .onlyShadow has been removed.")}},shadowCameraFov:{set:function(i){console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),this.shadow.camera.fov=i}},shadowCameraLeft:{set:function(i){console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."),this.shadow.camera.left=i}},shadowCameraRight:{set:function(i){console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."),this.shadow.camera.right=i}},shadowCameraTop:{set:function(i){console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),this.shadow.camera.top=i}},shadowCameraBottom:{set:function(i){console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."),this.shadow.camera.bottom=i}},shadowCameraNear:{set:function(i){console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."),this.shadow.camera.near=i}},shadowCameraFar:{set:function(i){console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),this.shadow.camera.far=i}},shadowCameraVisible:{set:function(){console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")}},shadowBias:{set:function(i){console.warn("THREE.Light: .shadowBias is now .shadow.bias."),this.shadow.bias=i}},shadowDarkness:{set:function(){console.warn("THREE.Light: .shadowDarkness has been removed.")}},shadowMapWidth:{set:function(i){console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."),this.shadow.mapSize.width=i}},shadowMapHeight:{set:function(i){console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."),this.shadow.mapSize.height=i}}});Object.defineProperties(Gt.prototype,{length:{get:function(){return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."),this.array.length}},dynamic:{get:function(){return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.usage===Os},set:function(){console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.setUsage(Os)}}});Gt.prototype.setDynamic=function(i){return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(i===!0?Os:Bs),this};Gt.prototype.copyIndicesArray=function(){console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")},Gt.prototype.setArray=function(){console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")};$t.prototype.addIndex=function(i){console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."),this.setIndex(i)};$t.prototype.addAttribute=function(i,t){return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."),!(t&&t.isBufferAttribute)&&!(t&&t.isInterleavedBufferAttribute)?(console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),this.setAttribute(i,new Gt(arguments[1],arguments[2]))):i==="index"?(console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),this.setIndex(t),this):this.setAttribute(i,t)};$t.prototype.addDrawCall=function(i,t,e){e!==void 0&&console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."),console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),this.addGroup(i,t)};$t.prototype.clearDrawCalls=function(){console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."),this.clearGroups()};$t.prototype.computeOffsets=function(){console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")};$t.prototype.removeAttribute=function(i){return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."),this.deleteAttribute(i)};$t.prototype.applyMatrix=function(i){return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(i)};Object.defineProperties($t.prototype,{drawcalls:{get:function(){return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."),this.groups}},offsets:{get:function(){return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."),this.groups}}});Object.defineProperties(ih.prototype,{maxInstancedCount:{get:function(){return console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."),this.instanceCount},set:function(i){console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."),this.instanceCount=i}}});Object.defineProperties(sp.prototype,{linePrecision:{get:function(){return console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."),this.params.Line.threshold},set:function(i){console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."),this.params.Line.threshold=i}}});Object.defineProperties(ri.prototype,{dynamic:{get:function(){return console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."),this.usage===Os},set:function(i){console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."),this.setUsage(i)}}});ri.prototype.setDynamic=function(i){return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(i===!0?Os:Bs),this};ri.prototype.setArray=function(){console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")};Ao.prototype.getArrays=function(){console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.")};Ao.prototype.addShapeList=function(){console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.")};Ao.prototype.addShape=function(){console.error("THREE.ExtrudeGeometry: .addShape() has been removed.")};af.prototype.dispose=function(){console.error("THREE.Scene: .dispose() has been removed.")};Object.defineProperties(se.prototype,{wrapAround:{get:function(){console.warn("THREE.Material: .wrapAround has been removed.")},set:function(){console.warn("THREE.Material: .wrapAround has been removed.")}},overdraw:{get:function(){console.warn("THREE.Material: .overdraw has been removed.")},set:function(){console.warn("THREE.Material: .overdraw has been removed.")}},wrapRGB:{get:function(){return console.warn("THREE.Material: .wrapRGB has been removed."),new zt}},shading:{get:function(){console.error("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead.")},set:function(i){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=i===Vu}},stencilMask:{get:function(){return console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask},set:function(i){console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask=i}}});Object.defineProperties(Ur.prototype,{transparency:{get:function(){return console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."),this.transmission},set:function(i){console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."),this.transmission=i}}});Object.defineProperties(ni.prototype,{derivatives:{get:function(){return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives},set:function(i){console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives=i}}});jt.prototype.clearTarget=function(i,t,e,n){console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."),this.setRenderTarget(i),this.clear(t,e,n)};jt.prototype.animate=function(i){console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."),this.setAnimationLoop(i)};jt.prototype.getCurrentRenderTarget=function(){return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."),this.getRenderTarget()};jt.prototype.getMaxAnisotropy=function(){return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."),this.capabilities.getMaxAnisotropy()};jt.prototype.getPrecision=function(){return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."),this.capabilities.precision};jt.prototype.resetGLState=function(){return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."),this.state.reset()};jt.prototype.supportsFloatTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."),this.extensions.get("OES_texture_float")};jt.prototype.supportsHalfFloatTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."),this.extensions.get("OES_texture_half_float")};jt.prototype.supportsStandardDerivatives=function(){return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."),this.extensions.get("OES_standard_derivatives")};jt.prototype.supportsCompressedTextureS3TC=function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."),this.extensions.get("WEBGL_compressed_texture_s3tc")};jt.prototype.supportsCompressedTexturePVRTC=function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."),this.extensions.get("WEBGL_compressed_texture_pvrtc")};jt.prototype.supportsBlendMinMax=function(){return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."),this.extensions.get("EXT_blend_minmax")};jt.prototype.supportsVertexTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."),this.capabilities.vertexTextures};jt.prototype.supportsInstancedArrays=function(){return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."),this.extensions.get("ANGLE_instanced_arrays")};jt.prototype.enableScissorTest=function(i){console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."),this.setScissorTest(i)};jt.prototype.initMaterial=function(){console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")};jt.prototype.addPrePlugin=function(){console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")};jt.prototype.addPostPlugin=function(){console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")};jt.prototype.updateShadowMap=function(){console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")};jt.prototype.setFaceCulling=function(){console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")};jt.prototype.allocTextureUnit=function(){console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")};jt.prototype.setTexture=function(){console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")};jt.prototype.setTexture2D=function(){console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")};jt.prototype.setTextureCube=function(){console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")};jt.prototype.getActiveMipMapLevel=function(){return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."),this.getActiveMipmapLevel()};Object.defineProperties(jt.prototype,{shadowMapEnabled:{get:function(){return this.shadowMap.enabled},set:function(i){console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."),this.shadowMap.enabled=i}},shadowMapType:{get:function(){return this.shadowMap.type},set:function(i){console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."),this.shadowMap.type=i}},shadowMapCullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")}},context:{get:function(){return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."),this.getContext()}},vr:{get:function(){return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),this.xr}},gammaInput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."),!1},set:function(){console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")}},gammaOutput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),!1},set:function(i){console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),this.outputEncoding=i===!0?fd:Ns}},toneMappingWhitePoint:{get:function(){return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."),1},set:function(){console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")}}});Object.defineProperties(nf.prototype,{cullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")}},renderReverseSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")}},renderSingleSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")}}});Object.defineProperties($n.prototype,{wrapS:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS},set:function(i){console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS=i}},wrapT:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT},set:function(i){console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT=i}},magFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter},set:function(i){console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter=i}},minFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter},set:function(i){console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter=i}},anisotropy:{get:function(){return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy},set:function(i){console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy=i}},offset:{get:function(){return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset},set:function(i){console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset=i}},repeat:{get:function(){return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat},set:function(i){console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat=i}},format:{get:function(){return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format},set:function(i){console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format=i}},type:{get:function(){return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type},set:function(i){console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type=i}},generateMipmaps:{get:function(){return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps},set:function(i){console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps=i}}});Ib.prototype.load=function(i){console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");const t=this;return new Pb().load(i,function(n){t.setBuffer(n)}),this};Rc.prototype.updateCubeMap=function(i,t){return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),this.update(i,t)};Rc.prototype.clear=function(i,t,e,n){return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."),this.renderTarget.clear(i,t,e,n)};gr.crossOrigin=void 0;gr.loadTexture=function(i,t,e,n){console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");const r=new Vc;r.setCrossOrigin(this.crossOrigin);const s=r.load(i,e,void 0,n);return t&&(s.mapping=t),s};gr.loadTextureCube=function(i,t,e,n){console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");const r=new db;r.setCrossOrigin(this.crossOrigin);const s=r.load(i,e,void 0,n);return t&&(s.mapping=t),s};gr.loadCompressedTexture=function(){console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")};gr.loadCompressedTextureCube=function(){console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")};typeof __THREE_DEVTOOLS__!="undefined"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:Hu}}));typeof window!="undefined"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=Hu);var Vr=function(i,t){t===void 0&&console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.'),t===document&&console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'),this.object=i,this.domElement=t,this.enabled=!0,this.target=new U,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=.05,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.enablePan=!0,this.panSpeed=1,this.screenSpacePanning=!0,this.keyPanSpeed=7,this.autoRotate=!1,this.autoRotateSpeed=2,this.keys={LEFT:"ArrowLeft",UP:"ArrowUp",RIGHT:"ArrowRight",BOTTOM:"ArrowDown"},this.mouseButtons={LEFT:cn.ROTATE,MIDDLE:cn.DOLLY,RIGHT:cn.PAN},this.touches={ONE:hn.ROTATE,TWO:hn.DOLLY_PAN},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this._domElementKeyEvents=null,this.getPolarAngle=function(){return c.phi},this.getAzimuthalAngle=function(){return c.theta},this.listenToKeyEvents=function(C){C.addEventListener("keydown",tt),this._domElementKeyEvents=C},this.saveState=function(){e.target0.copy(e.target),e.position0.copy(e.object.position),e.zoom0=e.object.zoom},this.reset=function(){e.target.copy(e.target0),e.object.position.copy(e.position0),e.object.zoom=e.zoom0,e.object.updateProjectionMatrix(),e.dispatchEvent(n),e.update(),o=a.NONE},this.update=function(){var C=new U,q=new Ae().setFromUnitVectors(i.up,new U(0,1,0)),et=q.clone().invert(),k=new U,at=new Ae,Rt=2*Math.PI;return function(){var xe=e.object.position;C.copy(xe).sub(e.target),C.applyQuaternion(q),c.setFromVector3(C),e.autoRotate&&o===a.NONE&&N(T()),e.enableDamping?(c.theta+=h.theta*e.dampingFactor,c.phi+=h.phi*e.dampingFactor):(c.theta+=h.theta,c.phi+=h.phi);var Ft=e.minAzimuthAngle,Xt=e.maxAzimuthAngle;return isFinite(Ft)&&isFinite(Xt)&&(Ft<-Math.PI?Ft+=Rt:Ft>Math.PI&&(Ft-=Rt),Xt<-Math.PI?Xt+=Rt:Xt>Math.PI&&(Xt-=Rt),Ft<=Xt?c.theta=Math.max(Ft,Math.min(Xt,c.theta)):c.theta=c.theta>(Ft+Xt)/2?Math.max(Ft,c.theta):Math.min(Xt,c.theta)),c.phi=Math.max(e.minPolarAngle,Math.min(e.maxPolarAngle,c.phi)),c.makeSafe(),c.radius*=u,c.radius=Math.max(e.minDistance,Math.min(e.maxDistance,c.radius)),e.enableDamping===!0?e.target.addScaledVector(d,e.dampingFactor):e.target.add(d),C.setFromSpherical(c),C.applyQuaternion(et),xe.copy(e.target).add(C),e.object.lookAt(e.target),e.enableDamping===!0?(h.theta*=1-e.dampingFactor,h.phi*=1-e.dampingFactor,d.multiplyScalar(1-e.dampingFactor)):(h.set(0,0,0),d.set(0,0,0)),u=1,f||k.distanceToSquared(e.object.position)>l||8*(1-at.dot(e.object.quaternion))>l?(e.dispatchEvent(n),k.copy(e.object.position),at.copy(e.object.quaternion),f=!1,!0):!1}}(),this.dispose=function(){e.domElement.removeEventListener("contextmenu",A),e.domElement.removeEventListener("pointerdown",mt),e.domElement.removeEventListener("wheel",$),e.domElement.removeEventListener("touchstart",nt),e.domElement.removeEventListener("touchend",xt),e.domElement.removeEventListener("touchmove",Lt),e.domElement.ownerDocument.removeEventListener("pointermove",bt),e.domElement.ownerDocument.removeEventListener("pointerup",ft),e._domElementKeyEvents!==null&&e._domElementKeyEvents.removeEventListener("keydown",tt)};var e=this,n={type:"change"},r={type:"start"},s={type:"end"},a={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6},o=a.NONE,l=1e-6,c=new op,h=new op,u=1,d=new U,f=!1,p=new lt,x=new lt,y=new lt,g=new lt,m=new lt,E=new lt,w=new lt,S=new lt,_=new lt;function T(){return 2*Math.PI/60/60*e.autoRotateSpeed}function B(){return Math.pow(.95,e.zoomSpeed)}function N(C){h.theta-=C}function G(C){h.phi-=C}var D=function(){var C=new U;return function(et,k){C.setFromMatrixColumn(k,0),C.multiplyScalar(-et),d.add(C)}}(),V=function(){var C=new U;return function(et,k){e.screenSpacePanning===!0?C.setFromMatrixColumn(k,1):(C.setFromMatrixColumn(k,0),C.crossVectors(e.object.up,C)),C.multiplyScalar(et),d.add(C)}}(),R=function(){var C=new U;return function(et,k){var at=e.domElement;if(e.object.isPerspectiveCamera){var Rt=e.object.position;C.copy(Rt).sub(e.target);var Nt=C.length();Nt*=Math.tan(e.object.fov/2*Math.PI/180),D(2*et*Nt/at.clientHeight,e.object.matrix),V(2*k*Nt/at.clientHeight,e.object.matrix)}else e.object.isOrthographicCamera?(D(et*(e.object.right-e.object.left)/e.object.zoom/at.clientWidth,e.object.matrix),V(k*(e.object.top-e.object.bottom)/e.object.zoom/at.clientHeight,e.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),e.enablePan=!1)}}();function L(C){e.object.isPerspectiveCamera?u/=C:e.object.isOrthographicCamera?(e.object.zoom=Math.max(e.minZoom,Math.min(e.maxZoom,e.object.zoom*C)),e.object.updateProjectionMatrix(),f=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),e.enableZoom=!1)}function P(C){e.object.isPerspectiveCamera?u*=C:e.object.isOrthographicCamera?(e.object.zoom=Math.max(e.minZoom,Math.min(e.maxZoom,e.object.zoom/C)),e.object.updateProjectionMatrix(),f=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),e.enableZoom=!1)}function F(C){p.set(C.clientX,C.clientY)}function W(C){w.set(C.clientX,C.clientY)}function j(C){g.set(C.clientX,C.clientY)}function Y(C){x.set(C.clientX,C.clientY),y.subVectors(x,p).multiplyScalar(e.rotateSpeed);var q=e.domElement;N(2*Math.PI*y.x/q.clientHeight),G(2*Math.PI*y.y/q.clientHeight),p.copy(x),e.update()}function Q(C){S.set(C.clientX,C.clientY),_.subVectors(S,w),_.y>0?L(B()):_.y<0&&P(B()),w.copy(S),e.update()}function K(C){m.set(C.clientX,C.clientY),E.subVectors(m,g).multiplyScalar(e.panSpeed),R(E.x,E.y),g.copy(m),e.update()}function st(C){C.deltaY<0?P(B()):C.deltaY>0&&L(B()),e.update()}function ct(C){var q=!1;switch(C.code){case e.keys.UP:R(0,e.keyPanSpeed),q=!0;break;case e.keys.BOTTOM:R(0,-e.keyPanSpeed),q=!0;break;case e.keys.LEFT:R(e.keyPanSpeed,0),q=!0;break;case e.keys.RIGHT:R(-e.keyPanSpeed,0),q=!0;break}q&&(C.preventDefault(),e.update())}function z(C){if(C.touches.length==1)p.set(C.touches[0].pageX,C.touches[0].pageY);else{var q=.5*(C.touches[0].pageX+C.touches[1].pageX),et=.5*(C.touches[0].pageY+C.touches[1].pageY);p.set(q,et)}}function Et(C){if(C.touches.length==1)g.set(C.touches[0].pageX,C.touches[0].pageY);else{var q=.5*(C.touches[0].pageX+C.touches[1].pageX),et=.5*(C.touches[0].pageY+C.touches[1].pageY);g.set(q,et)}}function At(C){var q=C.touches[0].pageX-C.touches[1].pageX,et=C.touches[0].pageY-C.touches[1].pageY,k=Math.sqrt(q*q+et*et);w.set(0,k)}function yt(C){e.enableZoom&&At(C),e.enablePan&&Et(C)}function ot(C){e.enableZoom&&At(C),e.enableRotate&&z(C)}function Ct(C){if(C.touches.length==1)x.set(C.touches[0].pageX,C.touches[0].pageY);else{var q=.5*(C.touches[0].pageX+C.touches[1].pageX),et=.5*(C.touches[0].pageY+C.touches[1].pageY);x.set(q,et)}y.subVectors(x,p).multiplyScalar(e.rotateSpeed);var k=e.domElement;N(2*Math.PI*y.x/k.clientHeight),G(2*Math.PI*y.y/k.clientHeight),p.copy(x)}function Mt(C){if(C.touches.length==1)m.set(C.touches[0].pageX,C.touches[0].pageY);else{var q=.5*(C.touches[0].pageX+C.touches[1].pageX),et=.5*(C.touches[0].pageY+C.touches[1].pageY);m.set(q,et)}E.subVectors(m,g).multiplyScalar(e.panSpeed),R(E.x,E.y),g.copy(m)}function St(C){var q=C.touches[0].pageX-C.touches[1].pageX,et=C.touches[0].pageY-C.touches[1].pageY,k=Math.sqrt(q*q+et*et);S.set(0,k),_.set(0,Math.pow(S.y/w.y,e.zoomSpeed)),L(_.y),w.copy(S)}function rt(C){e.enableZoom&&St(C),e.enablePan&&Mt(C)}function dt(C){e.enableZoom&&St(C),e.enableRotate&&Ct(C)}function mt(C){if(e.enabled!==!1)switch(C.pointerType){case"mouse":case"pen":b(C);break}}function bt(C){if(e.enabled!==!1)switch(C.pointerType){case"mouse":case"pen":M(C);break}}function ft(C){switch(C.pointerType){case"mouse":case"pen":X();break}}function b(C){C.preventDefault(),e.domElement.focus?e.domElement.focus():window.focus();var q;switch(C.button){case 0:q=e.mouseButtons.LEFT;break;case 1:q=e.mouseButtons.MIDDLE;break;case 2:q=e.mouseButtons.RIGHT;break;default:q=-1}switch(q){case cn.DOLLY:if(e.enableZoom===!1)return;W(C),o=a.DOLLY;break;case cn.ROTATE:if(C.ctrlKey||C.metaKey||C.shiftKey){if(e.enablePan===!1)return;j(C),o=a.PAN}else{if(e.enableRotate===!1)return;F(C),o=a.ROTATE}break;case cn.PAN:if(C.ctrlKey||C.metaKey||C.shiftKey){if(e.enableRotate===!1)return;F(C),o=a.ROTATE}else{if(e.enablePan===!1)return;j(C),o=a.PAN}break;default:o=a.NONE}o!==a.NONE&&(e.domElement.ownerDocument.addEventListener("pointermove",bt),e.domElement.ownerDocument.addEventListener("pointerup",ft),e.dispatchEvent(r))}function M(C){if(e.enabled!==!1)switch(C.preventDefault(),o){case a.ROTATE:if(e.enableRotate===!1)return;Y(C);break;case a.DOLLY:if(e.enableZoom===!1)return;Q(C);break;case a.PAN:if(e.enablePan===!1)return;K(C);break}}function X(C){e.domElement.ownerDocument.removeEventListener("pointermove",bt),e.domElement.ownerDocument.removeEventListener("pointerup",ft),e.enabled!==!1&&(e.dispatchEvent(s),o=a.NONE)}function $(C){e.enabled===!1||e.enableZoom===!1||o!==a.NONE&&o!==a.ROTATE||(C.preventDefault(),e.dispatchEvent(r),st(C),e.dispatchEvent(s))}function tt(C){e.enabled===!1||e.enablePan===!1||ct(C)}function nt(C){if(e.enabled!==!1){switch(C.preventDefault(),C.touches.length){case 1:switch(e.touches.ONE){case hn.ROTATE:if(e.enableRotate===!1)return;z(C),o=a.TOUCH_ROTATE;break;case hn.PAN:if(e.enablePan===!1)return;Et(C),o=a.TOUCH_PAN;break;default:o=a.NONE}break;case 2:switch(e.touches.TWO){case hn.DOLLY_PAN:if(e.enableZoom===!1&&e.enablePan===!1)return;yt(C),o=a.TOUCH_DOLLY_PAN;break;case hn.DOLLY_ROTATE:if(e.enableZoom===!1&&e.enableRotate===!1)return;ot(C),o=a.TOUCH_DOLLY_ROTATE;break;default:o=a.NONE}break;default:o=a.NONE}o!==a.NONE&&e.dispatchEvent(r)}}function Lt(C){if(e.enabled!==!1)switch(C.preventDefault(),o){case a.TOUCH_ROTATE:if(e.enableRotate===!1)return;Ct(C),e.update();break;case a.TOUCH_PAN:if(e.enablePan===!1)return;Mt(C),e.update();break;case a.TOUCH_DOLLY_PAN:if(e.enableZoom===!1&&e.enablePan===!1)return;rt(C),e.update();break;case a.TOUCH_DOLLY_ROTATE:if(e.enableZoom===!1&&e.enableRotate===!1)return;dt(C),e.update();break;default:o=a.NONE}}function xt(C){e.enabled!==!1&&(e.dispatchEvent(s),o=a.NONE)}function A(C){e.enabled!==!1&&C.preventDefault()}e.domElement.addEventListener("contextmenu",A),e.domElement.addEventListener("pointerdown",mt),e.domElement.addEventListener("wheel",$),e.domElement.addEventListener("touchstart",nt),e.domElement.addEventListener("touchend",xt),e.domElement.addEventListener("touchmove",Lt),this.update()};Vr.prototype=Object.create(Ti.prototype);Vr.prototype.constructor=Vr;var oh=function(i,t){Vr.call(this,i,t),this.screenSpacePanning=!1,this.mouseButtons.LEFT=cn.PAN,this.mouseButtons.RIGHT=cn.ROTATE,this.touches.ONE=hn.PAN,this.touches.TWO=hn.DOLLY_ROTATE};oh.prototype=Object.create(Ti.prototype);oh.prototype.constructor=oh;const Zb=0,cp=1,Jb=2,hp=1,Qb=2,ha=3,No=0,Le=1,Bo=2,Kb=1,ua=0,da=1,up=2,dp=3,fp=4,tw=5,Wr=100,ew=101,iw=102,pp=103,mp=104,nw=200,rw=201,sw=202,aw=203,gp=204,xp=205,ow=206,lw=207,cw=208,hw=209,uw=210,dw=0,fw=1,pw=2,lh=3,mw=4,gw=5,xw=6,yw=7,yp=0,_w=1,vw=2,fa=0,Mw=1,bw=2,ww=3,Sw=4,Ew=5,_p=300,ch=301,hh=302,vp=303,Mp=304,uh=306,dh=307,fh=1e3,mi=1001,ph=1002,je=1003,bp=1004,wp=1005,Fi=1006,Aw=1007,mh=1008,gh=1009,Tw=1010,Lw=1011,xh=1012,Rw=1013,Oo=1014,wn=1015,Uo=1016,Cw=1017,Pw=1018,Dw=1019,Ho=1020,Fw=1021,pa=1022,Ii=1023,Iw=1024,zw=1025,yh=1026,_h=1027,Nw=1028,Bw=1029,Ow=1030,Uw=1031,Hw=1032,Gw=1033,Sp=33776,Ep=33777,Ap=33778,Tp=33779,Lp=35840,Rp=35841,Cp=35842,Pp=35843,kw=36196,Dp=37492,Fp=37496,Vw=37808,Ww=37809,$w=37810,Xw=37811,qw=37812,Yw=37813,jw=37814,Zw=37815,Jw=37816,Qw=37817,Kw=37818,tS=37819,eS=37820,iS=37821,nS=36492,rS=37840,sS=37841,aS=37842,oS=37843,lS=37844,cS=37845,hS=37846,uS=37847,dS=37848,fS=37849,pS=37850,mS=37851,gS=37852,xS=37853,Go=3e3,yS=3001,_S=3007,vS=3002,MS=3003,bS=3004,wS=3005,SS=3006,ES=3200,AS=3201,TS=0,LS=1,vh=7680,RS=519,Ip=35044,zp="300 es",Re=[];for(let i=0;i<256;i++)Re[i]=(i<16?"0":"")+i.toString(16);let ko=1234567;const Zt={DEG2RAD:Math.PI/180,RAD2DEG:180/Math.PI,generateUUID:function(){const i=Math.random()*4294967295|0,t=Math.random()*4294967295|0,e=Math.random()*4294967295|0,n=Math.random()*4294967295|0;return(Re[i&255]+Re[i>>8&255]+Re[i>>16&255]+Re[i>>24&255]+"-"+Re[t&255]+Re[t>>8&255]+"-"+Re[t>>16&15|64]+Re[t>>24&255]+"-"+Re[e&63|128]+Re[e>>8&255]+"-"+Re[e>>16&255]+Re[e>>24&255]+Re[n&255]+Re[n>>8&255]+Re[n>>16&255]+Re[n>>24&255]).toUpperCase()},clamp:function(i,t,e){return Math.max(t,Math.min(e,i))},euclideanModulo:function(i,t){return(i%t+t)%t},mapLinear:function(i,t,e,n,r){return n+(i-t)*(r-n)/(e-t)},inverseLerp:function(i,t,e){return i!==t?(e-i)/(t-i):0},lerp:function(i,t,e){return(1-e)*i+e*t},damp:function(i,t,e,n){return Zt.lerp(i,t,1-Math.exp(-e*n))},pingpong:function(i,t=1){return t-Math.abs(Zt.euclideanModulo(i,t*2)-t)},smoothstep:function(i,t,e){return i<=t?0:i>=e?1:(i=(i-t)/(e-t),i*i*(3-2*i))},smootherstep:function(i,t,e){return i<=t?0:i>=e?1:(i=(i-t)/(e-t),i*i*i*(i*(i*6-15)+10))},randInt:function(i,t){return i+Math.floor(Math.random()*(t-i+1))},randFloat:function(i,t){return i+Math.random()*(t-i)},randFloatSpread:function(i){return i*(.5-Math.random())},seededRandom:function(i){return i!==void 0&&(ko=i%2147483647),ko=ko*16807%2147483647,(ko-1)/2147483646},degToRad:function(i){return i*Zt.DEG2RAD},radToDeg:function(i){return i*Zt.RAD2DEG},isPowerOfTwo:function(i){return(i&i-1)==0&&i!==0},ceilPowerOfTwo:function(i){return Math.pow(2,Math.ceil(Math.log(i)/Math.LN2))},floorPowerOfTwo:function(i){return Math.pow(2,Math.floor(Math.log(i)/Math.LN2))},setQuaternionFromProperEuler:function(i,t,e,n,r){const s=Math.cos,a=Math.sin,o=s(e/2),l=a(e/2),c=s((t+n)/2),h=a((t+n)/2),u=s((t-n)/2),d=a((t-n)/2),f=s((n-t)/2),p=a((n-t)/2);switch(r){case"XYX":i.set(o*h,l*u,l*d,o*c);break;case"YZY":i.set(l*d,o*h,l*u,o*c);break;case"ZXZ":i.set(l*u,l*d,o*h,o*c);break;case"XZX":i.set(o*h,l*p,l*f,o*c);break;case"YXY":i.set(l*f,o*h,l*p,o*c);break;case"ZYZ":i.set(l*p,l*f,o*h,o*c);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+r)}}};function Zn(){}Object.assign(Zn.prototype,{addEventListener:function(i,t){this._listeners===void 0&&(this._listeners={});const e=this._listeners;e[i]===void 0&&(e[i]=[]),e[i].indexOf(t)===-1&&e[i].push(t)},hasEventListener:function(i,t){if(this._listeners===void 0)return!1;const e=this._listeners;return e[i]!==void 0&&e[i].indexOf(t)!==-1},removeEventListener:function(i,t){if(this._listeners===void 0)return;const n=this._listeners[i];if(n!==void 0){const r=n.indexOf(t);r!==-1&&n.splice(r,1)}},dispatchEvent:function(i){if(this._listeners===void 0)return;const e=this._listeners[i.type];if(e!==void 0){i.target=this;const n=e.slice(0);for(let r=0,s=n.length;r<s;r++)n[r].call(this,i);i.target=null}}});class ee{constructor(t=0,e=0){this.x=t,this.y=e}get width(){return this.x}set width(t){this.x=t}get height(){return this.y}set height(t){this.y=t}set(t,e){return this.x=t,this.y=e,this}setScalar(t){return this.x=t,this.y=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y)}copy(t){return this.x=t.x,this.y=t.y,this}add(t,e){return e!==void 0?(console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this)}addScalar(t){return this.x+=t,this.y+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this}sub(t,e){return e!==void 0?(console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this)}subScalar(t){return this.x-=t,this.y-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this}multiply(t){return this.x*=t.x,this.y*=t.y,this}multiplyScalar(t){return this.x*=t,this.y*=t,this}divide(t){return this.x/=t.x,this.y/=t.y,this}divideScalar(t){return this.multiplyScalar(1/t)}applyMatrix3(t){const e=this.x,n=this.y,r=t.elements;return this.x=r[0]*e+r[3]*n+r[6],this.y=r[1]*e+r[4]*n+r[7],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,n=this.y-t.y;return e*e+n*n}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this}equals(t){return t.x===this.x&&t.y===this.y}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t}fromBufferAttribute(t,e,n){return n!==void 0&&console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this}rotateAround(t,e){const n=Math.cos(e),r=Math.sin(e),s=this.x-t.x,a=this.y-t.y;return this.x=s*n-a*r+t.x,this.y=s*r+a*n+t.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}}ee.prototype.isVector2=!0;class gi{constructor(){this.elements=[1,0,0,0,1,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")}set(t,e,n,r,s,a,o,l,c){const h=this.elements;return h[0]=t,h[1]=r,h[2]=o,h[3]=e,h[4]=s,h[5]=l,h[6]=n,h[7]=a,h[8]=c,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(t){const e=this.elements,n=t.elements;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],this}extractBasis(t,e,n){return t.setFromMatrix3Column(this,0),e.setFromMatrix3Column(this,1),n.setFromMatrix3Column(this,2),this}setFromMatrix4(t){const e=t.elements;return this.set(e[0],e[4],e[8],e[1],e[5],e[9],e[2],e[6],e[10]),this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const n=t.elements,r=e.elements,s=this.elements,a=n[0],o=n[3],l=n[6],c=n[1],h=n[4],u=n[7],d=n[2],f=n[5],p=n[8],x=r[0],y=r[3],g=r[6],m=r[1],E=r[4],w=r[7],S=r[2],_=r[5],T=r[8];return s[0]=a*x+o*m+l*S,s[3]=a*y+o*E+l*_,s[6]=a*g+o*w+l*T,s[1]=c*x+h*m+u*S,s[4]=c*y+h*E+u*_,s[7]=c*g+h*w+u*T,s[2]=d*x+f*m+p*S,s[5]=d*y+f*E+p*_,s[8]=d*g+f*w+p*T,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[3]*=t,e[6]*=t,e[1]*=t,e[4]*=t,e[7]*=t,e[2]*=t,e[5]*=t,e[8]*=t,this}determinant(){const t=this.elements,e=t[0],n=t[1],r=t[2],s=t[3],a=t[4],o=t[5],l=t[6],c=t[7],h=t[8];return e*a*h-e*o*c-n*s*h+n*o*l+r*s*c-r*a*l}invert(){const t=this.elements,e=t[0],n=t[1],r=t[2],s=t[3],a=t[4],o=t[5],l=t[6],c=t[7],h=t[8],u=h*a-o*c,d=o*l-h*s,f=c*s-a*l,p=e*u+n*d+r*f;if(p===0)return this.set(0,0,0,0,0,0,0,0,0);const x=1/p;return t[0]=u*x,t[1]=(r*c-h*n)*x,t[2]=(o*n-r*a)*x,t[3]=d*x,t[4]=(h*e-r*l)*x,t[5]=(r*s-o*e)*x,t[6]=f*x,t[7]=(n*l-c*e)*x,t[8]=(a*e-n*s)*x,this}transpose(){let t;const e=this.elements;return t=e[1],e[1]=e[3],e[3]=t,t=e[2],e[2]=e[6],e[6]=t,t=e[5],e[5]=e[7],e[7]=t,this}getNormalMatrix(t){return this.setFromMatrix4(t).invert().transpose()}transposeIntoArray(t){const e=this.elements;return t[0]=e[0],t[1]=e[3],t[2]=e[6],t[3]=e[1],t[4]=e[4],t[5]=e[7],t[6]=e[2],t[7]=e[5],t[8]=e[8],this}setUvTransform(t,e,n,r,s,a,o){const l=Math.cos(s),c=Math.sin(s);return this.set(n*l,n*c,-n*(l*a+c*o)+a+t,-r*c,r*l,-r*(-c*a+l*o)+o+e,0,0,1),this}scale(t,e){const n=this.elements;return n[0]*=t,n[3]*=t,n[6]*=t,n[1]*=e,n[4]*=e,n[7]*=e,this}rotate(t){const e=Math.cos(t),n=Math.sin(t),r=this.elements,s=r[0],a=r[3],o=r[6],l=r[1],c=r[4],h=r[7];return r[0]=e*s+n*l,r[3]=e*a+n*c,r[6]=e*o+n*h,r[1]=-n*s+e*l,r[4]=-n*a+e*c,r[7]=-n*o+e*h,this}translate(t,e){const n=this.elements;return n[0]+=t*n[2],n[3]+=t*n[5],n[6]+=t*n[8],n[1]+=e*n[2],n[4]+=e*n[5],n[7]+=e*n[8],this}equals(t){const e=this.elements,n=t.elements;for(let r=0;r<9;r++)if(e[r]!==n[r])return!1;return!0}fromArray(t,e=0){for(let n=0;n<9;n++)this.elements[n]=t[n+e];return this}toArray(t=[],e=0){const n=this.elements;return t[e]=n[0],t[e+1]=n[1],t[e+2]=n[2],t[e+3]=n[3],t[e+4]=n[4],t[e+5]=n[5],t[e+6]=n[6],t[e+7]=n[7],t[e+8]=n[8],t}clone(){return new this.constructor().fromArray(this.elements)}}gi.prototype.isMatrix3=!0;let $r;const CS={getDataURL:function(i){if(/^data:/i.test(i.src)||typeof HTMLCanvasElement=="undefined")return i.src;let t;if(i instanceof HTMLCanvasElement)t=i;else{$r===void 0&&($r=document.createElementNS("http://www.w3.org/1999/xhtml","canvas")),$r.width=i.width,$r.height=i.height;const e=$r.getContext("2d");i instanceof ImageData?e.putImageData(i,0,0):e.drawImage(i,0,0,i.width,i.height),t=$r}return t.width>2048||t.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",i),t.toDataURL("image/jpeg",.6)):t.toDataURL("image/png")}};let PS=0;class oi extends Zn{constructor(t=oi.DEFAULT_IMAGE,e=oi.DEFAULT_MAPPING,n=mi,r=mi,s=Fi,a=mh,o=Ii,l=gh,c=1,h=Go){super();Object.defineProperty(this,"id",{value:PS++}),this.uuid=Zt.generateUUID(),this.name="",this.image=t,this.mipmaps=[],this.mapping=e,this.wrapS=n,this.wrapT=r,this.magFilter=s,this.minFilter=a,this.anisotropy=c,this.format=o,this.internalFormat=null,this.type=l,this.offset=new ee(0,0),this.repeat=new ee(1,1),this.center=new ee(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new gi,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.encoding=h,this.version=0,this.onUpdate=null}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(t){return this.name=t.name,this.image=t.image,this.mipmaps=t.mipmaps.slice(0),this.mapping=t.mapping,this.wrapS=t.wrapS,this.wrapT=t.wrapT,this.magFilter=t.magFilter,this.minFilter=t.minFilter,this.anisotropy=t.anisotropy,this.format=t.format,this.internalFormat=t.internalFormat,this.type=t.type,this.offset.copy(t.offset),this.repeat.copy(t.repeat),this.center.copy(t.center),this.rotation=t.rotation,this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrix.copy(t.matrix),this.generateMipmaps=t.generateMipmaps,this.premultiplyAlpha=t.premultiplyAlpha,this.flipY=t.flipY,this.unpackAlignment=t.unpackAlignment,this.encoding=t.encoding,this}toJSON(t){const e=t===void 0||typeof t=="string";if(!e&&t.textures[this.uuid]!==void 0)return t.textures[this.uuid];const n={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};if(this.image!==void 0){const r=this.image;if(r.uuid===void 0&&(r.uuid=Zt.generateUUID()),!e&&t.images[r.uuid]===void 0){let s;if(Array.isArray(r)){s=[];for(let a=0,o=r.length;a<o;a++)r[a].isDataTexture?s.push(Mh(r[a].image)):s.push(Mh(r[a]))}else s=Mh(r);t.images[r.uuid]={uuid:r.uuid,url:s}}n.image=r.uuid}return e||(t.textures[this.uuid]=n),n}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(t){if(this.mapping!==_p)return t;if(t.applyMatrix3(this.matrix),t.x<0||t.x>1)switch(this.wrapS){case fh:t.x=t.x-Math.floor(t.x);break;case mi:t.x=t.x<0?0:1;break;case ph:Math.abs(Math.floor(t.x)%2)===1?t.x=Math.ceil(t.x)-t.x:t.x=t.x-Math.floor(t.x);break}if(t.y<0||t.y>1)switch(this.wrapT){case fh:t.y=t.y-Math.floor(t.y);break;case mi:t.y=t.y<0?0:1;break;case ph:Math.abs(Math.floor(t.y)%2)===1?t.y=Math.ceil(t.y)-t.y:t.y=t.y-Math.floor(t.y);break}return this.flipY&&(t.y=1-t.y),t}set needsUpdate(t){t===!0&&this.version++}}oi.DEFAULT_IMAGE=void 0;oi.DEFAULT_MAPPING=_p;oi.prototype.isTexture=!0;function Mh(i){return typeof HTMLImageElement!="undefined"&&i instanceof HTMLImageElement||typeof HTMLCanvasElement!="undefined"&&i instanceof HTMLCanvasElement||typeof ImageBitmap!="undefined"&&i instanceof ImageBitmap?CS.getDataURL(i):i.data?{data:Array.prototype.slice.call(i.data),width:i.width,height:i.height,type:i.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}class Np extends oi{constructor(t,e,n,r,s,a,o,l,c,h,u,d){super(null,a,o,l,c,h,r,s,u,d);this.image={data:t||null,width:e||1,height:n||1},this.magFilter=c!==void 0?c:je,this.minFilter=h!==void 0?h:je,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}}Np.prototype.isDataTexture=!0;class Jn{constructor(t=0,e=0,n=0,r=1){this._x=t,this._y=e,this._z=n,this._w=r}static slerp(t,e,n,r){return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."),n.slerpQuaternions(t,e,r)}static slerpFlat(t,e,n,r,s,a,o){let l=n[r+0],c=n[r+1],h=n[r+2],u=n[r+3];const d=s[a+0],f=s[a+1],p=s[a+2],x=s[a+3];if(o===0){t[e+0]=l,t[e+1]=c,t[e+2]=h,t[e+3]=u;return}if(o===1){t[e+0]=d,t[e+1]=f,t[e+2]=p,t[e+3]=x;return}if(u!==x||l!==d||c!==f||h!==p){let y=1-o;const g=l*d+c*f+h*p+u*x,m=g>=0?1:-1,E=1-g*g;if(E>Number.EPSILON){const S=Math.sqrt(E),_=Math.atan2(S,g*m);y=Math.sin(y*_)/S,o=Math.sin(o*_)/S}const w=o*m;if(l=l*y+d*w,c=c*y+f*w,h=h*y+p*w,u=u*y+x*w,y===1-o){const S=1/Math.sqrt(l*l+c*c+h*h+u*u);l*=S,c*=S,h*=S,u*=S}}t[e]=l,t[e+1]=c,t[e+2]=h,t[e+3]=u}static multiplyQuaternionsFlat(t,e,n,r,s,a){const o=n[r],l=n[r+1],c=n[r+2],h=n[r+3],u=s[a],d=s[a+1],f=s[a+2],p=s[a+3];return t[e]=o*p+h*u+l*f-c*d,t[e+1]=l*p+h*d+c*u-o*f,t[e+2]=c*p+h*f+o*d-l*u,t[e+3]=h*p-o*u-l*d-c*f,t}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get w(){return this._w}set w(t){this._w=t,this._onChangeCallback()}set(t,e,n,r){return this._x=t,this._y=e,this._z=n,this._w=r,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(t){return this._x=t.x,this._y=t.y,this._z=t.z,this._w=t.w,this._onChangeCallback(),this}setFromEuler(t,e){if(!(t&&t.isEuler))throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");const n=t._x,r=t._y,s=t._z,a=t._order,o=Math.cos,l=Math.sin,c=o(n/2),h=o(r/2),u=o(s/2),d=l(n/2),f=l(r/2),p=l(s/2);switch(a){case"XYZ":this._x=d*h*u+c*f*p,this._y=c*f*u-d*h*p,this._z=c*h*p+d*f*u,this._w=c*h*u-d*f*p;break;case"YXZ":this._x=d*h*u+c*f*p,this._y=c*f*u-d*h*p,this._z=c*h*p-d*f*u,this._w=c*h*u+d*f*p;break;case"ZXY":this._x=d*h*u-c*f*p,this._y=c*f*u+d*h*p,this._z=c*h*p+d*f*u,this._w=c*h*u-d*f*p;break;case"ZYX":this._x=d*h*u-c*f*p,this._y=c*f*u+d*h*p,this._z=c*h*p-d*f*u,this._w=c*h*u+d*f*p;break;case"YZX":this._x=d*h*u+c*f*p,this._y=c*f*u+d*h*p,this._z=c*h*p-d*f*u,this._w=c*h*u-d*f*p;break;case"XZY":this._x=d*h*u-c*f*p,this._y=c*f*u-d*h*p,this._z=c*h*p+d*f*u,this._w=c*h*u+d*f*p;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+a)}return e!==!1&&this._onChangeCallback(),this}setFromAxisAngle(t,e){const n=e/2,r=Math.sin(n);return this._x=t.x*r,this._y=t.y*r,this._z=t.z*r,this._w=Math.cos(n),this._onChangeCallback(),this}setFromRotationMatrix(t){const e=t.elements,n=e[0],r=e[4],s=e[8],a=e[1],o=e[5],l=e[9],c=e[2],h=e[6],u=e[10],d=n+o+u;if(d>0){const f=.5/Math.sqrt(d+1);this._w=.25/f,this._x=(h-l)*f,this._y=(s-c)*f,this._z=(a-r)*f}else if(n>o&&n>u){const f=2*Math.sqrt(1+n-o-u);this._w=(h-l)/f,this._x=.25*f,this._y=(r+a)/f,this._z=(s+c)/f}else if(o>u){const f=2*Math.sqrt(1+o-n-u);this._w=(s-c)/f,this._x=(r+a)/f,this._y=.25*f,this._z=(l+h)/f}else{const f=2*Math.sqrt(1+u-n-o);this._w=(a-r)/f,this._x=(s+c)/f,this._y=(l+h)/f,this._z=.25*f}return this._onChangeCallback(),this}setFromUnitVectors(t,e){let n=t.dot(e)+1;return n<Number.EPSILON?(n=0,Math.abs(t.x)>Math.abs(t.z)?(this._x=-t.y,this._y=t.x,this._z=0,this._w=n):(this._x=0,this._y=-t.z,this._z=t.y,this._w=n)):(this._x=t.y*e.z-t.z*e.y,this._y=t.z*e.x-t.x*e.z,this._z=t.x*e.y-t.y*e.x,this._w=n),this.normalize()}angleTo(t){return 2*Math.acos(Math.abs(Zt.clamp(this.dot(t),-1,1)))}rotateTowards(t,e){const n=this.angleTo(t);if(n===0)return this;const r=Math.min(1,e/n);return this.slerp(t,r),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(t){return this._x*t._x+this._y*t._y+this._z*t._z+this._w*t._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let t=this.length();return t===0?(this._x=0,this._y=0,this._z=0,this._w=1):(t=1/t,this._x=this._x*t,this._y=this._y*t,this._z=this._z*t,this._w=this._w*t),this._onChangeCallback(),this}multiply(t,e){return e!==void 0?(console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),this.multiplyQuaternions(t,e)):this.multiplyQuaternions(this,t)}premultiply(t){return this.multiplyQuaternions(t,this)}multiplyQuaternions(t,e){const n=t._x,r=t._y,s=t._z,a=t._w,o=e._x,l=e._y,c=e._z,h=e._w;return this._x=n*h+a*o+r*c-s*l,this._y=r*h+a*l+s*o-n*c,this._z=s*h+a*c+n*l-r*o,this._w=a*h-n*o-r*l-s*c,this._onChangeCallback(),this}slerp(t,e){if(e===0)return this;if(e===1)return this.copy(t);const n=this._x,r=this._y,s=this._z,a=this._w;let o=a*t._w+n*t._x+r*t._y+s*t._z;if(o<0?(this._w=-t._w,this._x=-t._x,this._y=-t._y,this._z=-t._z,o=-o):this.copy(t),o>=1)return this._w=a,this._x=n,this._y=r,this._z=s,this;const l=1-o*o;if(l<=Number.EPSILON){const f=1-e;return this._w=f*a+e*this._w,this._x=f*n+e*this._x,this._y=f*r+e*this._y,this._z=f*s+e*this._z,this.normalize(),this._onChangeCallback(),this}const c=Math.sqrt(l),h=Math.atan2(c,o),u=Math.sin((1-e)*h)/c,d=Math.sin(e*h)/c;return this._w=a*u+this._w*d,this._x=n*u+this._x*d,this._y=r*u+this._y*d,this._z=s*u+this._z*d,this._onChangeCallback(),this}slerpQuaternions(t,e,n){this.copy(t).slerp(e,n)}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._w===this._w}fromArray(t,e=0){return this._x=t[e],this._y=t[e+1],this._z=t[e+2],this._w=t[e+3],this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._w,t}fromBufferAttribute(t,e){return this._x=t.getX(e),this._y=t.getY(e),this._z=t.getZ(e),this._w=t.getW(e),this}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}}Jn.prototype.isQuaternion=!0;class Z{constructor(t=0,e=0,n=0){this.x=t,this.y=e,this.z=n}set(t,e,n){return n===void 0&&(n=this.z),this.x=t,this.y=e,this.z=n,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}add(t,e){return e!==void 0?(console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this.z+=t.z,this)}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this}sub(t,e){return e!==void 0?(console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this.z-=t.z,this)}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this}multiply(t,e){return e!==void 0?(console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(t,e)):(this.x*=t.x,this.y*=t.y,this.z*=t.z,this)}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}multiplyVectors(t,e){return this.x=t.x*e.x,this.y=t.y*e.y,this.z=t.z*e.z,this}applyEuler(t){return t&&t.isEuler||console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),this.applyQuaternion(Bp.setFromEuler(t))}applyAxisAngle(t,e){return this.applyQuaternion(Bp.setFromAxisAngle(t,e))}applyMatrix3(t){const e=this.x,n=this.y,r=this.z,s=t.elements;return this.x=s[0]*e+s[3]*n+s[6]*r,this.y=s[1]*e+s[4]*n+s[7]*r,this.z=s[2]*e+s[5]*n+s[8]*r,this}applyNormalMatrix(t){return this.applyMatrix3(t).normalize()}applyMatrix4(t){const e=this.x,n=this.y,r=this.z,s=t.elements,a=1/(s[3]*e+s[7]*n+s[11]*r+s[15]);return this.x=(s[0]*e+s[4]*n+s[8]*r+s[12])*a,this.y=(s[1]*e+s[5]*n+s[9]*r+s[13])*a,this.z=(s[2]*e+s[6]*n+s[10]*r+s[14])*a,this}applyQuaternion(t){const e=this.x,n=this.y,r=this.z,s=t.x,a=t.y,o=t.z,l=t.w,c=l*e+a*r-o*n,h=l*n+o*e-s*r,u=l*r+s*n-a*e,d=-s*e-a*n-o*r;return this.x=c*l+d*-s+h*-o-u*-a,this.y=h*l+d*-a+u*-s-c*-o,this.z=u*l+d*-o+c*-a-h*-s,this}project(t){return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)}unproject(t){return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)}transformDirection(t){const e=this.x,n=this.y,r=this.z,s=t.elements;return this.x=s[0]*e+s[4]*n+s[8]*r,this.y=s[1]*e+s[5]*n+s[9]*r,this.z=s[2]*e+s[6]*n+s[10]*r,this.normalize()}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this}divideScalar(t){return this.multiplyScalar(1/t)}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this.z=t.z+(e.z-t.z)*n,this}cross(t,e){return e!==void 0?(console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(t,e)):this.crossVectors(this,t)}crossVectors(t,e){const n=t.x,r=t.y,s=t.z,a=e.x,o=e.y,l=e.z;return this.x=r*l-s*o,this.y=s*a-n*l,this.z=n*o-r*a,this}projectOnVector(t){const e=t.lengthSq();if(e===0)return this.set(0,0,0);const n=t.dot(this)/e;return this.copy(t).multiplyScalar(n)}projectOnPlane(t){return bh.copy(this).projectOnVector(t),this.sub(bh)}reflect(t){return this.sub(bh.copy(t).multiplyScalar(2*this.dot(t)))}angleTo(t){const e=Math.sqrt(this.lengthSq()*t.lengthSq());if(e===0)return Math.PI/2;const n=this.dot(t)/e;return Math.acos(Zt.clamp(n,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,n=this.y-t.y,r=this.z-t.z;return e*e+n*n+r*r}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)+Math.abs(this.z-t.z)}setFromSpherical(t){return this.setFromSphericalCoords(t.radius,t.phi,t.theta)}setFromSphericalCoords(t,e,n){const r=Math.sin(e)*t;return this.x=r*Math.sin(n),this.y=Math.cos(e)*t,this.z=r*Math.cos(n),this}setFromCylindrical(t){return this.setFromCylindricalCoords(t.radius,t.theta,t.y)}setFromCylindricalCoords(t,e,n){return this.x=t*Math.sin(e),this.y=n,this.z=t*Math.cos(e),this}setFromMatrixPosition(t){const e=t.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this}setFromMatrixScale(t){const e=this.setFromMatrixColumn(t,0).length(),n=this.setFromMatrixColumn(t,1).length(),r=this.setFromMatrixColumn(t,2).length();return this.x=e,this.y=n,this.z=r,this}setFromMatrixColumn(t,e){return this.fromArray(t.elements,e*4)}setFromMatrix3Column(t,e){return this.fromArray(t.elements,e*3)}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t}fromBufferAttribute(t,e,n){return n!==void 0&&console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}}Z.prototype.isVector3=!0;const bh=new Z,Bp=new Jn;class Qn{constructor(t=new Z(1/0,1/0,1/0),e=new Z(-1/0,-1/0,-1/0)){this.min=t,this.max=e}set(t,e){return this.min.copy(t),this.max.copy(e),this}setFromArray(t){let e=1/0,n=1/0,r=1/0,s=-1/0,a=-1/0,o=-1/0;for(let l=0,c=t.length;l<c;l+=3){const h=t[l],u=t[l+1],d=t[l+2];h<e&&(e=h),u<n&&(n=u),d<r&&(r=d),h>s&&(s=h),u>a&&(a=u),d>o&&(o=d)}return this.min.set(e,n,r),this.max.set(s,a,o),this}setFromBufferAttribute(t){let e=1/0,n=1/0,r=1/0,s=-1/0,a=-1/0,o=-1/0;for(let l=0,c=t.count;l<c;l++){const h=t.getX(l),u=t.getY(l),d=t.getZ(l);h<e&&(e=h),u<n&&(n=u),d<r&&(r=d),h>s&&(s=h),u>a&&(a=u),d>o&&(o=d)}return this.min.set(e,n,r),this.max.set(s,a,o),this}setFromPoints(t){this.makeEmpty();for(let e=0,n=t.length;e<n;e++)this.expandByPoint(t[e]);return this}setFromCenterAndSize(t,e){const n=ma.copy(e).multiplyScalar(.5);return this.min.copy(t).sub(n),this.max.copy(t).add(n),this}setFromObject(t){return this.makeEmpty(),this.expandByObject(t)}clone(){return new this.constructor().copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(t){return t===void 0&&(console.warn("THREE.Box3: .getCenter() target is now required"),t=new Z),this.isEmpty()?t.set(0,0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return t===void 0&&(console.warn("THREE.Box3: .getSize() target is now required"),t=new Z),this.isEmpty()?t.set(0,0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}expandByObject(t){t.updateWorldMatrix(!1,!1);const e=t.geometry;e!==void 0&&(e.boundingBox===null&&e.computeBoundingBox(),wh.copy(e.boundingBox),wh.applyMatrix4(t.matrixWorld),this.union(wh));const n=t.children;for(let r=0,s=n.length;r<s;r++)this.expandByObject(n[r]);return this}containsPoint(t){return!(t.x<this.min.x||t.x>this.max.x||t.y<this.min.y||t.y>this.max.y||t.z<this.min.z||t.z>this.max.z)}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y&&this.min.z<=t.min.z&&t.max.z<=this.max.z}getParameter(t,e){return e===void 0&&(console.warn("THREE.Box3: .getParameter() target is now required"),e=new Z),e.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y),(t.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(t){return!(t.max.x<this.min.x||t.min.x>this.max.x||t.max.y<this.min.y||t.min.y>this.max.y||t.max.z<this.min.z||t.min.z>this.max.z)}intersectsSphere(t){return this.clampPoint(t.center,ma),ma.distanceToSquared(t.center)<=t.radius*t.radius}intersectsPlane(t){let e,n;return t.normal.x>0?(e=t.normal.x*this.min.x,n=t.normal.x*this.max.x):(e=t.normal.x*this.max.x,n=t.normal.x*this.min.x),t.normal.y>0?(e+=t.normal.y*this.min.y,n+=t.normal.y*this.max.y):(e+=t.normal.y*this.max.y,n+=t.normal.y*this.min.y),t.normal.z>0?(e+=t.normal.z*this.min.z,n+=t.normal.z*this.max.z):(e+=t.normal.z*this.max.z,n+=t.normal.z*this.min.z),e<=-t.constant&&n>=-t.constant}intersectsTriangle(t){if(this.isEmpty())return!1;this.getCenter(ga),Vo.subVectors(this.max,ga),Xr.subVectors(t.a,ga),qr.subVectors(t.b,ga),Yr.subVectors(t.c,ga),Sn.subVectors(qr,Xr),En.subVectors(Yr,qr),Kn.subVectors(Xr,Yr);let e=[0,-Sn.z,Sn.y,0,-En.z,En.y,0,-Kn.z,Kn.y,Sn.z,0,-Sn.x,En.z,0,-En.x,Kn.z,0,-Kn.x,-Sn.y,Sn.x,0,-En.y,En.x,0,-Kn.y,Kn.x,0];return!Sh(e,Xr,qr,Yr,Vo)||(e=[1,0,0,0,1,0,0,0,1],!Sh(e,Xr,qr,Yr,Vo))?!1:(Wo.crossVectors(Sn,En),e=[Wo.x,Wo.y,Wo.z],Sh(e,Xr,qr,Yr,Vo))}clampPoint(t,e){return e===void 0&&(console.warn("THREE.Box3: .clampPoint() target is now required"),e=new Z),e.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return ma.copy(t).clamp(this.min,this.max).sub(t).length()}getBoundingSphere(t){return t===void 0&&console.error("THREE.Box3: .getBoundingSphere() target is now required"),this.getCenter(t.center),t.radius=this.getSize(ma).length()*.5,t}intersect(t){return this.min.max(t.min),this.max.min(t.max),this.isEmpty()&&this.makeEmpty(),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}applyMatrix4(t){return this.isEmpty()?this:($i[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(t),$i[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(t),$i[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(t),$i[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(t),$i[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(t),$i[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(t),$i[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(t),$i[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(t),this.setFromPoints($i),this)}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}}Qn.prototype.isBox3=!0;const $i=[new Z,new Z,new Z,new Z,new Z,new Z,new Z,new Z],ma=new Z,wh=new Qn,Xr=new Z,qr=new Z,Yr=new Z,Sn=new Z,En=new Z,Kn=new Z,ga=new Z,Vo=new Z,Wo=new Z,tr=new Z;function Sh(i,t,e,n,r){for(let s=0,a=i.length-3;s<=a;s+=3){tr.fromArray(i,s);const o=r.x*Math.abs(tr.x)+r.y*Math.abs(tr.y)+r.z*Math.abs(tr.z),l=t.dot(tr),c=e.dot(tr),h=n.dot(tr);if(Math.max(-Math.max(l,c,h),Math.min(l,c,h))>o)return!1}return!0}const DS=new Qn,Op=new Z,Eh=new Z,Ah=new Z;class Th{constructor(t=new Z,e=-1){this.center=t,this.radius=e}set(t,e){return this.center.copy(t),this.radius=e,this}setFromPoints(t,e){const n=this.center;e!==void 0?n.copy(e):DS.setFromPoints(t).getCenter(n);let r=0;for(let s=0,a=t.length;s<a;s++)r=Math.max(r,n.distanceToSquared(t[s]));return this.radius=Math.sqrt(r),this}copy(t){return this.center.copy(t.center),this.radius=t.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(t){return t.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(t){return t.distanceTo(this.center)-this.radius}intersectsSphere(t){const e=this.radius+t.radius;return t.center.distanceToSquared(this.center)<=e*e}intersectsBox(t){return t.intersectsSphere(this)}intersectsPlane(t){return Math.abs(t.distanceToPoint(this.center))<=this.radius}clampPoint(t,e){const n=this.center.distanceToSquared(t);return e===void 0&&(console.warn("THREE.Sphere: .clampPoint() target is now required"),e=new Z),e.copy(t),n>this.radius*this.radius&&(e.sub(this.center).normalize(),e.multiplyScalar(this.radius).add(this.center)),e}getBoundingBox(t){return t===void 0&&(console.warn("THREE.Sphere: .getBoundingBox() target is now required"),t=new Qn),this.isEmpty()?(t.makeEmpty(),t):(t.set(this.center,this.center),t.expandByScalar(this.radius),t)}applyMatrix4(t){return this.center.applyMatrix4(t),this.radius=this.radius*t.getMaxScaleOnAxis(),this}translate(t){return this.center.add(t),this}expandByPoint(t){Ah.subVectors(t,this.center);const e=Ah.lengthSq();if(e>this.radius*this.radius){const n=Math.sqrt(e),r=(n-this.radius)*.5;this.center.add(Ah.multiplyScalar(r/n)),this.radius+=r}return this}union(t){return Eh.subVectors(t.center,this.center).normalize().multiplyScalar(t.radius),this.expandByPoint(Op.copy(t.center).add(Eh)),this.expandByPoint(Op.copy(t.center).sub(Eh)),this}equals(t){return t.center.equals(this.center)&&t.radius===this.radius}clone(){return new this.constructor().copy(this)}}const Lh=new Z,FS=new Z,IS=new gi;class Xi{constructor(t=new Z(1,0,0),e=0){this.normal=t,this.constant=e}set(t,e){return this.normal.copy(t),this.constant=e,this}setComponents(t,e,n,r){return this.normal.set(t,e,n),this.constant=r,this}setFromNormalAndCoplanarPoint(t,e){return this.normal.copy(t),this.constant=-e.dot(this.normal),this}setFromCoplanarPoints(t,e,n){const r=Lh.subVectors(n,e).cross(FS.subVectors(t,e)).normalize();return this.setFromNormalAndCoplanarPoint(r,t),this}copy(t){return this.normal.copy(t.normal),this.constant=t.constant,this}normalize(){const t=1/this.normal.length();return this.normal.multiplyScalar(t),this.constant*=t,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(t){return this.normal.dot(t)+this.constant}distanceToSphere(t){return this.distanceToPoint(t.center)-t.radius}projectPoint(t,e){return e===void 0&&(console.warn("THREE.Plane: .projectPoint() target is now required"),e=new Z),e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)}intersectLine(t,e){e===void 0&&(console.warn("THREE.Plane: .intersectLine() target is now required"),e=new Z);const n=t.delta(Lh),r=this.normal.dot(n);if(r===0)return this.distanceToPoint(t.start)===0?e.copy(t.start):null;const s=-(t.start.dot(this.normal)+this.constant)/r;return s<0||s>1?null:e.copy(n).multiplyScalar(s).add(t.start)}intersectsLine(t){const e=this.distanceToPoint(t.start),n=this.distanceToPoint(t.end);return e<0&&n>0||n<0&&e>0}intersectsBox(t){return t.intersectsPlane(this)}intersectsSphere(t){return t.intersectsPlane(this)}coplanarPoint(t){return t===void 0&&(console.warn("THREE.Plane: .coplanarPoint() target is now required"),t=new Z),t.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(t,e){const n=e||IS.getNormalMatrix(t),r=this.coplanarPoint(Lh).applyMatrix4(t),s=this.normal.applyMatrix3(n).normalize();return this.constant=-r.dot(s),this}translate(t){return this.constant-=t.dot(this.normal),this}equals(t){return t.normal.equals(this.normal)&&t.constant===this.constant}clone(){return new this.constructor().copy(this)}}Xi.prototype.isPlane=!0;const jr=new Th,$o=new Z;class Up{constructor(t=new Xi,e=new Xi,n=new Xi,r=new Xi,s=new Xi,a=new Xi){this.planes=[t,e,n,r,s,a]}set(t,e,n,r,s,a){const o=this.planes;return o[0].copy(t),o[1].copy(e),o[2].copy(n),o[3].copy(r),o[4].copy(s),o[5].copy(a),this}copy(t){const e=this.planes;for(let n=0;n<6;n++)e[n].copy(t.planes[n]);return this}setFromProjectionMatrix(t){const e=this.planes,n=t.elements,r=n[0],s=n[1],a=n[2],o=n[3],l=n[4],c=n[5],h=n[6],u=n[7],d=n[8],f=n[9],p=n[10],x=n[11],y=n[12],g=n[13],m=n[14],E=n[15];return e[0].setComponents(o-r,u-l,x-d,E-y).normalize(),e[1].setComponents(o+r,u+l,x+d,E+y).normalize(),e[2].setComponents(o+s,u+c,x+f,E+g).normalize(),e[3].setComponents(o-s,u-c,x-f,E-g).normalize(),e[4].setComponents(o-a,u-h,x-p,E-m).normalize(),e[5].setComponents(o+a,u+h,x+p,E+m).normalize(),this}intersectsObject(t){const e=t.geometry;return e.boundingSphere===null&&e.computeBoundingSphere(),jr.copy(e.boundingSphere).applyMatrix4(t.matrixWorld),this.intersectsSphere(jr)}intersectsSprite(t){return jr.center.set(0,0,0),jr.radius=.7071067811865476,jr.applyMatrix4(t.matrixWorld),this.intersectsSphere(jr)}intersectsSphere(t){const e=this.planes,n=t.center,r=-t.radius;for(let s=0;s<6;s++)if(e[s].distanceToPoint(n)<r)return!1;return!0}intersectsBox(t){const e=this.planes;for(let n=0;n<6;n++){const r=e[n];if($o.x=r.normal.x>0?t.max.x:t.min.x,$o.y=r.normal.y>0?t.max.y:t.min.y,$o.z=r.normal.z>0?t.max.z:t.min.z,r.distanceToPoint($o)<0)return!1}return!0}containsPoint(t){const e=this.planes;for(let n=0;n<6;n++)if(e[n].distanceToPoint(t)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}}class Ce{constructor(){this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")}set(t,e,n,r,s,a,o,l,c,h,u,d,f,p,x,y){const g=this.elements;return g[0]=t,g[4]=e,g[8]=n,g[12]=r,g[1]=s,g[5]=a,g[9]=o,g[13]=l,g[2]=c,g[6]=h,g[10]=u,g[14]=d,g[3]=f,g[7]=p,g[11]=x,g[15]=y,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new Ce().fromArray(this.elements)}copy(t){const e=this.elements,n=t.elements;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],e[9]=n[9],e[10]=n[10],e[11]=n[11],e[12]=n[12],e[13]=n[13],e[14]=n[14],e[15]=n[15],this}copyPosition(t){const e=this.elements,n=t.elements;return e[12]=n[12],e[13]=n[13],e[14]=n[14],this}setFromMatrix3(t){const e=t.elements;return this.set(e[0],e[3],e[6],0,e[1],e[4],e[7],0,e[2],e[5],e[8],0,0,0,0,1),this}extractBasis(t,e,n){return t.setFromMatrixColumn(this,0),e.setFromMatrixColumn(this,1),n.setFromMatrixColumn(this,2),this}makeBasis(t,e,n){return this.set(t.x,e.x,n.x,0,t.y,e.y,n.y,0,t.z,e.z,n.z,0,0,0,0,1),this}extractRotation(t){const e=this.elements,n=t.elements,r=1/Zr.setFromMatrixColumn(t,0).length(),s=1/Zr.setFromMatrixColumn(t,1).length(),a=1/Zr.setFromMatrixColumn(t,2).length();return e[0]=n[0]*r,e[1]=n[1]*r,e[2]=n[2]*r,e[3]=0,e[4]=n[4]*s,e[5]=n[5]*s,e[6]=n[6]*s,e[7]=0,e[8]=n[8]*a,e[9]=n[9]*a,e[10]=n[10]*a,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromEuler(t){t&&t.isEuler||console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");const e=this.elements,n=t.x,r=t.y,s=t.z,a=Math.cos(n),o=Math.sin(n),l=Math.cos(r),c=Math.sin(r),h=Math.cos(s),u=Math.sin(s);if(t.order==="XYZ"){const d=a*h,f=a*u,p=o*h,x=o*u;e[0]=l*h,e[4]=-l*u,e[8]=c,e[1]=f+p*c,e[5]=d-x*c,e[9]=-o*l,e[2]=x-d*c,e[6]=p+f*c,e[10]=a*l}else if(t.order==="YXZ"){const d=l*h,f=l*u,p=c*h,x=c*u;e[0]=d+x*o,e[4]=p*o-f,e[8]=a*c,e[1]=a*u,e[5]=a*h,e[9]=-o,e[2]=f*o-p,e[6]=x+d*o,e[10]=a*l}else if(t.order==="ZXY"){const d=l*h,f=l*u,p=c*h,x=c*u;e[0]=d-x*o,e[4]=-a*u,e[8]=p+f*o,e[1]=f+p*o,e[5]=a*h,e[9]=x-d*o,e[2]=-a*c,e[6]=o,e[10]=a*l}else if(t.order==="ZYX"){const d=a*h,f=a*u,p=o*h,x=o*u;e[0]=l*h,e[4]=p*c-f,e[8]=d*c+x,e[1]=l*u,e[5]=x*c+d,e[9]=f*c-p,e[2]=-c,e[6]=o*l,e[10]=a*l}else if(t.order==="YZX"){const d=a*l,f=a*c,p=o*l,x=o*c;e[0]=l*h,e[4]=x-d*u,e[8]=p*u+f,e[1]=u,e[5]=a*h,e[9]=-o*h,e[2]=-c*h,e[6]=f*u+p,e[10]=d-x*u}else if(t.order==="XZY"){const d=a*l,f=a*c,p=o*l,x=o*c;e[0]=l*h,e[4]=-u,e[8]=c*h,e[1]=d*u+x,e[5]=a*h,e[9]=f*u-p,e[2]=p*u-f,e[6]=o*h,e[10]=x*u+d}return e[3]=0,e[7]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromQuaternion(t){return this.compose(zS,t,NS)}lookAt(t,e,n){const r=this.elements;return Ze.subVectors(t,e),Ze.lengthSq()===0&&(Ze.z=1),Ze.normalize(),An.crossVectors(n,Ze),An.lengthSq()===0&&(Math.abs(n.z)===1?Ze.x+=1e-4:Ze.z+=1e-4,Ze.normalize(),An.crossVectors(n,Ze)),An.normalize(),Xo.crossVectors(Ze,An),r[0]=An.x,r[4]=Xo.x,r[8]=Ze.x,r[1]=An.y,r[5]=Xo.y,r[9]=Ze.y,r[2]=An.z,r[6]=Xo.z,r[10]=Ze.z,this}multiply(t,e){return e!==void 0?(console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),this.multiplyMatrices(t,e)):this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const n=t.elements,r=e.elements,s=this.elements,a=n[0],o=n[4],l=n[8],c=n[12],h=n[1],u=n[5],d=n[9],f=n[13],p=n[2],x=n[6],y=n[10],g=n[14],m=n[3],E=n[7],w=n[11],S=n[15],_=r[0],T=r[4],B=r[8],N=r[12],G=r[1],D=r[5],V=r[9],R=r[13],L=r[2],P=r[6],F=r[10],W=r[14],j=r[3],Y=r[7],Q=r[11],K=r[15];return s[0]=a*_+o*G+l*L+c*j,s[4]=a*T+o*D+l*P+c*Y,s[8]=a*B+o*V+l*F+c*Q,s[12]=a*N+o*R+l*W+c*K,s[1]=h*_+u*G+d*L+f*j,s[5]=h*T+u*D+d*P+f*Y,s[9]=h*B+u*V+d*F+f*Q,s[13]=h*N+u*R+d*W+f*K,s[2]=p*_+x*G+y*L+g*j,s[6]=p*T+x*D+y*P+g*Y,s[10]=p*B+x*V+y*F+g*Q,s[14]=p*N+x*R+y*W+g*K,s[3]=m*_+E*G+w*L+S*j,s[7]=m*T+E*D+w*P+S*Y,s[11]=m*B+E*V+w*F+S*Q,s[15]=m*N+E*R+w*W+S*K,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[4]*=t,e[8]*=t,e[12]*=t,e[1]*=t,e[5]*=t,e[9]*=t,e[13]*=t,e[2]*=t,e[6]*=t,e[10]*=t,e[14]*=t,e[3]*=t,e[7]*=t,e[11]*=t,e[15]*=t,this}determinant(){const t=this.elements,e=t[0],n=t[4],r=t[8],s=t[12],a=t[1],o=t[5],l=t[9],c=t[13],h=t[2],u=t[6],d=t[10],f=t[14],p=t[3],x=t[7],y=t[11],g=t[15];return p*(+s*l*u-r*c*u-s*o*d+n*c*d+r*o*f-n*l*f)+x*(+e*l*f-e*c*d+s*a*d-r*a*f+r*c*h-s*l*h)+y*(+e*c*u-e*o*f-s*a*u+n*a*f+s*o*h-n*c*h)+g*(-r*o*h-e*l*u+e*o*d+r*a*u-n*a*d+n*l*h)}transpose(){const t=this.elements;let e;return e=t[1],t[1]=t[4],t[4]=e,e=t[2],t[2]=t[8],t[8]=e,e=t[6],t[6]=t[9],t[9]=e,e=t[3],t[3]=t[12],t[12]=e,e=t[7],t[7]=t[13],t[13]=e,e=t[11],t[11]=t[14],t[14]=e,this}setPosition(t,e,n){const r=this.elements;return t.isVector3?(r[12]=t.x,r[13]=t.y,r[14]=t.z):(r[12]=t,r[13]=e,r[14]=n),this}invert(){const t=this.elements,e=t[0],n=t[1],r=t[2],s=t[3],a=t[4],o=t[5],l=t[6],c=t[7],h=t[8],u=t[9],d=t[10],f=t[11],p=t[12],x=t[13],y=t[14],g=t[15],m=u*y*c-x*d*c+x*l*f-o*y*f-u*l*g+o*d*g,E=p*d*c-h*y*c-p*l*f+a*y*f+h*l*g-a*d*g,w=h*x*c-p*u*c+p*o*f-a*x*f-h*o*g+a*u*g,S=p*u*l-h*x*l-p*o*d+a*x*d+h*o*y-a*u*y,_=e*m+n*E+r*w+s*S;if(_===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const T=1/_;return t[0]=m*T,t[1]=(x*d*s-u*y*s-x*r*f+n*y*f+u*r*g-n*d*g)*T,t[2]=(o*y*s-x*l*s+x*r*c-n*y*c-o*r*g+n*l*g)*T,t[3]=(u*l*s-o*d*s-u*r*c+n*d*c+o*r*f-n*l*f)*T,t[4]=E*T,t[5]=(h*y*s-p*d*s+p*r*f-e*y*f-h*r*g+e*d*g)*T,t[6]=(p*l*s-a*y*s-p*r*c+e*y*c+a*r*g-e*l*g)*T,t[7]=(a*d*s-h*l*s+h*r*c-e*d*c-a*r*f+e*l*f)*T,t[8]=w*T,t[9]=(p*u*s-h*x*s-p*n*f+e*x*f+h*n*g-e*u*g)*T,t[10]=(a*x*s-p*o*s+p*n*c-e*x*c-a*n*g+e*o*g)*T,t[11]=(h*o*s-a*u*s-h*n*c+e*u*c+a*n*f-e*o*f)*T,t[12]=S*T,t[13]=(h*x*r-p*u*r+p*n*d-e*x*d-h*n*y+e*u*y)*T,t[14]=(p*o*r-a*x*r-p*n*l+e*x*l+a*n*y-e*o*y)*T,t[15]=(a*u*r-h*o*r+h*n*l-e*u*l-a*n*d+e*o*d)*T,this}scale(t){const e=this.elements,n=t.x,r=t.y,s=t.z;return e[0]*=n,e[4]*=r,e[8]*=s,e[1]*=n,e[5]*=r,e[9]*=s,e[2]*=n,e[6]*=r,e[10]*=s,e[3]*=n,e[7]*=r,e[11]*=s,this}getMaxScaleOnAxis(){const t=this.elements,e=t[0]*t[0]+t[1]*t[1]+t[2]*t[2],n=t[4]*t[4]+t[5]*t[5]+t[6]*t[6],r=t[8]*t[8]+t[9]*t[9]+t[10]*t[10];return Math.sqrt(Math.max(e,n,r))}makeTranslation(t,e,n){return this.set(1,0,0,t,0,1,0,e,0,0,1,n,0,0,0,1),this}makeRotationX(t){const e=Math.cos(t),n=Math.sin(t);return this.set(1,0,0,0,0,e,-n,0,0,n,e,0,0,0,0,1),this}makeRotationY(t){const e=Math.cos(t),n=Math.sin(t);return this.set(e,0,n,0,0,1,0,0,-n,0,e,0,0,0,0,1),this}makeRotationZ(t){const e=Math.cos(t),n=Math.sin(t);return this.set(e,-n,0,0,n,e,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(t,e){const n=Math.cos(e),r=Math.sin(e),s=1-n,a=t.x,o=t.y,l=t.z,c=s*a,h=s*o;return this.set(c*a+n,c*o-r*l,c*l+r*o,0,c*o+r*l,h*o+n,h*l-r*a,0,c*l-r*o,h*l+r*a,s*l*l+n,0,0,0,0,1),this}makeScale(t,e,n){return this.set(t,0,0,0,0,e,0,0,0,0,n,0,0,0,0,1),this}makeShear(t,e,n){return this.set(1,e,n,0,t,1,n,0,t,e,1,0,0,0,0,1),this}compose(t,e,n){const r=this.elements,s=e._x,a=e._y,o=e._z,l=e._w,c=s+s,h=a+a,u=o+o,d=s*c,f=s*h,p=s*u,x=a*h,y=a*u,g=o*u,m=l*c,E=l*h,w=l*u,S=n.x,_=n.y,T=n.z;return r[0]=(1-(x+g))*S,r[1]=(f+w)*S,r[2]=(p-E)*S,r[3]=0,r[4]=(f-w)*_,r[5]=(1-(d+g))*_,r[6]=(y+m)*_,r[7]=0,r[8]=(p+E)*T,r[9]=(y-m)*T,r[10]=(1-(d+x))*T,r[11]=0,r[12]=t.x,r[13]=t.y,r[14]=t.z,r[15]=1,this}decompose(t,e,n){const r=this.elements;let s=Zr.set(r[0],r[1],r[2]).length();const a=Zr.set(r[4],r[5],r[6]).length(),o=Zr.set(r[8],r[9],r[10]).length();this.determinant()<0&&(s=-s),t.x=r[12],t.y=r[13],t.z=r[14],xi.copy(this);const c=1/s,h=1/a,u=1/o;return xi.elements[0]*=c,xi.elements[1]*=c,xi.elements[2]*=c,xi.elements[4]*=h,xi.elements[5]*=h,xi.elements[6]*=h,xi.elements[8]*=u,xi.elements[9]*=u,xi.elements[10]*=u,e.setFromRotationMatrix(xi),n.x=s,n.y=a,n.z=o,this}makePerspective(t,e,n,r,s,a){a===void 0&&console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");const o=this.elements,l=2*s/(e-t),c=2*s/(n-r),h=(e+t)/(e-t),u=(n+r)/(n-r),d=-(a+s)/(a-s),f=-2*a*s/(a-s);return o[0]=l,o[4]=0,o[8]=h,o[12]=0,o[1]=0,o[5]=c,o[9]=u,o[13]=0,o[2]=0,o[6]=0,o[10]=d,o[14]=f,o[3]=0,o[7]=0,o[11]=-1,o[15]=0,this}makeOrthographic(t,e,n,r,s,a){const o=this.elements,l=1/(e-t),c=1/(n-r),h=1/(a-s),u=(e+t)*l,d=(n+r)*c,f=(a+s)*h;return o[0]=2*l,o[4]=0,o[8]=0,o[12]=-u,o[1]=0,o[5]=2*c,o[9]=0,o[13]=-d,o[2]=0,o[6]=0,o[10]=-2*h,o[14]=-f,o[3]=0,o[7]=0,o[11]=0,o[15]=1,this}equals(t){const e=this.elements,n=t.elements;for(let r=0;r<16;r++)if(e[r]!==n[r])return!1;return!0}fromArray(t,e=0){for(let n=0;n<16;n++)this.elements[n]=t[n+e];return this}toArray(t=[],e=0){const n=this.elements;return t[e]=n[0],t[e+1]=n[1],t[e+2]=n[2],t[e+3]=n[3],t[e+4]=n[4],t[e+5]=n[5],t[e+6]=n[6],t[e+7]=n[7],t[e+8]=n[8],t[e+9]=n[9],t[e+10]=n[10],t[e+11]=n[11],t[e+12]=n[12],t[e+13]=n[13],t[e+14]=n[14],t[e+15]=n[15],t}}Ce.prototype.isMatrix4=!0;const Zr=new Z,xi=new Ce,zS=new Z(0,0,0),NS=new Z(1,1,1),An=new Z,Xo=new Z,Ze=new Z;class Ie{constructor(t=0,e=0,n=0,r=1){this.x=t,this.y=e,this.z=n,this.w=r}get width(){return this.z}set width(t){this.z=t}get height(){return this.w}set height(t){this.w=t}set(t,e,n,r){return this.x=t,this.y=e,this.z=n,this.w=r,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this.w=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setW(t){return this.w=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;case 3:this.w=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=t.w!==void 0?t.w:1,this}add(t,e){return e!==void 0?(console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this.z+=t.z,this.w+=t.w,this)}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this.w+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this.w=t.w+e.w,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this.w+=t.w*e,this}sub(t,e){return e!==void 0?(console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this.z-=t.z,this.w-=t.w,this)}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this.w-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this.w=t.w-e.w,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this.w*=t.w,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this.w*=t,this}applyMatrix4(t){const e=this.x,n=this.y,r=this.z,s=this.w,a=t.elements;return this.x=a[0]*e+a[4]*n+a[8]*r+a[12]*s,this.y=a[1]*e+a[5]*n+a[9]*r+a[13]*s,this.z=a[2]*e+a[6]*n+a[10]*r+a[14]*s,this.w=a[3]*e+a[7]*n+a[11]*r+a[15]*s,this}divideScalar(t){return this.multiplyScalar(1/t)}setAxisAngleFromQuaternion(t){this.w=2*Math.acos(t.w);const e=Math.sqrt(1-t.w*t.w);return e<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=t.x/e,this.y=t.y/e,this.z=t.z/e),this}setAxisAngleFromRotationMatrix(t){let e,n,r,s;const a=.01,o=.1,l=t.elements,c=l[0],h=l[4],u=l[8],d=l[1],f=l[5],p=l[9],x=l[2],y=l[6],g=l[10];if(Math.abs(h-d)<a&&Math.abs(u-x)<a&&Math.abs(p-y)<a){if(Math.abs(h+d)<o&&Math.abs(u+x)<o&&Math.abs(p+y)<o&&Math.abs(c+f+g-3)<o)return this.set(1,0,0,0),this;e=Math.PI;const E=(c+1)/2,w=(f+1)/2,S=(g+1)/2,_=(h+d)/4,T=(u+x)/4,B=(p+y)/4;return E>w&&E>S?E<a?(n=0,r=.707106781,s=.707106781):(n=Math.sqrt(E),r=_/n,s=T/n):w>S?w<a?(n=.707106781,r=0,s=.707106781):(r=Math.sqrt(w),n=_/r,s=B/r):S<a?(n=.707106781,r=.707106781,s=0):(s=Math.sqrt(S),n=T/s,r=B/s),this.set(n,r,s,e),this}let m=Math.sqrt((y-p)*(y-p)+(u-x)*(u-x)+(d-h)*(d-h));return Math.abs(m)<.001&&(m=1),this.x=(y-p)/m,this.y=(u-x)/m,this.z=(d-h)/m,this.w=Math.acos((c+f+g-1)/2),this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this.w=Math.min(this.w,t.w),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this.w=Math.max(this.w,t.w),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this.w=Math.max(t.w,Math.min(e.w,this.w)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this.w=Math.max(t,Math.min(e,this.w)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this.w+=(t.w-this.w)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this.z=t.z+(e.z-t.z)*n,this.w=t.w+(e.w-t.w)*n,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z&&t.w===this.w}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this.w=t[e+3],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t[e+3]=this.w,t}fromBufferAttribute(t,e,n){return n!==void 0&&console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this.w=t.getW(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}}Ie.prototype.isVector4=!0;const Hp={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},yi={h:0,s:0,l:0},qo={h:0,s:0,l:0};function Rh(i,t,e){return e<0&&(e+=1),e>1&&(e-=1),e<1/6?i+(t-i)*6*e:e<1/2?t:e<2/3?i+(t-i)*6*(2/3-e):i}function Ch(i){return i<.04045?i*.0773993808:Math.pow(i*.9478672986+.0521327014,2.4)}function Ph(i){return i<.0031308?i*12.92:1.055*Math.pow(i,.41666)-.055}class Jt{constructor(t,e,n){return e===void 0&&n===void 0?this.set(t):this.setRGB(t,e,n)}set(t){return t&&t.isColor?this.copy(t):typeof t=="number"?this.setHex(t):typeof t=="string"&&this.setStyle(t),this}setScalar(t){return this.r=t,this.g=t,this.b=t,this}setHex(t){return t=Math.floor(t),this.r=(t>>16&255)/255,this.g=(t>>8&255)/255,this.b=(t&255)/255,this}setRGB(t,e,n){return this.r=t,this.g=e,this.b=n,this}setHSL(t,e,n){if(t=Zt.euclideanModulo(t,1),e=Zt.clamp(e,0,1),n=Zt.clamp(n,0,1),e===0)this.r=this.g=this.b=n;else{const r=n<=.5?n*(1+e):n+e-n*e,s=2*n-r;this.r=Rh(s,r,t+1/3),this.g=Rh(s,r,t),this.b=Rh(s,r,t-1/3)}return this}setStyle(t){function e(r){r!==void 0&&parseFloat(r)<1&&console.warn("THREE.Color: Alpha component of "+t+" will be ignored.")}let n;if(n=/^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t)){let r;const s=n[1],a=n[2];switch(s){case"rgb":case"rgba":if(r=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return this.r=Math.min(255,parseInt(r[1],10))/255,this.g=Math.min(255,parseInt(r[2],10))/255,this.b=Math.min(255,parseInt(r[3],10))/255,e(r[4]),this;if(r=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return this.r=Math.min(100,parseInt(r[1],10))/100,this.g=Math.min(100,parseInt(r[2],10))/100,this.b=Math.min(100,parseInt(r[3],10))/100,e(r[4]),this;break;case"hsl":case"hsla":if(r=/^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)){const o=parseFloat(r[1])/360,l=parseInt(r[2],10)/100,c=parseInt(r[3],10)/100;return e(r[4]),this.setHSL(o,l,c)}break}}else if(n=/^\#([A-Fa-f\d]+)$/.exec(t)){const r=n[1],s=r.length;if(s===3)return this.r=parseInt(r.charAt(0)+r.charAt(0),16)/255,this.g=parseInt(r.charAt(1)+r.charAt(1),16)/255,this.b=parseInt(r.charAt(2)+r.charAt(2),16)/255,this;if(s===6)return this.r=parseInt(r.charAt(0)+r.charAt(1),16)/255,this.g=parseInt(r.charAt(2)+r.charAt(3),16)/255,this.b=parseInt(r.charAt(4)+r.charAt(5),16)/255,this}return t&&t.length>0?this.setColorName(t):this}setColorName(t){const e=Hp[t];return e!==void 0?this.setHex(e):console.warn("THREE.Color: Unknown color "+t),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(t){return this.r=t.r,this.g=t.g,this.b=t.b,this}copyGammaToLinear(t,e=2){return this.r=Math.pow(t.r,e),this.g=Math.pow(t.g,e),this.b=Math.pow(t.b,e),this}copyLinearToGamma(t,e=2){const n=e>0?1/e:1;return this.r=Math.pow(t.r,n),this.g=Math.pow(t.g,n),this.b=Math.pow(t.b,n),this}convertGammaToLinear(t){return this.copyGammaToLinear(this,t),this}convertLinearToGamma(t){return this.copyLinearToGamma(this,t),this}copySRGBToLinear(t){return this.r=Ch(t.r),this.g=Ch(t.g),this.b=Ch(t.b),this}copyLinearToSRGB(t){return this.r=Ph(t.r),this.g=Ph(t.g),this.b=Ph(t.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(){return this.r*255<<16^this.g*255<<8^this.b*255<<0}getHexString(){return("000000"+this.getHex().toString(16)).slice(-6)}getHSL(t){t===void 0&&(console.warn("THREE.Color: .getHSL() target is now required"),t={h:0,s:0,l:0});const e=this.r,n=this.g,r=this.b,s=Math.max(e,n,r),a=Math.min(e,n,r);let o,l;const c=(a+s)/2;if(a===s)o=0,l=0;else{const h=s-a;switch(l=c<=.5?h/(s+a):h/(2-s-a),s){case e:o=(n-r)/h+(n<r?6:0);break;case n:o=(r-e)/h+2;break;case r:o=(e-n)/h+4;break}o/=6}return t.h=o,t.s=l,t.l=c,t}getStyle(){return"rgb("+(this.r*255|0)+","+(this.g*255|0)+","+(this.b*255|0)+")"}offsetHSL(t,e,n){return this.getHSL(yi),yi.h+=t,yi.s+=e,yi.l+=n,this.setHSL(yi.h,yi.s,yi.l),this}add(t){return this.r+=t.r,this.g+=t.g,this.b+=t.b,this}addColors(t,e){return this.r=t.r+e.r,this.g=t.g+e.g,this.b=t.b+e.b,this}addScalar(t){return this.r+=t,this.g+=t,this.b+=t,this}sub(t){return this.r=Math.max(0,this.r-t.r),this.g=Math.max(0,this.g-t.g),this.b=Math.max(0,this.b-t.b),this}multiply(t){return this.r*=t.r,this.g*=t.g,this.b*=t.b,this}multiplyScalar(t){return this.r*=t,this.g*=t,this.b*=t,this}lerp(t,e){return this.r+=(t.r-this.r)*e,this.g+=(t.g-this.g)*e,this.b+=(t.b-this.b)*e,this}lerpColors(t,e,n){return this.r=t.r+(e.r-t.r)*n,this.g=t.g+(e.g-t.g)*n,this.b=t.b+(e.b-t.b)*n,this}lerpHSL(t,e){this.getHSL(yi),t.getHSL(qo);const n=Zt.lerp(yi.h,qo.h,e),r=Zt.lerp(yi.s,qo.s,e),s=Zt.lerp(yi.l,qo.l,e);return this.setHSL(n,r,s),this}equals(t){return t.r===this.r&&t.g===this.g&&t.b===this.b}fromArray(t,e=0){return this.r=t[e],this.g=t[e+1],this.b=t[e+2],this}toArray(t=[],e=0){return t[e]=this.r,t[e+1]=this.g,t[e+2]=this.b,t}fromBufferAttribute(t,e){return this.r=t.getX(e),this.g=t.getY(e),this.b=t.getZ(e),t.normalized===!0&&(this.r/=255,this.g/=255,this.b/=255),this}toJSON(){return this.getHex()}}Jt.NAMES=Hp;Jt.prototype.isColor=!0;Jt.prototype.r=1;Jt.prototype.g=1;Jt.prototype.b=1;function Gp(){let i=null,t=!1,e=null,n=null;function r(s,a){e(s,a),n=i.requestAnimationFrame(r)}return{start:function(){t!==!0&&e!==null&&(n=i.requestAnimationFrame(r),t=!0)},stop:function(){i.cancelAnimationFrame(n),t=!1},setAnimationLoop:function(s){e=s},setContext:function(s){i=s}}}function BS(i,t){const e=t.isWebGL2,n=new WeakMap;function r(c,h){const u=c.array,d=c.usage,f=i.createBuffer();i.bindBuffer(h,f),i.bufferData(h,u,d),c.onUploadCallback();let p=i.FLOAT;return u instanceof Float32Array?p=i.FLOAT:u instanceof Float64Array?console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."):u instanceof Uint16Array?c.isFloat16BufferAttribute?e?p=i.HALF_FLOAT:console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."):p=i.UNSIGNED_SHORT:u instanceof Int16Array?p=i.SHORT:u instanceof Uint32Array?p=i.UNSIGNED_INT:u instanceof Int32Array?p=i.INT:u instanceof Int8Array?p=i.BYTE:u instanceof Uint8Array&&(p=i.UNSIGNED_BYTE),{buffer:f,type:p,bytesPerElement:u.BYTES_PER_ELEMENT,version:c.version}}function s(c,h,u){const d=h.array,f=h.updateRange;i.bindBuffer(u,c),f.count===-1?i.bufferSubData(u,0,d):(e?i.bufferSubData(u,f.offset*d.BYTES_PER_ELEMENT,d,f.offset,f.count):i.bufferSubData(u,f.offset*d.BYTES_PER_ELEMENT,d.subarray(f.offset,f.offset+f.count)),f.count=-1)}function a(c){return c.isInterleavedBufferAttribute&&(c=c.data),n.get(c)}function o(c){c.isInterleavedBufferAttribute&&(c=c.data);const h=n.get(c);h&&(i.deleteBuffer(h.buffer),n.delete(c))}function l(c,h){if(c.isGLBufferAttribute){const d=n.get(c);(!d||d.version<c.version)&&n.set(c,{buffer:c.buffer,type:c.type,bytesPerElement:c.elementSize,version:c.version});return}c.isInterleavedBufferAttribute&&(c=c.data);const u=n.get(c);u===void 0?n.set(c,r(c,h)):u.version<c.version&&(s(u.buffer,c,h),u.version=c.version)}return{get:a,remove:o,update:l}}const Kt=new Z,Yo=new ee;function te(i,t,e){if(Array.isArray(i))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.name="",this.array=i,this.itemSize=t,this.count=i!==void 0?i.length/t:0,this.normalized=e===!0,this.usage=Ip,this.updateRange={offset:0,count:-1},this.version=0}Object.defineProperty(te.prototype,"needsUpdate",{set:function(i){i===!0&&this.version++}});Object.assign(te.prototype,{isBufferAttribute:!0,onUploadCallback:function(){},setUsage:function(i){return this.usage=i,this},copy:function(i){return this.name=i.name,this.array=new i.array.constructor(i.array),this.itemSize=i.itemSize,this.count=i.count,this.normalized=i.normalized,this.usage=i.usage,this},copyAt:function(i,t,e){i*=this.itemSize,e*=t.itemSize;for(let n=0,r=this.itemSize;n<r;n++)this.array[i+n]=t.array[e+n];return this},copyArray:function(i){return this.array.set(i),this},copyColorsArray:function(i){const t=this.array;let e=0;for(let n=0,r=i.length;n<r;n++){let s=i[n];s===void 0&&(console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined",n),s=new Jt),t[e++]=s.r,t[e++]=s.g,t[e++]=s.b}return this},copyVector2sArray:function(i){const t=this.array;let e=0;for(let n=0,r=i.length;n<r;n++){let s=i[n];s===void 0&&(console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined",n),s=new ee),t[e++]=s.x,t[e++]=s.y}return this},copyVector3sArray:function(i){const t=this.array;let e=0;for(let n=0,r=i.length;n<r;n++){let s=i[n];s===void 0&&(console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined",n),s=new Z),t[e++]=s.x,t[e++]=s.y,t[e++]=s.z}return this},copyVector4sArray:function(i){const t=this.array;let e=0;for(let n=0,r=i.length;n<r;n++){let s=i[n];s===void 0&&(console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined",n),s=new Ie),t[e++]=s.x,t[e++]=s.y,t[e++]=s.z,t[e++]=s.w}return this},applyMatrix3:function(i){if(this.itemSize===2)for(let t=0,e=this.count;t<e;t++)Yo.fromBufferAttribute(this,t),Yo.applyMatrix3(i),this.setXY(t,Yo.x,Yo.y);else if(this.itemSize===3)for(let t=0,e=this.count;t<e;t++)Kt.fromBufferAttribute(this,t),Kt.applyMatrix3(i),this.setXYZ(t,Kt.x,Kt.y,Kt.z);return this},applyMatrix4:function(i){for(let t=0,e=this.count;t<e;t++)Kt.x=this.getX(t),Kt.y=this.getY(t),Kt.z=this.getZ(t),Kt.applyMatrix4(i),this.setXYZ(t,Kt.x,Kt.y,Kt.z);return this},applyNormalMatrix:function(i){for(let t=0,e=this.count;t<e;t++)Kt.x=this.getX(t),Kt.y=this.getY(t),Kt.z=this.getZ(t),Kt.applyNormalMatrix(i),this.setXYZ(t,Kt.x,Kt.y,Kt.z);return this},transformDirection:function(i){for(let t=0,e=this.count;t<e;t++)Kt.x=this.getX(t),Kt.y=this.getY(t),Kt.z=this.getZ(t),Kt.transformDirection(i),this.setXYZ(t,Kt.x,Kt.y,Kt.z);return this},set:function(i,t=0){return this.array.set(i,t),this},getX:function(i){return this.array[i*this.itemSize]},setX:function(i,t){return this.array[i*this.itemSize]=t,this},getY:function(i){return this.array[i*this.itemSize+1]},setY:function(i,t){return this.array[i*this.itemSize+1]=t,this},getZ:function(i){return this.array[i*this.itemSize+2]},setZ:function(i,t){return this.array[i*this.itemSize+2]=t,this},getW:function(i){return this.array[i*this.itemSize+3]},setW:function(i,t){return this.array[i*this.itemSize+3]=t,this},setXY:function(i,t,e){return i*=this.itemSize,this.array[i+0]=t,this.array[i+1]=e,this},setXYZ:function(i,t,e,n){return i*=this.itemSize,this.array[i+0]=t,this.array[i+1]=e,this.array[i+2]=n,this},setXYZW:function(i,t,e,n,r){return i*=this.itemSize,this.array[i+0]=t,this.array[i+1]=e,this.array[i+2]=n,this.array[i+3]=r,this},onUpload:function(i){return this.onUploadCallback=i,this},clone:function(){return new this.constructor(this.array,this.itemSize).copy(this)},toJSON:function(){const i={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.prototype.slice.call(this.array),normalized:this.normalized};return this.name!==""&&(i.name=this.name),this.usage!==Ip&&(i.usage=this.usage),(this.updateRange.offset!==0||this.updateRange.count!==-1)&&(i.updateRange=this.updateRange),i}});function Dh(i,t,e){te.call(this,new Int8Array(i),t,e)}Dh.prototype=Object.create(te.prototype);Dh.prototype.constructor=Dh;function Fh(i,t,e){te.call(this,new Uint8Array(i),t,e)}Fh.prototype=Object.create(te.prototype);Fh.prototype.constructor=Fh;function Ih(i,t,e){te.call(this,new Uint8ClampedArray(i),t,e)}Ih.prototype=Object.create(te.prototype);Ih.prototype.constructor=Ih;function zh(i,t,e){te.call(this,new Int16Array(i),t,e)}zh.prototype=Object.create(te.prototype);zh.prototype.constructor=zh;function xa(i,t,e){te.call(this,new Uint16Array(i),t,e)}xa.prototype=Object.create(te.prototype);xa.prototype.constructor=xa;function Nh(i,t,e){te.call(this,new Int32Array(i),t,e)}Nh.prototype=Object.create(te.prototype);Nh.prototype.constructor=Nh;function ya(i,t,e){te.call(this,new Uint32Array(i),t,e)}ya.prototype=Object.create(te.prototype);ya.prototype.constructor=ya;function jo(i,t,e){te.call(this,new Uint16Array(i),t,e)}jo.prototype=Object.create(te.prototype);jo.prototype.constructor=jo;jo.prototype.isFloat16BufferAttribute=!0;function zi(i,t,e){te.call(this,new Float32Array(i),t,e)}zi.prototype=Object.create(te.prototype);zi.prototype.constructor=zi;function Bh(i,t,e){te.call(this,new Float64Array(i),t,e)}Bh.prototype=Object.create(te.prototype);Bh.prototype.constructor=Bh;const kp=new Ce,Vp=new Jn;class Jr{constructor(t=0,e=0,n=0,r=Jr.DefaultOrder){this._x=t,this._y=e,this._z=n,this._order=r}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get order(){return this._order}set order(t){this._order=t,this._onChangeCallback()}set(t,e,n,r){return this._x=t,this._y=e,this._z=n,this._order=r||this._order,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(t){return this._x=t._x,this._y=t._y,this._z=t._z,this._order=t._order,this._onChangeCallback(),this}setFromRotationMatrix(t,e,n){const r=Zt.clamp,s=t.elements,a=s[0],o=s[4],l=s[8],c=s[1],h=s[5],u=s[9],d=s[2],f=s[6],p=s[10];switch(e=e||this._order,e){case"XYZ":this._y=Math.asin(r(l,-1,1)),Math.abs(l)<.9999999?(this._x=Math.atan2(-u,p),this._z=Math.atan2(-o,a)):(this._x=Math.atan2(f,h),this._z=0);break;case"YXZ":this._x=Math.asin(-r(u,-1,1)),Math.abs(u)<.9999999?(this._y=Math.atan2(l,p),this._z=Math.atan2(c,h)):(this._y=Math.atan2(-d,a),this._z=0);break;case"ZXY":this._x=Math.asin(r(f,-1,1)),Math.abs(f)<.9999999?(this._y=Math.atan2(-d,p),this._z=Math.atan2(-o,h)):(this._y=0,this._z=Math.atan2(c,a));break;case"ZYX":this._y=Math.asin(-r(d,-1,1)),Math.abs(d)<.9999999?(this._x=Math.atan2(f,p),this._z=Math.atan2(c,a)):(this._x=0,this._z=Math.atan2(-o,h));break;case"YZX":this._z=Math.asin(r(c,-1,1)),Math.abs(c)<.9999999?(this._x=Math.atan2(-u,h),this._y=Math.atan2(-d,a)):(this._x=0,this._y=Math.atan2(l,p));break;case"XZY":this._z=Math.asin(-r(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(f,h),this._y=Math.atan2(l,a)):(this._x=Math.atan2(-u,p),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+e)}return this._order=e,n!==!1&&this._onChangeCallback(),this}setFromQuaternion(t,e,n){return kp.makeRotationFromQuaternion(t),this.setFromRotationMatrix(kp,e,n)}setFromVector3(t,e){return this.set(t.x,t.y,t.z,e||this._order)}reorder(t){return Vp.setFromEuler(this),this.setFromQuaternion(Vp,t)}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._order===this._order}fromArray(t){return this._x=t[0],this._y=t[1],this._z=t[2],t[3]!==void 0&&(this._order=t[3]),this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._order,t}toVector3(t){return t?t.set(this._x,this._y,this._z):new Z(this._x,this._y,this._z)}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}}Jr.prototype.isEuler=!0;Jr.DefaultOrder="XYZ";Jr.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"];class OS{constructor(){this.mask=1|0}set(t){this.mask=1<<t|0}enable(t){this.mask|=1<<t|0}enableAll(){this.mask=4294967295|0}toggle(t){this.mask^=1<<t|0}disable(t){this.mask&=~(1<<t|0)}disableAll(){this.mask=0}test(t){return(this.mask&t.mask)!=0}}let US=0;const Wp=new Z,Qr=new Jn,qi=new Ce,Zo=new Z,_a=new Z,HS=new Z,GS=new Jn,$p=new Z(1,0,0),Xp=new Z(0,1,0),qp=new Z(0,0,1),kS={type:"added"},Yp={type:"removed"};function he(){Object.defineProperty(this,"id",{value:US++}),this.uuid=Zt.generateUUID(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=he.DefaultUp.clone();const i=new Z,t=new Jr,e=new Jn,n=new Z(1,1,1);function r(){e.setFromEuler(t,!1)}function s(){t.setFromQuaternion(e,void 0,!1)}t._onChange(r),e._onChange(s),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:i},rotation:{configurable:!0,enumerable:!0,value:t},quaternion:{configurable:!0,enumerable:!0,value:e},scale:{configurable:!0,enumerable:!0,value:n},modelViewMatrix:{value:new Ce},normalMatrix:{value:new gi}}),this.matrix=new Ce,this.matrixWorld=new Ce,this.matrixAutoUpdate=he.DefaultMatrixAutoUpdate,this.matrixWorldNeedsUpdate=!1,this.layers=new OS,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}he.DefaultUp=new Z(0,1,0);he.DefaultMatrixAutoUpdate=!0;he.prototype=Object.assign(Object.create(Zn.prototype),{constructor:he,isObject3D:!0,onBeforeRender:function(){},onAfterRender:function(){},applyMatrix4:function(i){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(i),this.matrix.decompose(this.position,this.quaternion,this.scale)},applyQuaternion:function(i){return this.quaternion.premultiply(i),this},setRotationFromAxisAngle:function(i,t){this.quaternion.setFromAxisAngle(i,t)},setRotationFromEuler:function(i){this.quaternion.setFromEuler(i,!0)},setRotationFromMatrix:function(i){this.quaternion.setFromRotationMatrix(i)},setRotationFromQuaternion:function(i){this.quaternion.copy(i)},rotateOnAxis:function(i,t){return Qr.setFromAxisAngle(i,t),this.quaternion.multiply(Qr),this},rotateOnWorldAxis:function(i,t){return Qr.setFromAxisAngle(i,t),this.quaternion.premultiply(Qr),this},rotateX:function(i){return this.rotateOnAxis($p,i)},rotateY:function(i){return this.rotateOnAxis(Xp,i)},rotateZ:function(i){return this.rotateOnAxis(qp,i)},translateOnAxis:function(i,t){return Wp.copy(i).applyQuaternion(this.quaternion),this.position.add(Wp.multiplyScalar(t)),this},translateX:function(i){return this.translateOnAxis($p,i)},translateY:function(i){return this.translateOnAxis(Xp,i)},translateZ:function(i){return this.translateOnAxis(qp,i)},localToWorld:function(i){return i.applyMatrix4(this.matrixWorld)},worldToLocal:function(i){return i.applyMatrix4(qi.copy(this.matrixWorld).invert())},lookAt:function(i,t,e){i.isVector3?Zo.copy(i):Zo.set(i,t,e);const n=this.parent;this.updateWorldMatrix(!0,!1),_a.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?qi.lookAt(_a,Zo,this.up):qi.lookAt(Zo,_a,this.up),this.quaternion.setFromRotationMatrix(qi),n&&(qi.extractRotation(n.matrixWorld),Qr.setFromRotationMatrix(qi),this.quaternion.premultiply(Qr.invert()))},add:function(i){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.add(arguments[t]);return this}return i===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",i),this):(i&&i.isObject3D?(i.parent!==null&&i.parent.remove(i),i.parent=this,this.children.push(i),i.dispatchEvent(kS)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",i),this)},remove:function(i){if(arguments.length>1){for(let e=0;e<arguments.length;e++)this.remove(arguments[e]);return this}const t=this.children.indexOf(i);return t!==-1&&(i.parent=null,this.children.splice(t,1),i.dispatchEvent(Yp)),this},clear:function(){for(let i=0;i<this.children.length;i++){const t=this.children[i];t.parent=null,t.dispatchEvent(Yp)}return this.children.length=0,this},attach:function(i){return this.updateWorldMatrix(!0,!1),qi.copy(this.matrixWorld).invert(),i.parent!==null&&(i.parent.updateWorldMatrix(!0,!1),qi.multiply(i.parent.matrixWorld)),i.applyMatrix4(qi),this.add(i),i.updateWorldMatrix(!1,!0),this},getObjectById:function(i){return this.getObjectByProperty("id",i)},getObjectByName:function(i){return this.getObjectByProperty("name",i)},getObjectByProperty:function(i,t){if(this[i]===t)return this;for(let e=0,n=this.children.length;e<n;e++){const s=this.children[e].getObjectByProperty(i,t);if(s!==void 0)return s}},getWorldPosition:function(i){return i===void 0&&(console.warn("THREE.Object3D: .getWorldPosition() target is now required"),i=new Z),this.updateWorldMatrix(!0,!1),i.setFromMatrixPosition(this.matrixWorld)},getWorldQuaternion:function(i){return i===void 0&&(console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"),i=new Jn),this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(_a,i,HS),i},getWorldScale:function(i){return i===void 0&&(console.warn("THREE.Object3D: .getWorldScale() target is now required"),i=new Z),this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(_a,GS,i),i},getWorldDirection:function(i){i===void 0&&(console.warn("THREE.Object3D: .getWorldDirection() target is now required"),i=new Z),this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return i.set(t[8],t[9],t[10]).normalize()},raycast:function(){},traverse:function(i){i(this);const t=this.children;for(let e=0,n=t.length;e<n;e++)t[e].traverse(i)},traverseVisible:function(i){if(this.visible===!1)return;i(this);const t=this.children;for(let e=0,n=t.length;e<n;e++)t[e].traverseVisible(i)},traverseAncestors:function(i){const t=this.parent;t!==null&&(i(t),t.traverseAncestors(i))},updateMatrix:function(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0},updateMatrixWorld:function(i){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||i)&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,i=!0);const t=this.children;for(let e=0,n=t.length;e<n;e++)t[e].updateMatrixWorld(i)},updateWorldMatrix:function(i,t){const e=this.parent;if(i===!0&&e!==null&&e.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),t===!0){const n=this.children;for(let r=0,s=n.length;r<s;r++)n[r].updateWorldMatrix(!1,!0)}},toJSON:function(i){const t=i===void 0||typeof i=="string",e={};t&&(i={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{}},e.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});const n={};n.uuid=this.uuid,n.type=this.type,this.name!==""&&(n.name=this.name),this.castShadow===!0&&(n.castShadow=!0),this.receiveShadow===!0&&(n.receiveShadow=!0),this.visible===!1&&(n.visible=!1),this.frustumCulled===!1&&(n.frustumCulled=!1),this.renderOrder!==0&&(n.renderOrder=this.renderOrder),JSON.stringify(this.userData)!=="{}"&&(n.userData=this.userData),n.layers=this.layers.mask,n.matrix=this.matrix.toArray(),this.matrixAutoUpdate===!1&&(n.matrixAutoUpdate=!1),this.isInstancedMesh&&(n.type="InstancedMesh",n.count=this.count,n.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(n.instanceColor=this.instanceColor.toJSON()));function r(a,o){return a[o.uuid]===void 0&&(a[o.uuid]=o.toJSON(i)),o.uuid}if(this.isMesh||this.isLine||this.isPoints){n.geometry=r(i.geometries,this.geometry);const a=this.geometry.parameters;if(a!==void 0&&a.shapes!==void 0){const o=a.shapes;if(Array.isArray(o))for(let l=0,c=o.length;l<c;l++){const h=o[l];r(i.shapes,h)}else r(i.shapes,o)}}if(this.isSkinnedMesh&&(n.bindMode=this.bindMode,n.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(r(i.skeletons,this.skeleton),n.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const a=[];for(let o=0,l=this.material.length;o<l;o++)a.push(r(i.materials,this.material[o]));n.material=a}else n.material=r(i.materials,this.material);if(this.children.length>0){n.children=[];for(let a=0;a<this.children.length;a++)n.children.push(this.children[a].toJSON(i).object)}if(this.animations.length>0){n.animations=[];for(let a=0;a<this.animations.length;a++){const o=this.animations[a];n.animations.push(r(i.animations,o))}}if(t){const a=s(i.geometries),o=s(i.materials),l=s(i.textures),c=s(i.images),h=s(i.shapes),u=s(i.skeletons),d=s(i.animations);a.length>0&&(e.geometries=a),o.length>0&&(e.materials=o),l.length>0&&(e.textures=l),c.length>0&&(e.images=c),h.length>0&&(e.shapes=h),u.length>0&&(e.skeletons=u),d.length>0&&(e.animations=d)}return e.object=n,e;function s(a){const o=[];for(const l in a){const c=a[l];delete c.metadata,o.push(c)}return o}},clone:function(i){return new this.constructor().copy(this,i)},copy:function(i,t=!0){if(this.name=i.name,this.up.copy(i.up),this.position.copy(i.position),this.rotation.order=i.rotation.order,this.quaternion.copy(i.quaternion),this.scale.copy(i.scale),this.matrix.copy(i.matrix),this.matrixWorld.copy(i.matrixWorld),this.matrixAutoUpdate=i.matrixAutoUpdate,this.matrixWorldNeedsUpdate=i.matrixWorldNeedsUpdate,this.layers.mask=i.layers.mask,this.visible=i.visible,this.castShadow=i.castShadow,this.receiveShadow=i.receiveShadow,this.frustumCulled=i.frustumCulled,this.renderOrder=i.renderOrder,this.userData=JSON.parse(JSON.stringify(i.userData)),t===!0)for(let e=0;e<i.children.length;e++){const n=i.children[e];this.add(n.clone())}return this}});function jp(i){if(i.length===0)return-1/0;let t=i[0];for(let e=1,n=i.length;e<n;++e)i[e]>t&&(t=i[e]);return t}let VS=0;const Ni=new Ce,Oh=new he,Kr=new Z,Je=new Qn,va=new Qn,ve=new Z;function Tn(){Object.defineProperty(this,"id",{value:VS++}),this.uuid=Zt.generateUUID(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}Tn.prototype=Object.assign(Object.create(Zn.prototype),{constructor:Tn,isBufferGeometry:!0,getIndex:function(){return this.index},setIndex:function(i){return Array.isArray(i)?this.index=new(jp(i)>65535?ya:xa)(i,1):this.index=i,this},getAttribute:function(i){return this.attributes[i]},setAttribute:function(i,t){return this.attributes[i]=t,this},deleteAttribute:function(i){return delete this.attributes[i],this},hasAttribute:function(i){return this.attributes[i]!==void 0},addGroup:function(i,t,e=0){this.groups.push({start:i,count:t,materialIndex:e})},clearGroups:function(){this.groups=[]},setDrawRange:function(i,t){this.drawRange.start=i,this.drawRange.count=t},applyMatrix4:function(i){const t=this.attributes.position;t!==void 0&&(t.applyMatrix4(i),t.needsUpdate=!0);const e=this.attributes.normal;if(e!==void 0){const r=new gi().getNormalMatrix(i);e.applyNormalMatrix(r),e.needsUpdate=!0}const n=this.attributes.tangent;return n!==void 0&&(n.transformDirection(i),n.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this},rotateX:function(i){return Ni.makeRotationX(i),this.applyMatrix4(Ni),this},rotateY:function(i){return Ni.makeRotationY(i),this.applyMatrix4(Ni),this},rotateZ:function(i){return Ni.makeRotationZ(i),this.applyMatrix4(Ni),this},translate:function(i,t,e){return Ni.makeTranslation(i,t,e),this.applyMatrix4(Ni),this},scale:function(i,t,e){return Ni.makeScale(i,t,e),this.applyMatrix4(Ni),this},lookAt:function(i){return Oh.lookAt(i),Oh.updateMatrix(),this.applyMatrix4(Oh.matrix),this},center:function(){return this.computeBoundingBox(),this.boundingBox.getCenter(Kr).negate(),this.translate(Kr.x,Kr.y,Kr.z),this},setFromPoints:function(i){const t=[];for(let e=0,n=i.length;e<n;e++){const r=i[e];t.push(r.x,r.y,r.z||0)}return this.setAttribute("position",new zi(t,3)),this},computeBoundingBox:function(){this.boundingBox===null&&(this.boundingBox=new Qn);const i=this.attributes.position,t=this.morphAttributes.position;if(i&&i.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingBox.set(new Z(-1/0,-1/0,-1/0),new Z(1/0,1/0,1/0));return}if(i!==void 0){if(this.boundingBox.setFromBufferAttribute(i),t)for(let e=0,n=t.length;e<n;e++){const r=t[e];Je.setFromBufferAttribute(r),this.morphTargetsRelative?(ve.addVectors(this.boundingBox.min,Je.min),this.boundingBox.expandByPoint(ve),ve.addVectors(this.boundingBox.max,Je.max),this.boundingBox.expandByPoint(ve)):(this.boundingBox.expandByPoint(Je.min),this.boundingBox.expandByPoint(Je.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)},computeBoundingSphere:function(){this.boundingSphere===null&&(this.boundingSphere=new Th);const i=this.attributes.position,t=this.morphAttributes.position;if(i&&i.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingSphere.set(new Z,1/0);return}if(i){const e=this.boundingSphere.center;if(Je.setFromBufferAttribute(i),t)for(let r=0,s=t.length;r<s;r++){const a=t[r];va.setFromBufferAttribute(a),this.morphTargetsRelative?(ve.addVectors(Je.min,va.min),Je.expandByPoint(ve),ve.addVectors(Je.max,va.max),Je.expandByPoint(ve)):(Je.expandByPoint(va.min),Je.expandByPoint(va.max))}Je.getCenter(e);let n=0;for(let r=0,s=i.count;r<s;r++)ve.fromBufferAttribute(i,r),n=Math.max(n,e.distanceToSquared(ve));if(t)for(let r=0,s=t.length;r<s;r++){const a=t[r],o=this.morphTargetsRelative;for(let l=0,c=a.count;l<c;l++)ve.fromBufferAttribute(a,l),o&&(Kr.fromBufferAttribute(i,l),ve.add(Kr)),n=Math.max(n,e.distanceToSquared(ve))}this.boundingSphere.radius=Math.sqrt(n),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}},computeFaceNormals:function(){},computeTangents:function(){const i=this.index,t=this.attributes;if(i===null||t.position===void 0||t.normal===void 0||t.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const e=i.array,n=t.position.array,r=t.normal.array,s=t.uv.array,a=n.length/3;t.tangent===void 0&&this.setAttribute("tangent",new te(new Float32Array(4*a),4));const o=t.tangent.array,l=[],c=[];for(let N=0;N<a;N++)l[N]=new Z,c[N]=new Z;const h=new Z,u=new Z,d=new Z,f=new ee,p=new ee,x=new ee,y=new Z,g=new Z;function m(N,G,D){h.fromArray(n,N*3),u.fromArray(n,G*3),d.fromArray(n,D*3),f.fromArray(s,N*2),p.fromArray(s,G*2),x.fromArray(s,D*2),u.sub(h),d.sub(h),p.sub(f),x.sub(f);const V=1/(p.x*x.y-x.x*p.y);!isFinite(V)||(y.copy(u).multiplyScalar(x.y).addScaledVector(d,-p.y).multiplyScalar(V),g.copy(d).multiplyScalar(p.x).addScaledVector(u,-x.x).multiplyScalar(V),l[N].add(y),l[G].add(y),l[D].add(y),c[N].add(g),c[G].add(g),c[D].add(g))}let E=this.groups;E.length===0&&(E=[{start:0,count:e.length}]);for(let N=0,G=E.length;N<G;++N){const D=E[N],V=D.start,R=D.count;for(let L=V,P=V+R;L<P;L+=3)m(e[L+0],e[L+1],e[L+2])}const w=new Z,S=new Z,_=new Z,T=new Z;function B(N){_.fromArray(r,N*3),T.copy(_);const G=l[N];w.copy(G),w.sub(_.multiplyScalar(_.dot(G))).normalize(),S.crossVectors(T,G);const V=S.dot(c[N])<0?-1:1;o[N*4]=w.x,o[N*4+1]=w.y,o[N*4+2]=w.z,o[N*4+3]=V}for(let N=0,G=E.length;N<G;++N){const D=E[N],V=D.start,R=D.count;for(let L=V,P=V+R;L<P;L+=3)B(e[L+0]),B(e[L+1]),B(e[L+2])}},computeVertexNormals:function(){const i=this.index,t=this.getAttribute("position");if(t!==void 0){let e=this.getAttribute("normal");if(e===void 0)e=new te(new Float32Array(t.count*3),3),this.setAttribute("normal",e);else for(let u=0,d=e.count;u<d;u++)e.setXYZ(u,0,0,0);const n=new Z,r=new Z,s=new Z,a=new Z,o=new Z,l=new Z,c=new Z,h=new Z;if(i)for(let u=0,d=i.count;u<d;u+=3){const f=i.getX(u+0),p=i.getX(u+1),x=i.getX(u+2);n.fromBufferAttribute(t,f),r.fromBufferAttribute(t,p),s.fromBufferAttribute(t,x),c.subVectors(s,r),h.subVectors(n,r),c.cross(h),a.fromBufferAttribute(e,f),o.fromBufferAttribute(e,p),l.fromBufferAttribute(e,x),a.add(c),o.add(c),l.add(c),e.setXYZ(f,a.x,a.y,a.z),e.setXYZ(p,o.x,o.y,o.z),e.setXYZ(x,l.x,l.y,l.z)}else for(let u=0,d=t.count;u<d;u+=3)n.fromBufferAttribute(t,u+0),r.fromBufferAttribute(t,u+1),s.fromBufferAttribute(t,u+2),c.subVectors(s,r),h.subVectors(n,r),c.cross(h),e.setXYZ(u+0,c.x,c.y,c.z),e.setXYZ(u+1,c.x,c.y,c.z),e.setXYZ(u+2,c.x,c.y,c.z);this.normalizeNormals(),e.needsUpdate=!0}},merge:function(i,t){if(!(i&&i.isBufferGeometry)){console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",i);return}t===void 0&&(t=0,console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));const e=this.attributes;for(const n in e){if(i.attributes[n]===void 0)continue;const s=e[n].array,a=i.attributes[n],o=a.array,l=a.itemSize*t,c=Math.min(o.length,s.length-l);for(let h=0,u=l;h<c;h++,u++)s[u]=o[h]}return this},normalizeNormals:function(){const i=this.attributes.normal;for(let t=0,e=i.count;t<e;t++)ve.fromBufferAttribute(i,t),ve.normalize(),i.setXYZ(t,ve.x,ve.y,ve.z)},toNonIndexed:function(){function i(a,o){const l=a.array,c=a.itemSize,h=a.normalized,u=new l.constructor(o.length*c);let d=0,f=0;for(let p=0,x=o.length;p<x;p++){d=o[p]*c;for(let y=0;y<c;y++)u[f++]=l[d++]}return new te(u,c,h)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const t=new Tn,e=this.index.array,n=this.attributes;for(const a in n){const o=n[a],l=i(o,e);t.setAttribute(a,l)}const r=this.morphAttributes;for(const a in r){const o=[],l=r[a];for(let c=0,h=l.length;c<h;c++){const u=l[c],d=i(u,e);o.push(d)}t.morphAttributes[a]=o}t.morphTargetsRelative=this.morphTargetsRelative;const s=this.groups;for(let a=0,o=s.length;a<o;a++){const l=s[a];t.addGroup(l.start,l.count,l.materialIndex)}return t},toJSON:function(){const i={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(i.uuid=this.uuid,i.type=this.type,this.name!==""&&(i.name=this.name),Object.keys(this.userData).length>0&&(i.userData=this.userData),this.parameters!==void 0){const o=this.parameters;for(const l in o)o[l]!==void 0&&(i[l]=o[l]);return i}i.data={attributes:{}};const t=this.index;t!==null&&(i.data.index={type:t.array.constructor.name,array:Array.prototype.slice.call(t.array)});const e=this.attributes;for(const o in e){const l=e[o];i.data.attributes[o]=l.toJSON(i.data)}const n={};let r=!1;for(const o in this.morphAttributes){const l=this.morphAttributes[o],c=[];for(let h=0,u=l.length;h<u;h++){const d=l[h];c.push(d.toJSON(i.data))}c.length>0&&(n[o]=c,r=!0)}r&&(i.data.morphAttributes=n,i.data.morphTargetsRelative=this.morphTargetsRelative);const s=this.groups;s.length>0&&(i.data.groups=JSON.parse(JSON.stringify(s)));const a=this.boundingSphere;return a!==null&&(i.data.boundingSphere={center:a.center.toArray(),radius:a.radius}),i},clone:function(){return new Tn().copy(this)},copy:function(i){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const t={};this.name=i.name;const e=i.index;e!==null&&this.setIndex(e.clone(t));const n=i.attributes;for(const l in n){const c=n[l];this.setAttribute(l,c.clone(t))}const r=i.morphAttributes;for(const l in r){const c=[],h=r[l];for(let u=0,d=h.length;u<d;u++)c.push(h[u].clone(t));this.morphAttributes[l]=c}this.morphTargetsRelative=i.morphTargetsRelative;const s=i.groups;for(let l=0,c=s.length;l<c;l++){const h=s[l];this.addGroup(h.start,h.count,h.materialIndex)}const a=i.boundingBox;a!==null&&(this.boundingBox=a.clone());const o=i.boundingSphere;return o!==null&&(this.boundingSphere=o.clone()),this.drawRange.start=i.drawRange.start,this.drawRange.count=i.drawRange.count,this.userData=i.userData,this},dispose:function(){this.dispatchEvent({type:"dispose"})}});class Zp extends Tn{constructor(t=1,e=1,n=1,r=1,s=1,a=1){super();this.type="BoxGeometry",this.parameters={width:t,height:e,depth:n,widthSegments:r,heightSegments:s,depthSegments:a};const o=this;r=Math.floor(r),s=Math.floor(s),a=Math.floor(a);const l=[],c=[],h=[],u=[];let d=0,f=0;p("z","y","x",-1,-1,n,e,t,a,s,0),p("z","y","x",1,-1,n,e,-t,a,s,1),p("x","z","y",1,1,t,n,e,r,a,2),p("x","z","y",1,-1,t,n,-e,r,a,3),p("x","y","z",1,-1,t,e,n,r,s,4),p("x","y","z",-1,-1,t,e,-n,r,s,5),this.setIndex(l),this.setAttribute("position",new zi(c,3)),this.setAttribute("normal",new zi(h,3)),this.setAttribute("uv",new zi(u,2));function p(x,y,g,m,E,w,S,_,T,B,N){const G=w/T,D=S/B,V=w/2,R=S/2,L=_/2,P=T+1,F=B+1;let W=0,j=0;const Y=new Z;for(let Q=0;Q<F;Q++){const K=Q*D-R;for(let st=0;st<P;st++){const ct=st*G-V;Y[x]=ct*m,Y[y]=K*E,Y[g]=L,c.push(Y.x,Y.y,Y.z),Y[x]=0,Y[y]=0,Y[g]=_>0?1:-1,h.push(Y.x,Y.y,Y.z),u.push(st/T),u.push(1-Q/B),W+=1}}for(let Q=0;Q<B;Q++)for(let K=0;K<T;K++){const st=d+K+P*Q,ct=d+K+P*(Q+1),z=d+(K+1)+P*(Q+1),Et=d+(K+1)+P*Q;l.push(st,ct,Et),l.push(ct,z,Et),j+=6}o.addGroup(f,j,N),f+=j,d+=W}}}class WS extends Tn{constructor(t=1,e=1,n=1,r=1){super();this.type="PlaneGeometry",this.parameters={width:t,height:e,widthSegments:n,heightSegments:r};const s=t/2,a=e/2,o=Math.floor(n),l=Math.floor(r),c=o+1,h=l+1,u=t/o,d=e/l,f=[],p=[],x=[],y=[];for(let g=0;g<h;g++){const m=g*d-a;for(let E=0;E<c;E++){const w=E*u-s;p.push(w,-m,0),x.push(0,0,1),y.push(E/o),y.push(1-g/l)}}for(let g=0;g<l;g++)for(let m=0;m<o;m++){const E=m+c*g,w=m+c*(g+1),S=m+1+c*(g+1),_=m+1+c*g;f.push(E,w,_),f.push(w,S,_)}this.setIndex(f),this.setAttribute("position",new zi(p,3)),this.setAttribute("normal",new zi(x,3)),this.setAttribute("uv",new zi(y,2))}}let $S=0;function Bi(){Object.defineProperty(this,"id",{value:$S++}),this.uuid=Zt.generateUUID(),this.name="",this.type="Material",this.fog=!0,this.blending=da,this.side=No,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.blendSrc=gp,this.blendDst=xp,this.blendEquation=Wr,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=lh,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=RS,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=vh,this.stencilZFail=vh,this.stencilZPass=vh,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaTest=0,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0}Bi.prototype=Object.assign(Object.create(Zn.prototype),{constructor:Bi,isMaterial:!0,onBeforeCompile:function(){},customProgramCacheKey:function(){return this.onBeforeCompile.toString()},setValues:function(i){if(i!==void 0)for(const t in i){const e=i[t];if(e===void 0){console.warn("THREE.Material: '"+t+"' parameter is undefined.");continue}if(t==="shading"){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=e===Kb;continue}const n=this[t];if(n===void 0){console.warn("THREE."+this.type+": '"+t+"' is not a property of this material.");continue}n&&n.isColor?n.set(e):n&&n.isVector3&&e&&e.isVector3?n.copy(e):this[t]=e}},toJSON:function(i){const t=i===void 0||typeof i=="string";t&&(i={textures:{},images:{}});const e={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};e.uuid=this.uuid,e.type=this.type,this.name!==""&&(e.name=this.name),this.color&&this.color.isColor&&(e.color=this.color.getHex()),this.roughness!==void 0&&(e.roughness=this.roughness),this.metalness!==void 0&&(e.metalness=this.metalness),this.sheen&&this.sheen.isColor&&(e.sheen=this.sheen.getHex()),this.emissive&&this.emissive.isColor&&(e.emissive=this.emissive.getHex()),this.emissiveIntensity&&this.emissiveIntensity!==1&&(e.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(e.specular=this.specular.getHex()),this.shininess!==void 0&&(e.shininess=this.shininess),this.clearcoat!==void 0&&(e.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(e.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(e.clearcoatMap=this.clearcoatMap.toJSON(i).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(e.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(i).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(e.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(i).uuid,e.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.map&&this.map.isTexture&&(e.map=this.map.toJSON(i).uuid),this.matcap&&this.matcap.isTexture&&(e.matcap=this.matcap.toJSON(i).uuid),this.alphaMap&&this.alphaMap.isTexture&&(e.alphaMap=this.alphaMap.toJSON(i).uuid),this.lightMap&&this.lightMap.isTexture&&(e.lightMap=this.lightMap.toJSON(i).uuid,e.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(e.aoMap=this.aoMap.toJSON(i).uuid,e.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(e.bumpMap=this.bumpMap.toJSON(i).uuid,e.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(e.normalMap=this.normalMap.toJSON(i).uuid,e.normalMapType=this.normalMapType,e.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(e.displacementMap=this.displacementMap.toJSON(i).uuid,e.displacementScale=this.displacementScale,e.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(e.roughnessMap=this.roughnessMap.toJSON(i).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(e.metalnessMap=this.metalnessMap.toJSON(i).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(e.emissiveMap=this.emissiveMap.toJSON(i).uuid),this.specularMap&&this.specularMap.isTexture&&(e.specularMap=this.specularMap.toJSON(i).uuid),this.envMap&&this.envMap.isTexture&&(e.envMap=this.envMap.toJSON(i).uuid,e.reflectivity=this.reflectivity,e.refractionRatio=this.refractionRatio,this.combine!==void 0&&(e.combine=this.combine),this.envMapIntensity!==void 0&&(e.envMapIntensity=this.envMapIntensity)),this.gradientMap&&this.gradientMap.isTexture&&(e.gradientMap=this.gradientMap.toJSON(i).uuid),this.size!==void 0&&(e.size=this.size),this.shadowSide!==null&&(e.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(e.sizeAttenuation=this.sizeAttenuation),this.blending!==da&&(e.blending=this.blending),this.side!==No&&(e.side=this.side),this.vertexColors&&(e.vertexColors=!0),this.opacity<1&&(e.opacity=this.opacity),this.transparent===!0&&(e.transparent=this.transparent),e.depthFunc=this.depthFunc,e.depthTest=this.depthTest,e.depthWrite=this.depthWrite,e.colorWrite=this.colorWrite,e.stencilWrite=this.stencilWrite,e.stencilWriteMask=this.stencilWriteMask,e.stencilFunc=this.stencilFunc,e.stencilRef=this.stencilRef,e.stencilFuncMask=this.stencilFuncMask,e.stencilFail=this.stencilFail,e.stencilZFail=this.stencilZFail,e.stencilZPass=this.stencilZPass,this.rotation&&this.rotation!==0&&(e.rotation=this.rotation),this.polygonOffset===!0&&(e.polygonOffset=!0),this.polygonOffsetFactor!==0&&(e.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(e.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth&&this.linewidth!==1&&(e.linewidth=this.linewidth),this.dashSize!==void 0&&(e.dashSize=this.dashSize),this.gapSize!==void 0&&(e.gapSize=this.gapSize),this.scale!==void 0&&(e.scale=this.scale),this.dithering===!0&&(e.dithering=!0),this.alphaTest>0&&(e.alphaTest=this.alphaTest),this.alphaToCoverage===!0&&(e.alphaToCoverage=this.alphaToCoverage),this.premultipliedAlpha===!0&&(e.premultipliedAlpha=this.premultipliedAlpha),this.wireframe===!0&&(e.wireframe=this.wireframe),this.wireframeLinewidth>1&&(e.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(e.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(e.wireframeLinejoin=this.wireframeLinejoin),this.morphTargets===!0&&(e.morphTargets=!0),this.morphNormals===!0&&(e.morphNormals=!0),this.skinning===!0&&(e.skinning=!0),this.flatShading===!0&&(e.flatShading=this.flatShading),this.visible===!1&&(e.visible=!1),this.toneMapped===!1&&(e.toneMapped=!1),JSON.stringify(this.userData)!=="{}"&&(e.userData=this.userData);function n(r){const s=[];for(const a in r){const o=r[a];delete o.metadata,s.push(o)}return s}if(t){const r=n(i.textures),s=n(i.images);r.length>0&&(e.textures=r),s.length>0&&(e.images=s)}return e},clone:function(){return new this.constructor().copy(this)},copy:function(i){this.name=i.name,this.fog=i.fog,this.blending=i.blending,this.side=i.side,this.vertexColors=i.vertexColors,this.opacity=i.opacity,this.transparent=i.transparent,this.blendSrc=i.blendSrc,this.blendDst=i.blendDst,this.blendEquation=i.blendEquation,this.blendSrcAlpha=i.blendSrcAlpha,this.blendDstAlpha=i.blendDstAlpha,this.blendEquationAlpha=i.blendEquationAlpha,this.depthFunc=i.depthFunc,this.depthTest=i.depthTest,this.depthWrite=i.depthWrite,this.stencilWriteMask=i.stencilWriteMask,this.stencilFunc=i.stencilFunc,this.stencilRef=i.stencilRef,this.stencilFuncMask=i.stencilFuncMask,this.stencilFail=i.stencilFail,this.stencilZFail=i.stencilZFail,this.stencilZPass=i.stencilZPass,this.stencilWrite=i.stencilWrite;const t=i.clippingPlanes;let e=null;if(t!==null){const n=t.length;e=new Array(n);for(let r=0;r!==n;++r)e[r]=t[r].clone()}return this.clippingPlanes=e,this.clipIntersection=i.clipIntersection,this.clipShadows=i.clipShadows,this.shadowSide=i.shadowSide,this.colorWrite=i.colorWrite,this.precision=i.precision,this.polygonOffset=i.polygonOffset,this.polygonOffsetFactor=i.polygonOffsetFactor,this.polygonOffsetUnits=i.polygonOffsetUnits,this.dithering=i.dithering,this.alphaTest=i.alphaTest,this.alphaToCoverage=i.alphaToCoverage,this.premultipliedAlpha=i.premultipliedAlpha,this.visible=i.visible,this.toneMapped=i.toneMapped,this.userData=JSON.parse(JSON.stringify(i.userData)),this},dispose:function(){this.dispatchEvent({type:"dispose"})}});Object.defineProperty(Bi.prototype,"needsUpdate",{set:function(i){i===!0&&this.version++}});function ts(i){const t={};for(const e in i){t[e]={};for(const n in i[e]){const r=i[e][n];r&&(r.isColor||r.isMatrix3||r.isMatrix4||r.isVector2||r.isVector3||r.isVector4||r.isTexture||r.isQuaternion)?t[e][n]=r.clone():Array.isArray(r)?t[e][n]=r.slice():t[e][n]=r}}return t}function ze(i){const t={};for(let e=0;e<i.length;e++){const n=ts(i[e]);for(const r in n)t[r]=n[r]}return t}const XS={clone:ts,merge:ze};var qS=`
void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}
`,YS=`
void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}
`;function Oi(i){Bi.call(this),this.type="ShaderMaterial",this.defines={},this.uniforms={},this.vertexShader=qS,this.fragmentShader=YS,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,i!==void 0&&(i.attributes!==void 0&&console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),this.setValues(i))}Oi.prototype=Object.create(Bi.prototype);Oi.prototype.constructor=Oi;Oi.prototype.isShaderMaterial=!0;Oi.prototype.copy=function(i){return Bi.prototype.copy.call(this,i),this.fragmentShader=i.fragmentShader,this.vertexShader=i.vertexShader,this.uniforms=ts(i.uniforms),this.defines=Object.assign({},i.defines),this.wireframe=i.wireframe,this.wireframeLinewidth=i.wireframeLinewidth,this.lights=i.lights,this.clipping=i.clipping,this.skinning=i.skinning,this.morphTargets=i.morphTargets,this.morphNormals=i.morphNormals,this.extensions=Object.assign({},i.extensions),this.glslVersion=i.glslVersion,this};Oi.prototype.toJSON=function(i){const t=Bi.prototype.toJSON.call(this,i);t.glslVersion=this.glslVersion,t.uniforms={};for(const n in this.uniforms){const s=this.uniforms[n].value;s&&s.isTexture?t.uniforms[n]={type:"t",value:s.toJSON(i).uuid}:s&&s.isColor?t.uniforms[n]={type:"c",value:s.getHex()}:s&&s.isVector2?t.uniforms[n]={type:"v2",value:s.toArray()}:s&&s.isVector3?t.uniforms[n]={type:"v3",value:s.toArray()}:s&&s.isVector4?t.uniforms[n]={type:"v4",value:s.toArray()}:s&&s.isMatrix3?t.uniforms[n]={type:"m3",value:s.toArray()}:s&&s.isMatrix4?t.uniforms[n]={type:"m4",value:s.toArray()}:t.uniforms[n]={value:s}}Object.keys(this.defines).length>0&&(t.defines=this.defines),t.vertexShader=this.vertexShader,t.fragmentShader=this.fragmentShader;const e={};for(const n in this.extensions)this.extensions[n]===!0&&(e[n]=!0);return Object.keys(e).length>0&&(t.extensions=e),t};const Yi=new Z,Uh=new Z,Jo=new Z,Ln=new Z,Hh=new Z,Qo=new Z,Gh=new Z;class jS{constructor(t=new Z,e=new Z(0,0,-1)){this.origin=t,this.direction=e}set(t,e){return this.origin.copy(t),this.direction.copy(e),this}copy(t){return this.origin.copy(t.origin),this.direction.copy(t.direction),this}at(t,e){return e===void 0&&(console.warn("THREE.Ray: .at() target is now required"),e=new Z),e.copy(this.direction).multiplyScalar(t).add(this.origin)}lookAt(t){return this.direction.copy(t).sub(this.origin).normalize(),this}recast(t){return this.origin.copy(this.at(t,Yi)),this}closestPointToPoint(t,e){e===void 0&&(console.warn("THREE.Ray: .closestPointToPoint() target is now required"),e=new Z),e.subVectors(t,this.origin);const n=e.dot(this.direction);return n<0?e.copy(this.origin):e.copy(this.direction).multiplyScalar(n).add(this.origin)}distanceToPoint(t){return Math.sqrt(this.distanceSqToPoint(t))}distanceSqToPoint(t){const e=Yi.subVectors(t,this.origin).dot(this.direction);return e<0?this.origin.distanceToSquared(t):(Yi.copy(this.direction).multiplyScalar(e).add(this.origin),Yi.distanceToSquared(t))}distanceSqToSegment(t,e,n,r){Uh.copy(t).add(e).multiplyScalar(.5),Jo.copy(e).sub(t).normalize(),Ln.copy(this.origin).sub(Uh);const s=t.distanceTo(e)*.5,a=-this.direction.dot(Jo),o=Ln.dot(this.direction),l=-Ln.dot(Jo),c=Ln.lengthSq(),h=Math.abs(1-a*a);let u,d,f,p;if(h>0)if(u=a*l-o,d=a*o-l,p=s*h,u>=0)if(d>=-p)if(d<=p){const x=1/h;u*=x,d*=x,f=u*(u+a*d+2*o)+d*(a*u+d+2*l)+c}else d=s,u=Math.max(0,-(a*d+o)),f=-u*u+d*(d+2*l)+c;else d=-s,u=Math.max(0,-(a*d+o)),f=-u*u+d*(d+2*l)+c;else d<=-p?(u=Math.max(0,-(-a*s+o)),d=u>0?-s:Math.min(Math.max(-s,-l),s),f=-u*u+d*(d+2*l)+c):d<=p?(u=0,d=Math.min(Math.max(-s,-l),s),f=d*(d+2*l)+c):(u=Math.max(0,-(a*s+o)),d=u>0?s:Math.min(Math.max(-s,-l),s),f=-u*u+d*(d+2*l)+c);else d=a>0?-s:s,u=Math.max(0,-(a*d+o)),f=-u*u+d*(d+2*l)+c;return n&&n.copy(this.direction).multiplyScalar(u).add(this.origin),r&&r.copy(Jo).multiplyScalar(d).add(Uh),f}intersectSphere(t,e){Yi.subVectors(t.center,this.origin);const n=Yi.dot(this.direction),r=Yi.dot(Yi)-n*n,s=t.radius*t.radius;if(r>s)return null;const a=Math.sqrt(s-r),o=n-a,l=n+a;return o<0&&l<0?null:o<0?this.at(l,e):this.at(o,e)}intersectsSphere(t){return this.distanceSqToPoint(t.center)<=t.radius*t.radius}distanceToPlane(t){const e=t.normal.dot(this.direction);if(e===0)return t.distanceToPoint(this.origin)===0?0:null;const n=-(this.origin.dot(t.normal)+t.constant)/e;return n>=0?n:null}intersectPlane(t,e){const n=this.distanceToPlane(t);return n===null?null:this.at(n,e)}intersectsPlane(t){const e=t.distanceToPoint(this.origin);return e===0||t.normal.dot(this.direction)*e<0}intersectBox(t,e){let n,r,s,a,o,l;const c=1/this.direction.x,h=1/this.direction.y,u=1/this.direction.z,d=this.origin;return c>=0?(n=(t.min.x-d.x)*c,r=(t.max.x-d.x)*c):(n=(t.max.x-d.x)*c,r=(t.min.x-d.x)*c),h>=0?(s=(t.min.y-d.y)*h,a=(t.max.y-d.y)*h):(s=(t.max.y-d.y)*h,a=(t.min.y-d.y)*h),n>a||s>r||((s>n||n!==n)&&(n=s),(a<r||r!==r)&&(r=a),u>=0?(o=(t.min.z-d.z)*u,l=(t.max.z-d.z)*u):(o=(t.max.z-d.z)*u,l=(t.min.z-d.z)*u),n>l||o>r)||((o>n||n!==n)&&(n=o),(l<r||r!==r)&&(r=l),r<0)?null:this.at(n>=0?n:r,e)}intersectsBox(t){return this.intersectBox(t,Yi)!==null}intersectTriangle(t,e,n,r,s){Hh.subVectors(e,t),Qo.subVectors(n,t),Gh.crossVectors(Hh,Qo);let a=this.direction.dot(Gh),o;if(a>0){if(r)return null;o=1}else if(a<0)o=-1,a=-a;else return null;Ln.subVectors(this.origin,t);const l=o*this.direction.dot(Qo.crossVectors(Ln,Qo));if(l<0)return null;const c=o*this.direction.dot(Hh.cross(Ln));if(c<0||l+c>a)return null;const h=-o*Ln.dot(Gh);return h<0?null:this.at(h/a,s)}applyMatrix4(t){return this.origin.applyMatrix4(t),this.direction.transformDirection(t),this}equals(t){return t.origin.equals(this.origin)&&t.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}const _i=new Z,ji=new Z,kh=new Z,Zi=new Z,es=new Z,is=new Z,Jp=new Z,Vh=new Z,Wh=new Z,$h=new Z;class Ji{constructor(t=new Z,e=new Z,n=new Z){this.a=t,this.b=e,this.c=n}static getNormal(t,e,n,r){r===void 0&&(console.warn("THREE.Triangle: .getNormal() target is now required"),r=new Z),r.subVectors(n,e),_i.subVectors(t,e),r.cross(_i);const s=r.lengthSq();return s>0?r.multiplyScalar(1/Math.sqrt(s)):r.set(0,0,0)}static getBarycoord(t,e,n,r,s){_i.subVectors(r,e),ji.subVectors(n,e),kh.subVectors(t,e);const a=_i.dot(_i),o=_i.dot(ji),l=_i.dot(kh),c=ji.dot(ji),h=ji.dot(kh),u=a*c-o*o;if(s===void 0&&(console.warn("THREE.Triangle: .getBarycoord() target is now required"),s=new Z),u===0)return s.set(-2,-1,-1);const d=1/u,f=(c*l-o*h)*d,p=(a*h-o*l)*d;return s.set(1-f-p,p,f)}static containsPoint(t,e,n,r){return this.getBarycoord(t,e,n,r,Zi),Zi.x>=0&&Zi.y>=0&&Zi.x+Zi.y<=1}static getUV(t,e,n,r,s,a,o,l){return this.getBarycoord(t,e,n,r,Zi),l.set(0,0),l.addScaledVector(s,Zi.x),l.addScaledVector(a,Zi.y),l.addScaledVector(o,Zi.z),l}static isFrontFacing(t,e,n,r){return _i.subVectors(n,e),ji.subVectors(t,e),_i.cross(ji).dot(r)<0}set(t,e,n){return this.a.copy(t),this.b.copy(e),this.c.copy(n),this}setFromPointsAndIndices(t,e,n,r){return this.a.copy(t[e]),this.b.copy(t[n]),this.c.copy(t[r]),this}clone(){return new this.constructor().copy(this)}copy(t){return this.a.copy(t.a),this.b.copy(t.b),this.c.copy(t.c),this}getArea(){return _i.subVectors(this.c,this.b),ji.subVectors(this.a,this.b),_i.cross(ji).length()*.5}getMidpoint(t){return t===void 0&&(console.warn("THREE.Triangle: .getMidpoint() target is now required"),t=new Z),t.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(t){return Ji.getNormal(this.a,this.b,this.c,t)}getPlane(t){return t===void 0&&(console.warn("THREE.Triangle: .getPlane() target is now required"),t=new Xi),t.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(t,e){return Ji.getBarycoord(t,this.a,this.b,this.c,e)}getUV(t,e,n,r,s){return Ji.getUV(t,this.a,this.b,this.c,e,n,r,s)}containsPoint(t){return Ji.containsPoint(t,this.a,this.b,this.c)}isFrontFacing(t){return Ji.isFrontFacing(this.a,this.b,this.c,t)}intersectsBox(t){return t.intersectsTriangle(this)}closestPointToPoint(t,e){e===void 0&&(console.warn("THREE.Triangle: .closestPointToPoint() target is now required"),e=new Z);const n=this.a,r=this.b,s=this.c;let a,o;es.subVectors(r,n),is.subVectors(s,n),Vh.subVectors(t,n);const l=es.dot(Vh),c=is.dot(Vh);if(l<=0&&c<=0)return e.copy(n);Wh.subVectors(t,r);const h=es.dot(Wh),u=is.dot(Wh);if(h>=0&&u<=h)return e.copy(r);const d=l*u-h*c;if(d<=0&&l>=0&&h<=0)return a=l/(l-h),e.copy(n).addScaledVector(es,a);$h.subVectors(t,s);const f=es.dot($h),p=is.dot($h);if(p>=0&&f<=p)return e.copy(s);const x=f*c-l*p;if(x<=0&&c>=0&&p<=0)return o=c/(c-p),e.copy(n).addScaledVector(is,o);const y=h*p-f*u;if(y<=0&&u-h>=0&&f-p>=0)return Jp.subVectors(s,r),o=(u-h)/(u-h+(f-p)),e.copy(r).addScaledVector(Jp,o);const g=1/(y+x+d);return a=x*g,o=d*g,e.copy(n).addScaledVector(es,a).addScaledVector(is,o)}equals(t){return t.a.equals(this.a)&&t.b.equals(this.b)&&t.c.equals(this.c)}}class Qp extends Bi{constructor(t){super();this.type="MeshBasicMaterial",this.color=new Jt(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=yp,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.skinning=t.skinning,this.morphTargets=t.morphTargets,this}}Qp.prototype.isMeshBasicMaterial=!0;const Kp=new Ce,ns=new jS,Xh=new Th,Rn=new Z,Cn=new Z,Pn=new Z,qh=new Z,Yh=new Z,jh=new Z,Ko=new Z,tl=new Z,el=new Z,il=new ee,nl=new ee,rl=new ee,Zh=new Z,sl=new Z;function rs(i=new Tn,t=new Qp){he.call(this),this.type="Mesh",this.geometry=i,this.material=t,this.updateMorphTargets()}rs.prototype=Object.assign(Object.create(he.prototype),{constructor:rs,isMesh:!0,copy:function(i){return he.prototype.copy.call(this,i),i.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=i.morphTargetInfluences.slice()),i.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},i.morphTargetDictionary)),this.material=i.material,this.geometry=i.geometry,this},updateMorphTargets:function(){const i=this.geometry;if(i.isBufferGeometry){const t=i.morphAttributes,e=Object.keys(t);if(e.length>0){const n=t[e[0]];if(n!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,s=n.length;r<s;r++){const a=n[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=r}}}}else{const t=i.morphTargets;t!==void 0&&t.length>0&&console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}},raycast:function(i,t){const e=this.geometry,n=this.material,r=this.matrixWorld;if(n===void 0||(e.boundingSphere===null&&e.computeBoundingSphere(),Xh.copy(e.boundingSphere),Xh.applyMatrix4(r),i.ray.intersectsSphere(Xh)===!1)||(Kp.copy(r).invert(),ns.copy(i.ray).applyMatrix4(Kp),e.boundingBox!==null&&ns.intersectsBox(e.boundingBox)===!1))return;let s;if(e.isBufferGeometry){const a=e.index,o=e.attributes.position,l=e.morphAttributes.position,c=e.morphTargetsRelative,h=e.attributes.uv,u=e.attributes.uv2,d=e.groups,f=e.drawRange;if(a!==null)if(Array.isArray(n))for(let p=0,x=d.length;p<x;p++){const y=d[p],g=n[y.materialIndex],m=Math.max(y.start,f.start),E=Math.min(y.start+y.count,f.start+f.count);for(let w=m,S=E;w<S;w+=3){const _=a.getX(w),T=a.getX(w+1),B=a.getX(w+2);s=al(this,g,i,ns,o,l,c,h,u,_,T,B),s&&(s.faceIndex=Math.floor(w/3),s.face.materialIndex=y.materialIndex,t.push(s))}}else{const p=Math.max(0,f.start),x=Math.min(a.count,f.start+f.count);for(let y=p,g=x;y<g;y+=3){const m=a.getX(y),E=a.getX(y+1),w=a.getX(y+2);s=al(this,n,i,ns,o,l,c,h,u,m,E,w),s&&(s.faceIndex=Math.floor(y/3),t.push(s))}}else if(o!==void 0)if(Array.isArray(n))for(let p=0,x=d.length;p<x;p++){const y=d[p],g=n[y.materialIndex],m=Math.max(y.start,f.start),E=Math.min(y.start+y.count,f.start+f.count);for(let w=m,S=E;w<S;w+=3){const _=w,T=w+1,B=w+2;s=al(this,g,i,ns,o,l,c,h,u,_,T,B),s&&(s.faceIndex=Math.floor(w/3),s.face.materialIndex=y.materialIndex,t.push(s))}}else{const p=Math.max(0,f.start),x=Math.min(o.count,f.start+f.count);for(let y=p,g=x;y<g;y+=3){const m=y,E=y+1,w=y+2;s=al(this,n,i,ns,o,l,c,h,u,m,E,w),s&&(s.faceIndex=Math.floor(y/3),t.push(s))}}}else e.isGeometry&&console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}});function ZS(i,t,e,n,r,s,a,o){let l;if(t.side===Le?l=n.intersectTriangle(a,s,r,!0,o):l=n.intersectTriangle(r,s,a,t.side!==Bo,o),l===null)return null;sl.copy(o),sl.applyMatrix4(i.matrixWorld);const c=e.ray.origin.distanceTo(sl);return c<e.near||c>e.far?null:{distance:c,point:sl.clone(),object:i}}function al(i,t,e,n,r,s,a,o,l,c,h,u){Rn.fromBufferAttribute(r,c),Cn.fromBufferAttribute(r,h),Pn.fromBufferAttribute(r,u);const d=i.morphTargetInfluences;if(t.morphTargets&&s&&d){Ko.set(0,0,0),tl.set(0,0,0),el.set(0,0,0);for(let p=0,x=s.length;p<x;p++){const y=d[p],g=s[p];y!==0&&(qh.fromBufferAttribute(g,c),Yh.fromBufferAttribute(g,h),jh.fromBufferAttribute(g,u),a?(Ko.addScaledVector(qh,y),tl.addScaledVector(Yh,y),el.addScaledVector(jh,y)):(Ko.addScaledVector(qh.sub(Rn),y),tl.addScaledVector(Yh.sub(Cn),y),el.addScaledVector(jh.sub(Pn),y)))}Rn.add(Ko),Cn.add(tl),Pn.add(el)}i.isSkinnedMesh&&t.skinning&&(i.boneTransform(c,Rn),i.boneTransform(h,Cn),i.boneTransform(u,Pn));const f=ZS(i,t,e,n,Rn,Cn,Pn,Zh);if(f){o&&(il.fromBufferAttribute(o,c),nl.fromBufferAttribute(o,h),rl.fromBufferAttribute(o,u),f.uv=Ji.getUV(Zh,Rn,Cn,Pn,il,nl,rl,new ee)),l&&(il.fromBufferAttribute(l,c),nl.fromBufferAttribute(l,h),rl.fromBufferAttribute(l,u),f.uv2=Ji.getUV(Zh,Rn,Cn,Pn,il,nl,rl,new ee));const p={a:c,b:h,c:u,normal:new Z,materialIndex:0};Ji.getNormal(Rn,Cn,Pn,p.normal),f.face=p}return f}var JS=`
#ifdef USE_ALPHAMAP

	diffuseColor.a *= texture2D( alphaMap, vUv ).g;

#endif
`,QS=`
#ifdef USE_ALPHAMAP

	uniform sampler2D alphaMap;

#endif
`,KS=`
#ifdef ALPHATEST

	if ( diffuseColor.a < ALPHATEST ) discard;

#endif
`,t1=`
#ifdef USE_AOMAP

	// reads channel R, compatible with a combined OcclusionRoughnessMetallic (RGB) texture
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;

	reflectedLight.indirectDiffuse *= ambientOcclusion;

	#if defined( USE_ENVMAP ) && defined( STANDARD )

		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );

		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );

	#endif

#endif
`,e1=`
#ifdef USE_AOMAP

	uniform sampler2D aoMap;
	uniform float aoMapIntensity;

#endif
`,i1=`
vec3 transformed = vec3( position );
`,n1=`
vec3 objectNormal = vec3( normal );

#ifdef USE_TANGENT

	vec3 objectTangent = vec3( tangent.xyz );

#endif
`,r1=`

// Analytical approximation of the DFG LUT, one half of the
// split-sum approximation used in indirect specular lighting.
// via 'environmentBRDF' from "Physically Based Shading on Mobile"
// https://www.unrealengine.com/blog/physically-based-shading-on-mobile - environmentBRDF for GGX on mobile
vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );

	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );

	vec4 r = roughness * c0 + c1;

	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;

	return vec2( -1.04, 1.04 ) * a004 + r.zw;

}

float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {

#if defined ( PHYSICALLY_CORRECT_LIGHTS )

	// based upon Frostbite 3 Moving to Physically-based Rendering
	// page 32, equation 26: E[window1]
	// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
	// this is intended to be used on spot and point lights who are represented as luminous intensity
	// but who must be converted to luminous irradiance for surface lighting calculation
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );

	if( cutoffDistance > 0.0 ) {

		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );

	}

	return distanceFalloff;

#else

	if( cutoffDistance > 0.0 && decayExponent > 0.0 ) {

		return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );

	}

	return 1.0;

#endif

}

vec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {

	return RECIPROCAL_PI * diffuseColor;

} // validated

vec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {

	// Original approximation by Christophe Schlick '94
	// float fresnel = pow( 1.0 - dotLH, 5.0 );

	// Optimized variant (presented by Epic at SIGGRAPH '13)
	// https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf
	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );

	return ( 1.0 - specularColor ) * fresnel + specularColor;

} // validated

vec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {

	// See F_Schlick
	float fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );
	vec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;

	return Fr * fresnel + F0;

}


// Microfacet Models for Refraction through Rough Surfaces - equation (34)
// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html
// alpha is "roughness squared" in Disney\u2019s reparameterization
float G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {

	// geometry term (normalized) = G(l)\u22C5G(v) / 4(n\u22C5l)(n\u22C5v)
	// also see #12151

	float a2 = pow2( alpha );

	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );

	return 1.0 / ( gl * gv );

} // validated

// Moving Frostbite to Physically Based Rendering 3.0 - page 12, listing 2
// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
float G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {

	float a2 = pow2( alpha );

	// dotNL and dotNV are explicitly swapped. This is not a mistake.
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );

	return 0.5 / max( gv + gl, EPSILON );

}

// Microfacet Models for Refraction through Rough Surfaces - equation (33)
// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html
// alpha is "roughness squared" in Disney\u2019s reparameterization
float D_GGX( const in float alpha, const in float dotNH ) {

	float a2 = pow2( alpha );

	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0; // avoid alpha = 0 with dotNH = 1

	return RECIPROCAL_PI * a2 / pow2( denom );

}

// GGX Distribution, Schlick Fresnel, GGX-Smith Visibility
vec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {

	float alpha = pow2( roughness ); // UE4's roughness

	vec3 halfDir = normalize( incidentLight.direction + viewDir );

	float dotNL = saturate( dot( normal, incidentLight.direction ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );

	vec3 F = F_Schlick( specularColor, dotLH );

	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );

	float D = D_GGX( alpha, dotNH );

	return F * ( G * D );

} // validated

// Rect Area Light

// Real-Time Polygonal-Light Shading with Linearly Transformed Cosines
// by Eric Heitz, Jonathan Dupuy, Stephen Hill and David Neubelt
// code: https://github.com/selfshadow/ltc_code/

vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {

	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;

	float dotNV = saturate( dot( N, V ) );

	// texture parameterized by sqrt( GGX alpha ) and sqrt( 1 - cos( theta ) )
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );

	uv = uv * LUT_SCALE + LUT_BIAS;

	return uv;

}

float LTC_ClippedSphereFormFactor( const in vec3 f ) {

	// Real-Time Area Lighting: a Journey from Research to Production (p.102)
	// An approximation of the form factor of a horizon-clipped rectangle.

	float l = length( f );

	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );

}

vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {

	float x = dot( v1, v2 );

	float y = abs( x );

	// rational polynomial approximation to theta / sin( theta ) / 2PI
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;

	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;

	return cross( v1, v2 ) * theta_sintheta;

}

vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {

	// bail if point is on back side of plane of light
	// assumes ccw winding order of light vertices
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );

	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );

	// construct orthonormal basis around N
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 ); // negated from paper; possibly due to a different handedness of world coordinate system

	// compute transform
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );

	// transform rect
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );

	// project rect onto sphere
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );

	// calculate vector form factor
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );

	// adjust for horizon clipping
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );

/*
	// alternate method of adjusting for horizon clipping (see referece)
	// refactoring required
	float len = length( vectorFormFactor );
	float z = vectorFormFactor.z / len;

	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;

	// tabulated horizon-clipped sphere, apparently...
	vec2 uv = vec2( z * 0.5 + 0.5, len );
	uv = uv * LUT_SCALE + LUT_BIAS;

	float scale = texture2D( ltc_2, uv ).w;

	float result = len * scale;
*/

	return vec3( result );

}

// End Rect Area Light

// ref: https://www.unrealengine.com/blog/physically-based-shading-on-mobile - environmentBRDF for GGX on mobile
vec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {

	float dotNV = saturate( dot( normal, viewDir ) );

	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );

	return specularColor * brdf.x + brdf.y;

} // validated

// Fdez-Ag\xFCera's "Multiple-Scattering Microfacet Model for Real-Time Image Based Lighting"
// Approximates multiscattering in order to preserve energy.
// http://www.jcgt.org/published/0008/01/03/
void BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {

	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );

	vec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );
	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );
	vec3 FssEss = F * brdf.x + brdf.y;

	float Ess = brdf.x + brdf.y;
	float Ems = 1.0 - Ess;

	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619; // 1/21
	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );

	singleScatter += FssEss;
	multiScatter += Fms * Ems;

}

float G_BlinnPhong_Implicit( /* const in float dotNL, const in float dotNV */ ) {

	// geometry term is (n dot l)(n dot v) / 4(n dot l)(n dot v)
	return 0.25;

}

float D_BlinnPhong( const in float shininess, const in float dotNH ) {

	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );

}

vec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {

	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );

	//float dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );
	//float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
	float dotNH = saturate( dot( geometry.normal, halfDir ) );
	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );

	vec3 F = F_Schlick( specularColor, dotLH );

	float G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );

	float D = D_BlinnPhong( shininess, dotNH );

	return F * ( G * D );

} // validated

// source: http://simonstechblog.blogspot.ca/2011/12/microfacet-brdf.html
float GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {
	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );
}

float BlinnExponentToGGXRoughness( const in float blinnExponent ) {
	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );
}

#if defined( USE_SHEEN )

// https://github.com/google/filament/blob/master/shaders/src/brdf.fs#L94
float D_Charlie(float roughness, float NoH) {
	// Estevez and Kulla 2017, "Production Friendly Microfacet Sheen BRDF"
	float invAlpha = 1.0 / roughness;
	float cos2h = NoH * NoH;
	float sin2h = max(1.0 - cos2h, 0.0078125); // 2^(-14/2), so sin2h^2 > 0 in fp16
	return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);
}

// https://github.com/google/filament/blob/master/shaders/src/brdf.fs#L136
float V_Neubelt(float NoV, float NoL) {
	// Neubelt and Pettineo 2013, "Crafting a Next-gen Material Pipeline for The Order: 1886"
	return saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));
}

vec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {

	vec3 N = geometry.normal;
	vec3 V = geometry.viewDir;

	vec3 H = normalize( V + L );
	float dotNH = saturate( dot( N, H ) );

	return specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );

}

#endif
`,s1=`
#ifdef USE_BUMPMAP

	uniform sampler2D bumpMap;
	uniform float bumpScale;

	// Bump Mapping Unparametrized Surfaces on the GPU by Morten S. Mikkelsen
	// http://api.unrealengine.com/attachments/Engine/Rendering/LightingAndShadows/BumpMappingWithoutTangentSpace/mm_sfgrad_bump.pdf

	// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)

	vec2 dHdxy_fwd() {

		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );

		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;

		return vec2( dBx, dBy );

	}

	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {

		// Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988

		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );
		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );
		vec3 vN = surf_norm;		// normalized

		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );

		float fDet = dot( vSigmaX, R1 ) * faceDirection;

		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );

	}

#endif
`,a1=`
#if NUM_CLIPPING_PLANES > 0

	vec4 plane;

	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {

		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;

	}
	#pragma unroll_loop_end

	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES

		bool clipped = true;

		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {

			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;

		}
		#pragma unroll_loop_end

		if ( clipped ) discard;

	#endif

#endif
`,o1=`
#if NUM_CLIPPING_PLANES > 0

	varying vec3 vClipPosition;

	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];

#endif
`,l1=`
#if NUM_CLIPPING_PLANES > 0

	varying vec3 vClipPosition;

#endif
`,c1=`
#if NUM_CLIPPING_PLANES > 0

	vClipPosition = - mvPosition.xyz;

#endif
`,h1=`
#if defined( USE_COLOR_ALPHA )

	diffuseColor *= vColor;

#elif defined( USE_COLOR )

	diffuseColor.rgb *= vColor;

#endif
`,u1=`
#if defined( USE_COLOR_ALPHA )

	varying vec4 vColor;

#elif defined( USE_COLOR )

	varying vec3 vColor;

#endif
`,d1=`
#if defined( USE_COLOR_ALPHA )

	varying vec4 vColor;

#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )

	varying vec3 vColor;

#endif
`,f1=`
#if defined( USE_COLOR_ALPHA )

	vColor = vec4( 1.0 );

#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )

	vColor = vec3( 1.0 );

#endif

#ifdef USE_COLOR

	vColor *= color;

#endif

#ifdef USE_INSTANCING_COLOR

	vColor.xyz *= instanceColor.xyz;

#endif
`,p1=`
#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6

#ifndef saturate
// <tonemapping_pars_fragment> may have defined saturate() already
#define saturate(a) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement(a) ( 1.0 - saturate( a ) )

float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
// expects values in the range of [0,1]x[0,1], returns values in the [0,1] range.
// do not collapse into a single function per: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract(sin(sn) * c);
}

#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif

struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};

struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};

struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef CLEARCOAT
	vec3 clearcoatNormal;
#endif
};

vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

}

vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {

	// dir can be either a direction vector or a normal vector
	// upper-left 3x3 of matrix is assumed to be orthogonal

	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );

}

vec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {

	float distance = dot( planeNormal, point - pointOnPlane );

	return - distance * planeNormal + point;

}

float sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {

	return sign( dot( point - pointOnPlane, planeNormal ) );

}

vec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {

	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;

}

mat3 transposeMat3( const in mat3 m ) {

	mat3 tmp;

	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );

	return tmp;

}

// https://en.wikipedia.org/wiki/Relative_luminance
float linearToRelativeLuminance( const in vec3 color ) {

	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );

	return dot( weights, color.rgb );

}

bool isPerspectiveMatrix( mat4 m ) {

	return m[ 2 ][ 3 ] == - 1.0;

}

vec2 equirectUv( in vec3 dir ) {

	// dir is assumed to be unit length

	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;

	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;

	return vec2( u, v );

}
`,m1=`
#ifdef ENVMAP_TYPE_CUBE_UV

	#define cubeUV_maxMipLevel 8.0
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_maxTileSize 256.0
	#define cubeUV_minTileSize 16.0

	// These shader functions convert between the UV coordinates of a single face of
	// a cubemap, the 0-5 integer index of a cube face, and the direction vector for
	// sampling a textureCube (not generally normalized ).

	float getFace( vec3 direction ) {

		vec3 absDirection = abs( direction );

		float face = - 1.0;

		if ( absDirection.x > absDirection.z ) {

			if ( absDirection.x > absDirection.y )

				face = direction.x > 0.0 ? 0.0 : 3.0;

			else

				face = direction.y > 0.0 ? 1.0 : 4.0;

		} else {

			if ( absDirection.z > absDirection.y )

				face = direction.z > 0.0 ? 2.0 : 5.0;

			else

				face = direction.y > 0.0 ? 1.0 : 4.0;

		}

		return face;

	}

	// RH coordinate system; PMREM face-indexing convention
	vec2 getUV( vec3 direction, float face ) {

		vec2 uv;

		if ( face == 0.0 ) {

			uv = vec2( direction.z, direction.y ) / abs( direction.x ); // pos x

		} else if ( face == 1.0 ) {

			uv = vec2( - direction.x, - direction.z ) / abs( direction.y ); // pos y

		} else if ( face == 2.0 ) {

			uv = vec2( - direction.x, direction.y ) / abs( direction.z ); // pos z

		} else if ( face == 3.0 ) {

			uv = vec2( - direction.z, direction.y ) / abs( direction.x ); // neg x

		} else if ( face == 4.0 ) {

			uv = vec2( - direction.x, direction.z ) / abs( direction.y ); // neg y

		} else {

			uv = vec2( direction.x, direction.y ) / abs( direction.z ); // neg z

		}

		return 0.5 * ( uv + 1.0 );

	}

	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {

		float face = getFace( direction );

		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );

		mipInt = max( mipInt, cubeUV_minMipLevel );

		float faceSize = exp2( mipInt );

		float texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );

		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );

		vec2 f = fract( uv );

		uv += 0.5 - f;

		if ( face > 2.0 ) {

			uv.y += faceSize;

			face -= 3.0;

		}

		uv.x += face * faceSize;

		if ( mipInt < cubeUV_maxMipLevel ) {

			uv.y += 2.0 * cubeUV_maxTileSize;

		}

		uv.y += filterInt * 2.0 * cubeUV_minTileSize;

		uv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );

		uv *= texelSize;

		vec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;

		uv.x += texelSize;

		vec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;

		uv.y += texelSize;

		vec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;

		uv.x -= texelSize;

		vec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;

		vec3 tm = mix( tl, tr, f.x );

		vec3 bm = mix( bl, br, f.x );

		return mix( tm, bm, f.y );

	}

	// These defines must match with PMREMGenerator

	#define r0 1.0
	#define v0 0.339
	#define m0 - 2.0
	#define r1 0.8
	#define v1 0.276
	#define m1 - 1.0
	#define r4 0.4
	#define v4 0.046
	#define m4 2.0
	#define r5 0.305
	#define v5 0.016
	#define m5 3.0
	#define r6 0.21
	#define v6 0.0038
	#define m6 4.0

	float roughnessToMip( float roughness ) {

		float mip = 0.0;

		if ( roughness >= r1 ) {

			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;

		} else if ( roughness >= r4 ) {

			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;

		} else if ( roughness >= r5 ) {

			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;

		} else if ( roughness >= r6 ) {

			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;

		} else {

			mip = - 2.0 * log2( 1.16 * roughness ); // 1.16 = 1.79^0.25
		}

		return mip;

	}

	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {

		float mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );

		float mipF = fract( mip );

		float mipInt = floor( mip );

		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );

		if ( mipF == 0.0 ) {

			return vec4( color0, 1.0 );

		} else {

			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );

			return vec4( mix( color0, color1, mipF ), 1.0 );

		}

	}

#endif
`,g1=`
vec3 transformedNormal = objectNormal;

#ifdef USE_INSTANCING

	// this is in lieu of a per-instance normal-matrix
	// shear transforms in the instance matrix are not supported

	mat3 m = mat3( instanceMatrix );

	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );

	transformedNormal = m * transformedNormal;

#endif

transformedNormal = normalMatrix * transformedNormal;

#ifdef FLIP_SIDED

	transformedNormal = - transformedNormal;

#endif

#ifdef USE_TANGENT

	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;

	#ifdef FLIP_SIDED

		transformedTangent = - transformedTangent;

	#endif

#endif
`,x1=`
#ifdef USE_DISPLACEMENTMAP

	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;

#endif
`,y1=`
#ifdef USE_DISPLACEMENTMAP

	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );

#endif
`,_1=`
#ifdef USE_EMISSIVEMAP

	vec4 emissiveColor = texture2D( emissiveMap, vUv );

	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;

	totalEmissiveRadiance *= emissiveColor.rgb;

#endif
`,v1=`
#ifdef USE_EMISSIVEMAP

	uniform sampler2D emissiveMap;

#endif
`,M1=`
gl_FragColor = linearToOutputTexel( gl_FragColor );
`,b1=`
// For a discussion of what this is, please read this: http://lousodrome.net/blog/light/2013/05/26/gamma-correct-and-hdr-rendering-in-a-32-bits-buffer/

vec4 LinearToLinear( in vec4 value ) {
	return value;
}

vec4 GammaToLinear( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );
}

vec4 LinearToGamma( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );
}

vec4 sRGBToLinear( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}

vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}

vec4 RGBEToLinear( in vec4 value ) {
	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );
}

vec4 LinearToRGBE( in vec4 value ) {
	float maxComponent = max( max( value.r, value.g ), value.b );
	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );
	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );
	// return vec4( value.brg, ( 3.0 + 128.0 ) / 256.0 );
}

// reference: http://iwasbeingirony.blogspot.ca/2010/06/difference-between-rgbm-and-rgbd.html
vec4 RGBMToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * value.a * maxRange, 1.0 );
}

vec4 LinearToRGBM( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );
	M = ceil( M * 255.0 ) / 255.0;
	return vec4( value.rgb / ( M * maxRange ), M );
}

// reference: http://iwasbeingirony.blogspot.ca/2010/06/difference-between-rgbm-and-rgbd.html
vec4 RGBDToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );
}

vec4 LinearToRGBD( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float D = max( maxRange / maxRGB, 1.0 );
	// NOTE: The implementation with min causes the shader to not compile on
	// a common Alcatel A502DL in Chrome 78/Android 8.1. Some research suggests 
	// that the chipset is Mediatek MT6739 w/ IMG PowerVR GE8100 GPU.
	// D = min( floor( D ) / 255.0, 1.0 );
	D = clamp( floor( D ) / 255.0, 0.0, 1.0 );
	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );
}

// LogLuv reference: http://graphicrants.blogspot.ca/2009/04/rgbm-color-encoding.html

// M matrix, for encoding
const mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );
vec4 LinearToLogLuv( in vec4 value ) {
	vec3 Xp_Y_XYZp = cLogLuvM * value.rgb;
	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );
	vec4 vResult;
	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;
	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;
	vResult.w = fract( Le );
	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;
	return vResult;
}

// Inverse M matrix, for decoding
const mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );
vec4 LogLuvToLinear( in vec4 value ) {
	float Le = value.z * 255.0 + value.w;
	vec3 Xp_Y_XYZp;
	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );
	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;
	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;
	vec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;
	return vec4( max( vRGB, 0.0 ), 1.0 );
}
`,w1=`
#ifdef USE_ENVMAP

	#ifdef ENV_WORLDPOS

		vec3 cameraToFrag;

		if ( isOrthographic ) {

			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );

		} else {

			cameraToFrag = normalize( vWorldPosition - cameraPosition );

		}

		// Transforming Normal Vectors with the Inverse Transformation
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );

		#ifdef ENVMAP_MODE_REFLECTION

			vec3 reflectVec = reflect( cameraToFrag, worldNormal );

		#else

			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );

		#endif

	#else

		vec3 reflectVec = vReflect;

	#endif

	#ifdef ENVMAP_TYPE_CUBE

		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );

	#elif defined( ENVMAP_TYPE_CUBE_UV )

		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );

	#else

		vec4 envColor = vec4( 0.0 );

	#endif

	#ifndef ENVMAP_TYPE_CUBE_UV

		envColor = envMapTexelToLinear( envColor );

	#endif

	#ifdef ENVMAP_BLENDING_MULTIPLY

		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );

	#elif defined( ENVMAP_BLENDING_MIX )

		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );

	#elif defined( ENVMAP_BLENDING_ADD )

		outgoingLight += envColor.xyz * specularStrength * reflectivity;

	#endif

#endif
`,S1=`
#ifdef USE_ENVMAP

	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform int maxMipLevel;

	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif
`,E1=`
#ifdef USE_ENVMAP

	uniform float reflectivity;

	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )

		#define ENV_WORLDPOS

	#endif

	#ifdef ENV_WORLDPOS

		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif

#endif
`,A1=`
#ifdef USE_ENVMAP

	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )

		#define ENV_WORLDPOS

	#endif

	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;

	#else

		varying vec3 vReflect;
		uniform float refractionRatio;

	#endif

#endif
`,T1=`
#ifdef USE_ENVMAP

	#ifdef ENV_WORLDPOS

		vWorldPosition = worldPosition.xyz;

	#else

		vec3 cameraToVertex;

		if ( isOrthographic ) {

			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );

		} else {

			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );

		}

		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );

		#ifdef ENVMAP_MODE_REFLECTION

			vReflect = reflect( cameraToVertex, worldNormal );

		#else

			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );

		#endif

	#endif

#endif
`,L1=`
#ifdef USE_FOG

	fogDepth = - mvPosition.z;

#endif
`,R1=`
#ifdef USE_FOG

	varying float fogDepth;

#endif
`,C1=`
#ifdef USE_FOG

	#ifdef FOG_EXP2

		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );

	#else

		float fogFactor = smoothstep( fogNear, fogFar, fogDepth );

	#endif

	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );

#endif
`,P1=`
#ifdef USE_FOG

	uniform vec3 fogColor;
	varying float fogDepth;

	#ifdef FOG_EXP2

		uniform float fogDensity;

	#else

		uniform float fogNear;
		uniform float fogFar;

	#endif

#endif
`,D1=`

#ifdef USE_GRADIENTMAP

	uniform sampler2D gradientMap;

#endif

vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {

	// dotNL will be from -1.0 to 1.0
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );

	#ifdef USE_GRADIENTMAP

		return texture2D( gradientMap, coord ).rgb;

	#else

		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );

	#endif

}
`,F1=`
#ifdef USE_LIGHTMAP

	vec4 lightMapTexel= texture2D( lightMap, vUv2 );
	reflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity; // factor of PI should not be present; included here to prevent breakage

#endif
`,I1=`
#ifdef USE_LIGHTMAP

	uniform sampler2D lightMap;
	uniform float lightMapIntensity;

#endif
`,z1=`
vec3 diffuse = vec3( 1.0 );

GeometricContext geometry;
geometry.position = mvPosition.xyz;
geometry.normal = normalize( transformedNormal );
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );

GeometricContext backGeometry;
backGeometry.position = geometry.position;
backGeometry.normal = -geometry.normal;
backGeometry.viewDir = geometry.viewDir;

vLightFront = vec3( 0.0 );
vIndirectFront = vec3( 0.0 );
#ifdef DOUBLE_SIDED
	vLightBack = vec3( 0.0 );
	vIndirectBack = vec3( 0.0 );
#endif

IncidentLight directLight;
float dotNL;
vec3 directLightColor_Diffuse;

vIndirectFront += getAmbientLightIrradiance( ambientLightColor );

vIndirectFront += getLightProbeIrradiance( lightProbe, geometry );

#ifdef DOUBLE_SIDED

	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );

	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );

#endif

#if NUM_POINT_LIGHTS > 0

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {

		getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );

		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;

		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;

		#ifdef DOUBLE_SIDED

			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;

		#endif

	}
	#pragma unroll_loop_end

#endif

#if NUM_SPOT_LIGHTS > 0

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {

		getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );

		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;

		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;

		#ifdef DOUBLE_SIDED

			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;

		#endif
	}
	#pragma unroll_loop_end

#endif

/*
#if NUM_RECT_AREA_LIGHTS > 0

	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {

		// TODO (abelnation): implement

	}

#endif
*/

#if NUM_DIR_LIGHTS > 0

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {

		getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );

		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;

		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;

		#ifdef DOUBLE_SIDED

			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;

		#endif

	}
	#pragma unroll_loop_end

#endif

#if NUM_HEMI_LIGHTS > 0

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {

		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );

		#ifdef DOUBLE_SIDED

			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );

		#endif

	}
	#pragma unroll_loop_end

#endif
`,N1=`
uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];

// get the irradiance (radiance convolved with cosine lobe) at the point 'normal' on the unit sphere
// source: https://graphics.stanford.edu/papers/envmap/envmap.pdf
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {

	// normal is assumed to have unit length

	float x = normal.x, y = normal.y, z = normal.z;

	// band 0
	vec3 result = shCoefficients[ 0 ] * 0.886227;

	// band 1
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;

	// band 2
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );

	return result;

}

vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {

	vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );

	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );

	return irradiance;

}

vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {

	vec3 irradiance = ambientLightColor;

	#ifndef PHYSICALLY_CORRECT_LIGHTS

		irradiance *= PI;

	#endif

	return irradiance;

}

#if NUM_DIR_LIGHTS > 0

	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};

	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];

	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {

		directLight.color = directionalLight.color;
		directLight.direction = directionalLight.direction;
		directLight.visible = true;

	}

#endif


#if NUM_POINT_LIGHTS > 0

	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};

	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];

	// directLight is an out parameter as having it as a return value caused compiler errors on some devices
	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {

		vec3 lVector = pointLight.position - geometry.position;
		directLight.direction = normalize( lVector );

		float lightDistance = length( lVector );

		directLight.color = pointLight.color;
		directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );
		directLight.visible = ( directLight.color != vec3( 0.0 ) );

	}

#endif


#if NUM_SPOT_LIGHTS > 0

	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};

	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];

	// directLight is an out parameter as having it as a return value caused compiler errors on some devices
	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {

		vec3 lVector = spotLight.position - geometry.position;
		directLight.direction = normalize( lVector );

		float lightDistance = length( lVector );
		float angleCos = dot( directLight.direction, spotLight.direction );

		if ( angleCos > spotLight.coneCos ) {

			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );

			directLight.color = spotLight.color;
			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );
			directLight.visible = true;

		} else {

			directLight.color = vec3( 0.0 );
			directLight.visible = false;

		}
	}

#endif


#if NUM_RECT_AREA_LIGHTS > 0

	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};

	// Pre-computed values of LinearTransformedCosine approximation of BRDF
	// BRDF approximation Texture is 64x64
	uniform sampler2D ltc_1; // RGBA Float
	uniform sampler2D ltc_2; // RGBA Float

	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];

#endif


#if NUM_HEMI_LIGHTS > 0

	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};

	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];

	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {

		float dotNL = dot( geometry.normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;

		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );

		#ifndef PHYSICALLY_CORRECT_LIGHTS

			irradiance *= PI;

		#endif

		return irradiance;

	}

#endif
`,B1=`
#if defined( USE_ENVMAP )

	#ifdef ENVMAP_MODE_REFRACTION
		uniform float refractionRatio;
	#endif

	vec3 getLightProbeIndirectIrradiance( /*const in SpecularLightProbe specularLightProbe,*/ const in GeometricContext geometry, const in int maxMIPLevel ) {

		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );

		#ifdef ENVMAP_TYPE_CUBE

			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );

			// TODO: replace with properly filtered cubemaps and access the irradiance LOD level, be it the last LOD level
			// of a specular cubemap, or just the default level of a specially created irradiance cubemap.

			#ifdef TEXTURE_LOD_EXT

				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );

			#else

				// force the bias high to get the last LOD level as it is the most blurred.
				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );

			#endif

			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;

		#elif defined( ENVMAP_TYPE_CUBE_UV )

			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );

		#else

			vec4 envMapColor = vec4( 0.0 );

		#endif

		return PI * envMapColor.rgb * envMapIntensity;

	}

	// Trowbridge-Reitz distribution to Mip level, following the logic of http://casual-effects.blogspot.ca/2011/08/plausible-environment-lighting-in-two.html
	float getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {

		float maxMIPLevelScalar = float( maxMIPLevel );

		float sigma = PI * roughness * roughness / ( 1.0 + roughness );
		float desiredMIPLevel = maxMIPLevelScalar + log2( sigma );

		// clamp to allowable LOD ranges.
		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );

	}

	vec3 getLightProbeIndirectRadiance( /*const in SpecularLightProbe specularLightProbe,*/ const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {

		#ifdef ENVMAP_MODE_REFLECTION

			vec3 reflectVec = reflect( -viewDir, normal );

			// Mixing the reflection with the normal is more accurate and keeps rough objects from gathering light from behind their tangent plane.
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );

		#else

			vec3 reflectVec = refract( -viewDir, normal, refractionRatio );

		#endif

		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );

		float specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );

		#ifdef ENVMAP_TYPE_CUBE

			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );

			#ifdef TEXTURE_LOD_EXT

				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );

			#else

				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );

			#endif

			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;

		#elif defined( ENVMAP_TYPE_CUBE_UV )

			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );

		#endif

		return envMapColor.rgb * envMapIntensity;

	}

#endif
`,O1=`
ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;
`,U1=`
varying vec3 vViewPosition;

#ifndef FLAT_SHADED

	varying vec3 vNormal;

#endif


struct ToonMaterial {

	vec3 diffuseColor;

};

void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {

	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;

	#ifndef PHYSICALLY_CORRECT_LIGHTS

		irradiance *= PI; // punctual light

	#endif

	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );

}

void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {

	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );

}

#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon

#define Material_LightProbeLOD( material )	(0)
`,H1=`
BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;
`,G1=`
varying vec3 vViewPosition;

#ifndef FLAT_SHADED

	varying vec3 vNormal;

#endif


struct BlinnPhongMaterial {

	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;

};

void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {

	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;

	#ifndef PHYSICALLY_CORRECT_LIGHTS

		irradiance *= PI; // punctual light

	#endif

	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );

	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;

}

void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {

	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );

}

#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong

#define Material_LightProbeLOD( material )	(0)
`,k1=`
PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );

vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );

material.specularRoughness = max( roughnessFactor, 0.0525 );// 0.0525 corresponds to the base mip of a 256 cubemap.
material.specularRoughness += geometryRoughness;
material.specularRoughness = min( material.specularRoughness, 1.0 );

#ifdef REFLECTIVITY

	material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );

#else

	material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );

#endif

#ifdef CLEARCOAT

	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;

	#ifdef USE_CLEARCOATMAP

		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;

	#endif

	#ifdef USE_CLEARCOAT_ROUGHNESSMAP

		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;

	#endif

	material.clearcoat = saturate( material.clearcoat ); // Burley clearcoat model
	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );

#endif

#ifdef USE_SHEEN

	material.sheenColor = sheen;

#endif
`,V1=`
struct PhysicalMaterial {

	vec3 diffuseColor;
	float specularRoughness;
	vec3 specularColor;

#ifdef CLEARCOAT
	float clearcoat;
	float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	vec3 sheenColor;
#endif

};

#define MAXIMUM_SPECULAR_COEFFICIENT 0.16
#define DEFAULT_SPECULAR_COEFFICIENT 0.04

// Clear coat directional hemishperical reflectance (this approximation should be improved)
float clearcoatDHRApprox( const in float roughness, const in float dotNL ) {

	return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );

}

#if NUM_RECT_AREA_LIGHTS > 0

	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {

		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.specularRoughness;

		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight; // counterclockwise; light shines in local neg z direction
		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;

		vec2 uv = LTC_Uv( normal, viewDir, roughness );

		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );

		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);

		// LTC Fresnel Approximation by Stephen Hill
		// http://blog.selfshadow.com/publications/s2016-advances/s2016_ltc_fresnel.pdf
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );

		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );

		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );

	}

#endif

void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {

	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );

	vec3 irradiance = dotNL * directLight.color;

	#ifndef PHYSICALLY_CORRECT_LIGHTS

		irradiance *= PI; // punctual light

	#endif

	#ifdef CLEARCOAT

		float ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );

		vec3 ccIrradiance = ccDotNL * directLight.color;

		#ifndef PHYSICALLY_CORRECT_LIGHTS

			ccIrradiance *= PI; // punctual light

		#endif

		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );

		reflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );

	#else

		float clearcoatDHR = 0.0;

	#endif

	#ifdef USE_SHEEN
		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(
			material.specularRoughness,
			directLight.direction,
			geometry,
			material.sheenColor
		);
	#else
		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);
	#endif

	reflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}

void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {

	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );

}

void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {

	#ifdef CLEARCOAT

		float ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );

		reflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );

		float ccDotNL = ccDotNV;
		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );

	#else

		float clearcoatDHR = 0.0;

	#endif

	float clearcoatInv = 1.0 - clearcoatDHR;

	// Both indirect specular and indirect diffuse light accumulate here

	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;

	BRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );

	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );

	reflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;

	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;

}

#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical

// ref: https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {

	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );

}
`,W1=`
/**
 * This is a template that can be used to light a material, it uses pluggable
 * RenderEquations (RE)for specific lighting scenarios.
 *
 * Instructions for use:
 * - Ensure that both RE_Direct, RE_IndirectDiffuse and RE_IndirectSpecular are defined
 * - If you have defined an RE_IndirectSpecular, you need to also provide a Material_LightProbeLOD. <---- ???
 * - Create a material parameter that is to be passed as the third parameter to your lighting functions.
 *
 * TODO:
 * - Add area light support.
 * - Add sphere light support.
 * - Add diffuse light probe (irradiance cubemap) support.
 */

GeometricContext geometry;

geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );

#ifdef CLEARCOAT

	geometry.clearcoatNormal = clearcoatNormal;

#endif

IncidentLight directLight;

#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )

	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {

		pointLight = pointLights[ i ];

		getPointDirectLightIrradiance( pointLight, geometry, directLight );

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif

		RE_Direct( directLight, geometry, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )

	SpotLight spotLight;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {

		spotLight = spotLights[ i ];

		getSpotDirectLightIrradiance( spotLight, geometry, directLight );

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif

		RE_Direct( directLight, geometry, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )

	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {

		directionalLight = directionalLights[ i ];

		getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif

		RE_Direct( directLight, geometry, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )

	RectAreaLight rectAreaLight;

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {

		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if defined( RE_IndirectDiffuse )

	vec3 iblIrradiance = vec3( 0.0 );

	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );

	irradiance += getLightProbeIrradiance( lightProbe, geometry );

	#if ( NUM_HEMI_LIGHTS > 0 )

		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {

			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );

		}
		#pragma unroll_loop_end

	#endif

#endif

#if defined( RE_IndirectSpecular )

	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );

#endif
`,$1=`
#if defined( RE_IndirectDiffuse )

	#ifdef USE_LIGHTMAP

		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;

		#ifndef PHYSICALLY_CORRECT_LIGHTS

			lightMapIrradiance *= PI; // factor of PI should not be present; included here to prevent breakage

		#endif

		irradiance += lightMapIrradiance;

	#endif

	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )

		iblIrradiance += getLightProbeIndirectIrradiance( /*lightProbe,*/ geometry, maxMipLevel );

	#endif

#endif

#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )

	radiance += getLightProbeIndirectRadiance( /*specularLightProbe,*/ geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );

	#ifdef CLEARCOAT

		clearcoatRadiance += getLightProbeIndirectRadiance( /*specularLightProbe,*/ geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );

	#endif

#endif
`,X1=`
#if defined( RE_IndirectDiffuse )

	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );

#endif

#if defined( RE_IndirectSpecular )

	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );

#endif
`,q1=`
#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )

	// Doing a strict comparison with == 1.0 can cause noise artifacts
	// on some platforms. See issue #17623.
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;

#endif
`,Y1=`
#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )

	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;

#endif
`,j1=`
#ifdef USE_LOGDEPTHBUF

	#ifdef USE_LOGDEPTHBUF_EXT

		varying float vFragDepth;
		varying float vIsPerspective;

	#else

		uniform float logDepthBufFC;

	#endif

#endif
`,Z1=`
#ifdef USE_LOGDEPTHBUF

	#ifdef USE_LOGDEPTHBUF_EXT

		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );

	#else

		if ( isPerspectiveMatrix( projectionMatrix ) ) {

			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;

			gl_Position.z *= gl_Position.w;

		}

	#endif

#endif
`,J1=`
#ifdef USE_MAP

	vec4 texelColor = texture2D( map, vUv );

	texelColor = mapTexelToLinear( texelColor );
	diffuseColor *= texelColor;

#endif
`,Q1=`
#ifdef USE_MAP

	uniform sampler2D map;

#endif
`,K1=`
#if defined( USE_MAP ) || defined( USE_ALPHAMAP )

	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;

#endif

#ifdef USE_MAP

	vec4 mapTexel = texture2D( map, uv );
	diffuseColor *= mapTexelToLinear( mapTexel );

#endif

#ifdef USE_ALPHAMAP

	diffuseColor.a *= texture2D( alphaMap, uv ).g;

#endif
`,tE=`
#if defined( USE_MAP ) || defined( USE_ALPHAMAP )

	uniform mat3 uvTransform;

#endif

#ifdef USE_MAP

	uniform sampler2D map;

#endif

#ifdef USE_ALPHAMAP

	uniform sampler2D alphaMap;

#endif
`,eE=`
float metalnessFactor = metalness;

#ifdef USE_METALNESSMAP

	vec4 texelMetalness = texture2D( metalnessMap, vUv );

	// reads channel B, compatible with a combined OcclusionRoughnessMetallic (RGB) texture
	metalnessFactor *= texelMetalness.b;

#endif
`,iE=`
#ifdef USE_METALNESSMAP

	uniform sampler2D metalnessMap;

#endif
`,nE=`
#ifdef USE_MORPHNORMALS

	// morphTargetBaseInfluence is set based on BufferGeometry.morphTargetsRelative value:
	// When morphTargetsRelative is false, this is set to 1 - sum(influences); this results in normal = sum((target - base) * influence)
	// When morphTargetsRelative is true, this is set to 1; as a result, all morph targets are simply added to the base after weighting
	objectNormal *= morphTargetBaseInfluence;
	objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
	objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
	objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
	objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];

#endif
`,rE=`
#ifdef USE_MORPHTARGETS

	uniform float morphTargetBaseInfluence;

	#ifndef USE_MORPHNORMALS

		uniform float morphTargetInfluences[ 8 ];

	#else

		uniform float morphTargetInfluences[ 4 ];

	#endif

#endif
`,sE=`
#ifdef USE_MORPHTARGETS

	// morphTargetBaseInfluence is set based on BufferGeometry.morphTargetsRelative value:
	// When morphTargetsRelative is false, this is set to 1 - sum(influences); this results in position = sum((target - base) * influence)
	// When morphTargetsRelative is true, this is set to 1; as a result, all morph targets are simply added to the base after weighting
	transformed *= morphTargetBaseInfluence;
	transformed += morphTarget0 * morphTargetInfluences[ 0 ];
	transformed += morphTarget1 * morphTargetInfluences[ 1 ];
	transformed += morphTarget2 * morphTargetInfluences[ 2 ];
	transformed += morphTarget3 * morphTargetInfluences[ 3 ];

	#ifndef USE_MORPHNORMALS

		transformed += morphTarget4 * morphTargetInfluences[ 4 ];
		transformed += morphTarget5 * morphTargetInfluences[ 5 ];
		transformed += morphTarget6 * morphTargetInfluences[ 6 ];
		transformed += morphTarget7 * morphTargetInfluences[ 7 ];

	#endif

#endif
`,aE=`
float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;

#ifdef FLAT_SHADED

	// Workaround for Adreno GPUs not able to do dFdx( vViewPosition )

	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
	vec3 normal = normalize( cross( fdx, fdy ) );

#else

	vec3 normal = normalize( vNormal );

	#ifdef DOUBLE_SIDED

		normal = normal * faceDirection;

	#endif

	#ifdef USE_TANGENT

		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );

		#ifdef DOUBLE_SIDED

			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;

		#endif

		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )

			mat3 vTBN = mat3( tangent, bitangent, normal );

		#endif

	#endif

#endif

// non perturbed normal for clearcoat among others

vec3 geometryNormal = normal;

`,oE=`

#ifdef OBJECTSPACE_NORMALMAP

	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0; // overrides both flatShading and attribute normals

	#ifdef FLIP_SIDED

		normal = - normal;

	#endif

	#ifdef DOUBLE_SIDED

		normal = normal * faceDirection;

	#endif

	normal = normalize( normalMatrix * normal );

#elif defined( TANGENTSPACE_NORMALMAP )

	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;

	#ifdef USE_TANGENT

		normal = normalize( vTBN * mapN );

	#else

		normal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );

	#endif

#elif defined( USE_BUMPMAP )

	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );

#endif
`,lE=`
#ifdef USE_NORMALMAP

	uniform sampler2D normalMap;
	uniform vec2 normalScale;

#endif

#ifdef OBJECTSPACE_NORMALMAP

	uniform mat3 normalMatrix;

#endif

#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )

	// Normal Mapping Without Precomputed Tangents
	// http://www.thetenthplanet.de/archives/1180

	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {

		// Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988

		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );

		vec3 N = surf_norm; // normalized

		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );

		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;

		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );

		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );

	}

#endif
`,cE=`
#ifdef CLEARCOAT

	vec3 clearcoatNormal = geometryNormal;

#endif
`,hE=`
#ifdef USE_CLEARCOAT_NORMALMAP

	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;

	#ifdef USE_TANGENT

		clearcoatNormal = normalize( vTBN * clearcoatMapN );

	#else

		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );

	#endif

#endif
`,uE=`

#ifdef USE_CLEARCOATMAP

	uniform sampler2D clearcoatMap;

#endif

#ifdef USE_CLEARCOAT_ROUGHNESSMAP

	uniform sampler2D clearcoatRoughnessMap;

#endif

#ifdef USE_CLEARCOAT_NORMALMAP

	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;

#endif
`,dE=`
vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}

vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}

const float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)
const float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)

const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );

const float ShiftRight8 = 1. / 256.;

vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8; // tidy overflow
	return r * PackUpscale;
}

float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}

vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}

// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions

float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}

float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return (( near + viewZ ) * far ) / (( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}
`,fE=`
#ifdef PREMULTIPLIED_ALPHA

	// Get get normal blending with premultipled, use with CustomBlending, OneFactor, OneMinusSrcAlphaFactor, AddEquation.
	gl_FragColor.rgb *= gl_FragColor.a;

#endif
`,pE=`
vec4 mvPosition = vec4( transformed, 1.0 );

#ifdef USE_INSTANCING

	mvPosition = instanceMatrix * mvPosition;

#endif

mvPosition = modelViewMatrix * mvPosition;

gl_Position = projectionMatrix * mvPosition;
`,mE=`
#ifdef DITHERING

	gl_FragColor.rgb = dithering( gl_FragColor.rgb );

#endif
`,gE=`
#ifdef DITHERING

	// based on https://www.shadertoy.com/view/MslGR8
	vec3 dithering( vec3 color ) {
		//Calculate grid position
		float grid_position = rand( gl_FragCoord.xy );

		//Shift the individual colors differently, thus making it even harder to see the dithering pattern
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );

		//modify shift acording to grid position.
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );

		//shift the color by dither_shift
		return color + dither_shift_RGB;
	}

#endif
`,xE=`
float roughnessFactor = roughness;

#ifdef USE_ROUGHNESSMAP

	vec4 texelRoughness = texture2D( roughnessMap, vUv );

	// reads channel G, compatible with a combined OcclusionRoughnessMetallic (RGB) texture
	roughnessFactor *= texelRoughness.g;

#endif
`,yE=`
#ifdef USE_ROUGHNESSMAP

	uniform sampler2D roughnessMap;

#endif
`,_E=`
#ifdef USE_SHADOWMAP

	#if NUM_DIR_LIGHT_SHADOWS > 0

		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];

		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};

		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];

	#endif

	#if NUM_SPOT_LIGHT_SHADOWS > 0

		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];

		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};

		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];

	#endif

	#if NUM_POINT_LIGHT_SHADOWS > 0

		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];

		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};

		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];

	#endif

	/*
	#if NUM_RECT_AREA_LIGHTS > 0

		// TODO (abelnation): create uniforms for area light shadows

	#endif
	*/

	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {

		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );

	}

	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {

		return unpackRGBATo2Half( texture2D( shadow, uv ) );

	}

	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){

		float occlusion = 1.0;

		vec2 distribution = texture2DDistribution( shadow, uv );

		float hard_shadow = step( compare , distribution.x ); // Hard Shadow

		if (hard_shadow != 1.0 ) {

			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance ); // Chebeyshevs inequality
			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 ); // 0.3 reduces light bleed
			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );

		}
		return occlusion;

	}

	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {

		float shadow = 1.0;

		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;

		// if ( something && something ) breaks ATI OpenGL shader compiler
		// if ( all( something, something ) ) using this instead

		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );

		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );

		bool frustumTest = all( frustumTestVec );

		if ( frustumTest ) {

		#if defined( SHADOWMAP_TYPE_PCF )

			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;

			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;

			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );

		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )

			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;

			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;

			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );

		#elif defined( SHADOWMAP_TYPE_VSM )

			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );

		#else // no percentage-closer filtering:

			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );

		#endif

		}

		return shadow;

	}

	// cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D
	// vector suitable for 2D texture mapping. This code uses the following layout for the
	// 2D texture:
	//
	// xzXZ
	//  y Y
	//
	// Y - Positive y direction
	// y - Negative y direction
	// X - Positive x direction
	// x - Negative x direction
	// Z - Positive z direction
	// z - Negative z direction
	//
	// Source and test bed:
	// https://gist.github.com/tschw/da10c43c467ce8afd0c4

	vec2 cubeToUV( vec3 v, float texelSizeY ) {

		// Number of texels to avoid at the edge of each square

		vec3 absV = abs( v );

		// Intersect unit cube

		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;

		// Apply scale to avoid seams

		// two texels less per square (one texel will do for NEAREST)
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );

		// Unwrap

		// space: -1 ... 1 range for each square
		//
		// #X##		dim    := ( 4 , 2 )
		//  # #		center := ( 1 , 1 )

		vec2 planar = v.xy;

		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;

		if ( absV.z >= almostOne ) {

			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;

		} else if ( absV.x >= almostOne ) {

			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;

		} else if ( absV.y >= almostOne ) {

			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;

		}

		// Transform to UV space

		// scale := 0.5 / dim
		// translate := ( center + 0.5 ) / dim
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );

	}

	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {

		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );

		// for point lights, the uniform @vShadowCoord is re-purposed to hold
		// the vector from the light to the world-space position of the fragment.
		vec3 lightToPosition = shadowCoord.xyz;

		// dp = normalized distance from light to fragment position
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear ); // need to clamp?
		dp += shadowBias;

		// bd3D = base direction 3D
		vec3 bd3D = normalize( lightToPosition );

		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )

			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;

			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );

		#else // no percentage-closer filtering

			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );

		#endif

	}

#endif
`,vE=`
#ifdef USE_SHADOWMAP

	#if NUM_DIR_LIGHT_SHADOWS > 0

		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];

		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};

		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];

	#endif

	#if NUM_SPOT_LIGHT_SHADOWS > 0

		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];

		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};

		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];

	#endif

	#if NUM_POINT_LIGHT_SHADOWS > 0

		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];

		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};

		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];

	#endif

	/*
	#if NUM_RECT_AREA_LIGHTS > 0

		// TODO (abelnation): uniforms for area light shadows

	#endif
	*/

#endif
`,ME=`
#ifdef USE_SHADOWMAP

	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0

		// Offsetting the position used for querying occlusion along the world normal can be used to reduce shadow acne.
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;

	#endif

	#if NUM_DIR_LIGHT_SHADOWS > 0

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {

		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;

	}
	#pragma unroll_loop_end

	#endif

	#if NUM_SPOT_LIGHT_SHADOWS > 0

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {

		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;

	}
	#pragma unroll_loop_end

	#endif

	#if NUM_POINT_LIGHT_SHADOWS > 0

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {

		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;

	}
	#pragma unroll_loop_end

	#endif

	/*
	#if NUM_RECT_AREA_LIGHTS > 0

		// TODO (abelnation): update vAreaShadowCoord with area light info

	#endif
	*/

#endif
`,bE=`
float getShadowMask() {

	float shadow = 1.0;

	#ifdef USE_SHADOWMAP

	#if NUM_DIR_LIGHT_SHADOWS > 0

	DirectionalLightShadow directionalLight;

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {

		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;

	}
	#pragma unroll_loop_end

	#endif

	#if NUM_SPOT_LIGHT_SHADOWS > 0

	SpotLightShadow spotLight;

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {

		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;

	}
	#pragma unroll_loop_end

	#endif

	#if NUM_POINT_LIGHT_SHADOWS > 0

	PointLightShadow pointLight;

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {

		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;

	}
	#pragma unroll_loop_end

	#endif

	/*
	#if NUM_RECT_AREA_LIGHTS > 0

		// TODO (abelnation): update shadow for Area light

	#endif
	*/

	#endif

	return shadow;

}
`,wE=`
#ifdef USE_SKINNING

	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );

#endif
`,SE=`
#ifdef USE_SKINNING

	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;

	#ifdef BONE_TEXTURE

		uniform highp sampler2D boneTexture;
		uniform int boneTextureSize;

		mat4 getBoneMatrix( const in float i ) {

			float j = i * 4.0;
			float x = mod( j, float( boneTextureSize ) );
			float y = floor( j / float( boneTextureSize ) );

			float dx = 1.0 / float( boneTextureSize );
			float dy = 1.0 / float( boneTextureSize );

			y = dy * ( y + 0.5 );

			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );

			mat4 bone = mat4( v1, v2, v3, v4 );

			return bone;

		}

	#else

		uniform mat4 boneMatrices[ MAX_BONES ];

		mat4 getBoneMatrix( const in float i ) {

			mat4 bone = boneMatrices[ int(i) ];
			return bone;

		}

	#endif

#endif
`,EE=`
#ifdef USE_SKINNING

	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );

	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;

	transformed = ( bindMatrixInverse * skinned ).xyz;

#endif
`,AE=`
#ifdef USE_SKINNING

	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;

	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;

	#ifdef USE_TANGENT

		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;

	#endif

#endif
`,TE=`
float specularStrength;

#ifdef USE_SPECULARMAP

	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;

#else

	specularStrength = 1.0;

#endif
`,LE=`
#ifdef USE_SPECULARMAP

	uniform sampler2D specularMap;

#endif
`,RE=`
#if defined( TONE_MAPPING )

	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );

#endif
`,CE=`
#ifndef saturate
// <common> may have defined saturate() already
#define saturate(a) clamp( a, 0.0, 1.0 )
#endif

uniform float toneMappingExposure;

// exposure only
vec3 LinearToneMapping( vec3 color ) {

	return toneMappingExposure * color;

}

// source: https://www.cs.utah.edu/~reinhard/cdrom/
vec3 ReinhardToneMapping( vec3 color ) {

	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );

}

// source: http://filmicworlds.com/blog/filmic-tonemapping-operators/
vec3 OptimizedCineonToneMapping( vec3 color ) {

	// optimized filmic operator by Jim Hejl and Richard Burgess-Dawson
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );

}

// source: https://github.com/selfshadow/ltc_code/blob/master/webgl/shaders/ltc/ltc_blit.fs
vec3 RRTAndODTFit( vec3 v ) {

	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;

}

// this implementation of ACES is modified to accommodate a brighter viewing environment.
// the scale factor of 1/0.6 is subjective. see discussion in #19621.

vec3 ACESFilmicToneMapping( vec3 color ) {

	// sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ), // transposed from source
		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);

	// ODT_SAT => XYZ => D60_2_D65 => sRGB
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ), // transposed from source
		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);

	color *= toneMappingExposure / 0.6;

	color = ACESInputMat * color;

	// Apply RRT and ODT
	color = RRTAndODTFit( color );

	color = ACESOutputMat * color;

	// Clamp to [0, 1]
	return saturate( color );

}

vec3 CustomToneMapping( vec3 color ) { return color; }
`,PE=`
#ifdef USE_TRANSMISSIONMAP

	totalTransmission *= texture2D( transmissionMap, vUv ).r;

#endif
`,DE=`
#ifdef USE_TRANSMISSIONMAP

	uniform sampler2D transmissionMap;

#endif
`,FE=`
#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )

	varying vec2 vUv;

#endif
`,IE=`
#ifdef USE_UV

	#ifdef UVS_VERTEX_ONLY

		vec2 vUv;

	#else

		varying vec2 vUv;

	#endif

	uniform mat3 uvTransform;

#endif
`,zE=`
#ifdef USE_UV

	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;

#endif
`,NE=`
#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )

	varying vec2 vUv2;

#endif
`,BE=`
#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )

	attribute vec2 uv2;
	varying vec2 vUv2;

	uniform mat3 uv2Transform;

#endif
`,OE=`
#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )

	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;

#endif
`,UE=`
#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )

	vec4 worldPosition = vec4( transformed, 1.0 );

	#ifdef USE_INSTANCING

		worldPosition = instanceMatrix * worldPosition;

	#endif

	worldPosition = modelMatrix * worldPosition;

#endif
`,HE=`
uniform sampler2D t2D;

varying vec2 vUv;

void main() {

	vec4 texColor = texture2D( t2D, vUv );

	gl_FragColor = mapTexelToLinear( texColor );

	#include <tonemapping_fragment>
	#include <encodings_fragment>

}
`,GE=`
varying vec2 vUv;
uniform mat3 uvTransform;

void main() {

	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;

	gl_Position = vec4( position.xy, 1.0, 1.0 );

}
`,kE=`
#include <envmap_common_pars_fragment>
uniform float opacity;

varying vec3 vWorldDirection;

#include <cube_uv_reflection_fragment>

void main() {

	vec3 vReflect = vWorldDirection;
	#include <envmap_fragment>

	gl_FragColor = envColor;
	gl_FragColor.a *= opacity;

	#include <tonemapping_fragment>
	#include <encodings_fragment>

}
`,VE=`
varying vec3 vWorldDirection;

#include <common>

void main() {

	vWorldDirection = transformDirection( position, modelMatrix );

	#include <begin_vertex>
	#include <project_vertex>

	gl_Position.z = gl_Position.w; // set z to camera.far

}
`,WE=`
#if DEPTH_PACKING == 3200

	uniform float opacity;

#endif

#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

varying vec2 vHighPrecisionZW;

void main() {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( 1.0 );

	#if DEPTH_PACKING == 3200

		diffuseColor.a = opacity;

	#endif

	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>

	#include <logdepthbuf_fragment>

	// Higher precision equivalent of gl_FragCoord.z. This assumes depthRange has been left to its default values.
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;

	#if DEPTH_PACKING == 3200

		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );

	#elif DEPTH_PACKING == 3201

		gl_FragColor = packDepthToRGBA( fragCoordZ );

	#endif

}
`,$E=`
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

// This is used for computing an equivalent of gl_FragCoord.z that is as high precision as possible.
// Some platforms compute gl_FragCoord at a lower precision which makes the manually computed value better for
// depth-based postprocessing effects. Reproduced on iPad with A10 processor / iPadOS 13.3.1.
varying vec2 vHighPrecisionZW;

void main() {

	#include <uv_vertex>

	#include <skinbase_vertex>

	#ifdef USE_DISPLACEMENTMAP

		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>

	#endif

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

	vHighPrecisionZW = gl_Position.zw;

}
`,XE=`
#define DISTANCE

uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;

#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <clipping_planes_pars_fragment>

void main () {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( 1.0 );

	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>

	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist ); // clamp to [ 0, 1 ]

	gl_FragColor = packDepthToRGBA( dist );

}
`,qE=`
#define DISTANCE

varying vec3 vWorldPosition;

#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>

	#include <skinbase_vertex>

	#ifdef USE_DISPLACEMENTMAP

		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>

	#endif

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>

	vWorldPosition = worldPosition.xyz;

}
`,YE=`
uniform sampler2D tEquirect;

varying vec3 vWorldDirection;

#include <common>

void main() {

	vec3 direction = normalize( vWorldDirection );

	vec2 sampleUV = equirectUv( direction );

	vec4 texColor = texture2D( tEquirect, sampleUV );

	gl_FragColor = mapTexelToLinear( texColor );

	#include <tonemapping_fragment>
	#include <encodings_fragment>

}
`,jE=`
varying vec3 vWorldDirection;

#include <common>

void main() {

	vWorldDirection = transformDirection( position, modelMatrix );

	#include <begin_vertex>
	#include <project_vertex>

}
`,ZE=`
uniform vec3 diffuse;
uniform float opacity;

uniform float dashSize;
uniform float totalSize;

varying float vLineDistance;

#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	if ( mod( vLineDistance, totalSize ) > dashSize ) {

		discard;

	}

	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );

	#include <logdepthbuf_fragment>
	#include <color_fragment>

	outgoingLight = diffuseColor.rgb; // simple shader

	gl_FragColor = vec4( outgoingLight, diffuseColor.a );

	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>

}
`,JE=`
uniform float scale;
attribute float lineDistance;

varying float vLineDistance;

#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	vLineDistance = scale * lineDistance;

	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>

}
`,QE=`
uniform vec3 diffuse;
uniform float opacity;

#ifndef FLAT_SHADED

	varying vec3 vNormal;

#endif

#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( diffuse, opacity );

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>

	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );

	// accumulation (baked indirect lighting only)
	#ifdef USE_LIGHTMAP
	
		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;

	#else

		reflectedLight.indirectDiffuse += vec3( 1.0 );

	#endif

	// modulation
	#include <aomap_fragment>

	reflectedLight.indirectDiffuse *= diffuseColor.rgb;

	vec3 outgoingLight = reflectedLight.indirectDiffuse;

	#include <envmap_fragment>

	gl_FragColor = vec4( outgoingLight, diffuseColor.a );

	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>

}
`,KE=`
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <skinbase_vertex>

	#ifdef USE_ENVMAP

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>

	#endif

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>

	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>

}
`,tA=`
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;

varying vec3 vLightFront;
varying vec3 vIndirectFront;

#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif


#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <emissivemap_fragment>

	// accumulation

	#ifdef DOUBLE_SIDED

		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;

	#else

		reflectedLight.indirectDiffuse += vIndirectFront;

	#endif

	#include <lightmap_fragment>

	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );

	#ifdef DOUBLE_SIDED

		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;

	#else

		reflectedLight.directDiffuse = vLightFront;

	#endif

	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();

	// modulation

	#include <aomap_fragment>

	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;

	#include <envmap_fragment>

	gl_FragColor = vec4( outgoingLight, diffuseColor.a );

	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}
`,eA=`
#define LAMBERT

varying vec3 vLightFront;
varying vec3 vIndirectFront;

#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif

#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars_begin>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <lights_lambert_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}
`,iA=`
#define MATCAP

uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;

varying vec3 vViewPosition;

#ifndef FLAT_SHADED

	varying vec3 vNormal;

#endif

#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>

#include <fog_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( diffuse, opacity );

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>

	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5; // 0.495 to remove artifacts caused by undersized matcap disks

	#ifdef USE_MATCAP

		vec4 matcapColor = texture2D( matcap, uv );
		matcapColor = matcapTexelToLinear( matcapColor );

	#else

		vec4 matcapColor = vec4( 1.0 );

	#endif

	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;

	gl_FragColor = vec4( outgoingLight, diffuseColor.a );

	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>

}
`,nA=`
#define MATCAP

varying vec3 vViewPosition;

#ifndef FLAT_SHADED

	varying vec3 vNormal;

#endif

#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>

#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>

	#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED

		vNormal = normalize( transformedNormal );

	#endif

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>

	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>

	vViewPosition = - mvPosition.xyz;

}
`,rA=`
#define TOON

uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;

#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>

	// accumulation
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>

	// modulation
	#include <aomap_fragment>

	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;

	gl_FragColor = vec4( outgoingLight, diffuseColor.a );

	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>

}
`,sA=`
#define TOON

varying vec3 vViewPosition;

#ifndef FLAT_SHADED

	varying vec3 vNormal;

#endif

#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>

#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED

	vNormal = normalize( transformedNormal );

#endif

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

	vViewPosition = - mvPosition.xyz;

	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>

}
`,aA=`
#define PHONG

uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;

#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>

	// accumulation
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>

	// modulation
	#include <aomap_fragment>

	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;

	#include <envmap_fragment>

	gl_FragColor = vec4( outgoingLight, diffuseColor.a );

	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>

}
`,oA=`
#define PHONG

varying vec3 vViewPosition;

#ifndef FLAT_SHADED

	varying vec3 vNormal;

#endif

#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>

#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED

	vNormal = normalize( transformedNormal );

#endif

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

	vViewPosition = - mvPosition.xyz;

	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>

}
`,lA=`
#define STANDARD

#ifdef PHYSICAL
	#define REFLECTIVITY
	#define CLEARCOAT
	#define TRANSMISSION
#endif

uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;

#ifdef TRANSMISSION
	uniform float transmission;
#endif

#ifdef REFLECTIVITY
	uniform float reflectivity;
#endif

#ifdef CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif

#ifdef USE_SHEEN
	uniform vec3 sheen;
#endif

varying vec3 vViewPosition;

#ifndef FLAT_SHADED

	varying vec3 vNormal;

	#ifdef USE_TANGENT

		varying vec3 vTangent;
		varying vec3 vBitangent;

	#endif

#endif

#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <transmissionmap_pars_fragment>
#include <bsdfs>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <lights_physical_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;

	#ifdef TRANSMISSION
		float totalTransmission = transmission;
	#endif

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <transmissionmap_fragment>

	// accumulation
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>

	// modulation
	#include <aomap_fragment>

	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;

	// this is a stub for the transmission model
	#ifdef TRANSMISSION
		diffuseColor.a *= mix( saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) ), 1.0, metalness );
	#endif

	gl_FragColor = vec4( outgoingLight, diffuseColor.a );

	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>

}
`,cA=`
#define STANDARD

varying vec3 vViewPosition;

#ifndef FLAT_SHADED

	varying vec3 vNormal;

	#ifdef USE_TANGENT

		varying vec3 vTangent;
		varying vec3 vBitangent;

	#endif

#endif

#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>

#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED

	vNormal = normalize( transformedNormal );

	#ifdef USE_TANGENT

		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );

	#endif

#endif

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

	vViewPosition = - mvPosition.xyz;

	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>

}
`,hA=`
#define NORMAL

uniform float opacity;

#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )

	varying vec3 vViewPosition;

#endif

#ifndef FLAT_SHADED

	varying vec3 vNormal;

	#ifdef USE_TANGENT

		varying vec3 vTangent;
		varying vec3 vBitangent;

	#endif

#endif

#include <packing>
#include <uv_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>

	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );

}
`,uA=`
#define NORMAL

#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )

	varying vec3 vViewPosition;

#endif

#ifndef FLAT_SHADED

	varying vec3 vNormal;

	#ifdef USE_TANGENT

		varying vec3 vTangent;
		varying vec3 vBitangent;

	#endif

#endif

#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>

#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED

	vNormal = normalize( transformedNormal );

	#ifdef USE_TANGENT

		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );

	#endif

#endif

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )

	vViewPosition = - mvPosition.xyz;

#endif

}
`,dA=`
uniform vec3 diffuse;
uniform float opacity;

#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );

	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>

	outgoingLight = diffuseColor.rgb;

	gl_FragColor = vec4( outgoingLight, diffuseColor.a );

	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>

}
`,fA=`
uniform float size;
uniform float scale;

#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>

	gl_PointSize = size;

	#ifdef USE_SIZEATTENUATION

		bool isPerspective = isPerspectiveMatrix( projectionMatrix );

		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );

	#endif

	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>

}
`,pA=`
uniform vec3 color;
uniform float opacity;

#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>

void main() {

	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );

	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>

}
`,mA=`
#include <common>
#include <fog_pars_vertex>
#include <shadowmap_pars_vertex>

void main() {

	#include <begin_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>

	#include <shadowmap_vertex>
	#include <fog_vertex>

}
`,gA=`
uniform vec3 diffuse;
uniform float opacity;

#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>

	outgoingLight = diffuseColor.rgb;

	gl_FragColor = vec4( outgoingLight, diffuseColor.a );

	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>

}
`,xA=`
uniform float rotation;
uniform vec2 center;

#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>

	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );

	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

	#ifndef USE_SIZEATTENUATION

		bool isPerspective = isPerspectiveMatrix( projectionMatrix );

		if ( isPerspective ) scale *= - mvPosition.z;

	#endif

	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;

	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;

	mvPosition.xy += rotatedPosition;

	gl_Position = projectionMatrix * mvPosition;

	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>

}
`;const Vt={alphamap_fragment:JS,alphamap_pars_fragment:QS,alphatest_fragment:KS,aomap_fragment:t1,aomap_pars_fragment:e1,begin_vertex:i1,beginnormal_vertex:n1,bsdfs:r1,bumpmap_pars_fragment:s1,clipping_planes_fragment:a1,clipping_planes_pars_fragment:o1,clipping_planes_pars_vertex:l1,clipping_planes_vertex:c1,color_fragment:h1,color_pars_fragment:u1,color_pars_vertex:d1,color_vertex:f1,common:p1,cube_uv_reflection_fragment:m1,defaultnormal_vertex:g1,displacementmap_pars_vertex:x1,displacementmap_vertex:y1,emissivemap_fragment:_1,emissivemap_pars_fragment:v1,encodings_fragment:M1,encodings_pars_fragment:b1,envmap_fragment:w1,envmap_common_pars_fragment:S1,envmap_pars_fragment:E1,envmap_pars_vertex:A1,envmap_physical_pars_fragment:B1,envmap_vertex:T1,fog_vertex:L1,fog_pars_vertex:R1,fog_fragment:C1,fog_pars_fragment:P1,gradientmap_pars_fragment:D1,lightmap_fragment:F1,lightmap_pars_fragment:I1,lights_lambert_vertex:z1,lights_pars_begin:N1,lights_toon_fragment:O1,lights_toon_pars_fragment:U1,lights_phong_fragment:H1,lights_phong_pars_fragment:G1,lights_physical_fragment:k1,lights_physical_pars_fragment:V1,lights_fragment_begin:W1,lights_fragment_maps:$1,lights_fragment_end:X1,logdepthbuf_fragment:q1,logdepthbuf_pars_fragment:Y1,logdepthbuf_pars_vertex:j1,logdepthbuf_vertex:Z1,map_fragment:J1,map_pars_fragment:Q1,map_particle_fragment:K1,map_particle_pars_fragment:tE,metalnessmap_fragment:eE,metalnessmap_pars_fragment:iE,morphnormal_vertex:nE,morphtarget_pars_vertex:rE,morphtarget_vertex:sE,normal_fragment_begin:aE,normal_fragment_maps:oE,normalmap_pars_fragment:lE,clearcoat_normal_fragment_begin:cE,clearcoat_normal_fragment_maps:hE,clearcoat_pars_fragment:uE,packing:dE,premultiplied_alpha_fragment:fE,project_vertex:pE,dithering_fragment:mE,dithering_pars_fragment:gE,roughnessmap_fragment:xE,roughnessmap_pars_fragment:yE,shadowmap_pars_fragment:_E,shadowmap_pars_vertex:vE,shadowmap_vertex:ME,shadowmask_pars_fragment:bE,skinbase_vertex:wE,skinning_pars_vertex:SE,skinning_vertex:EE,skinnormal_vertex:AE,specularmap_fragment:TE,specularmap_pars_fragment:LE,tonemapping_fragment:RE,tonemapping_pars_fragment:CE,transmissionmap_fragment:PE,transmissionmap_pars_fragment:DE,uv_pars_fragment:FE,uv_pars_vertex:IE,uv_vertex:zE,uv2_pars_fragment:NE,uv2_pars_vertex:BE,uv2_vertex:OE,worldpos_vertex:UE,background_frag:HE,background_vert:GE,cube_frag:kE,cube_vert:VE,depth_frag:WE,depth_vert:$E,distanceRGBA_frag:XE,distanceRGBA_vert:qE,equirect_frag:YE,equirect_vert:jE,linedashed_frag:ZE,linedashed_vert:JE,meshbasic_frag:QE,meshbasic_vert:KE,meshlambert_frag:tA,meshlambert_vert:eA,meshmatcap_frag:iA,meshmatcap_vert:nA,meshtoon_frag:rA,meshtoon_vert:sA,meshphong_frag:aA,meshphong_vert:oA,meshphysical_frag:lA,meshphysical_vert:cA,normal_frag:hA,normal_vert:uA,points_frag:dA,points_vert:fA,shadow_frag:pA,shadow_vert:mA,sprite_frag:gA,sprite_vert:xA},vt={common:{diffuse:{value:new Jt(15658734)},opacity:{value:1},map:{value:null},uvTransform:{value:new gi},uv2Transform:{value:new gi},alphaMap:{value:null}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},refractionRatio:{value:.98},maxMipLevel:{value:0}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new ee(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new Jt(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new Jt(15658734)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},uvTransform:{value:new gi}},sprite:{diffuse:{value:new Jt(15658734)},opacity:{value:1},center:{value:new ee(.5,.5)},rotation:{value:0},map:{value:null},alphaMap:{value:null},uvTransform:{value:new gi}}},Ui={basic:{uniforms:ze([vt.common,vt.specularmap,vt.envmap,vt.aomap,vt.lightmap,vt.fog]),vertexShader:Vt.meshbasic_vert,fragmentShader:Vt.meshbasic_frag},lambert:{uniforms:ze([vt.common,vt.specularmap,vt.envmap,vt.aomap,vt.lightmap,vt.emissivemap,vt.fog,vt.lights,{emissive:{value:new Jt(0)}}]),vertexShader:Vt.meshlambert_vert,fragmentShader:Vt.meshlambert_frag},phong:{uniforms:ze([vt.common,vt.specularmap,vt.envmap,vt.aomap,vt.lightmap,vt.emissivemap,vt.bumpmap,vt.normalmap,vt.displacementmap,vt.fog,vt.lights,{emissive:{value:new Jt(0)},specular:{value:new Jt(1118481)},shininess:{value:30}}]),vertexShader:Vt.meshphong_vert,fragmentShader:Vt.meshphong_frag},standard:{uniforms:ze([vt.common,vt.envmap,vt.aomap,vt.lightmap,vt.emissivemap,vt.bumpmap,vt.normalmap,vt.displacementmap,vt.roughnessmap,vt.metalnessmap,vt.fog,vt.lights,{emissive:{value:new Jt(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:Vt.meshphysical_vert,fragmentShader:Vt.meshphysical_frag},toon:{uniforms:ze([vt.common,vt.aomap,vt.lightmap,vt.emissivemap,vt.bumpmap,vt.normalmap,vt.displacementmap,vt.gradientmap,vt.fog,vt.lights,{emissive:{value:new Jt(0)}}]),vertexShader:Vt.meshtoon_vert,fragmentShader:Vt.meshtoon_frag},matcap:{uniforms:ze([vt.common,vt.bumpmap,vt.normalmap,vt.displacementmap,vt.fog,{matcap:{value:null}}]),vertexShader:Vt.meshmatcap_vert,fragmentShader:Vt.meshmatcap_frag},points:{uniforms:ze([vt.points,vt.fog]),vertexShader:Vt.points_vert,fragmentShader:Vt.points_frag},dashed:{uniforms:ze([vt.common,vt.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:Vt.linedashed_vert,fragmentShader:Vt.linedashed_frag},depth:{uniforms:ze([vt.common,vt.displacementmap]),vertexShader:Vt.depth_vert,fragmentShader:Vt.depth_frag},normal:{uniforms:ze([vt.common,vt.bumpmap,vt.normalmap,vt.displacementmap,{opacity:{value:1}}]),vertexShader:Vt.normal_vert,fragmentShader:Vt.normal_frag},sprite:{uniforms:ze([vt.sprite,vt.fog]),vertexShader:Vt.sprite_vert,fragmentShader:Vt.sprite_frag},background:{uniforms:{uvTransform:{value:new gi},t2D:{value:null}},vertexShader:Vt.background_vert,fragmentShader:Vt.background_frag},cube:{uniforms:ze([vt.envmap,{opacity:{value:1}}]),vertexShader:Vt.cube_vert,fragmentShader:Vt.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:Vt.equirect_vert,fragmentShader:Vt.equirect_frag},distanceRGBA:{uniforms:ze([vt.common,vt.displacementmap,{referencePosition:{value:new Z},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:Vt.distanceRGBA_vert,fragmentShader:Vt.distanceRGBA_frag},shadow:{uniforms:ze([vt.lights,vt.fog,{color:{value:new Jt(0)},opacity:{value:1}}]),vertexShader:Vt.shadow_vert,fragmentShader:Vt.shadow_frag}};Ui.physical={uniforms:ze([Ui.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new ee(1,1)},clearcoatNormalMap:{value:null},sheen:{value:new Jt(0)},transmission:{value:0},transmissionMap:{value:null}}]),vertexShader:Vt.meshphysical_vert,fragmentShader:Vt.meshphysical_frag};function yA(i,t,e,n,r){const s=new Jt(0);let a=0,o,l,c=null,h=0,u=null;function d(p,x,y,g){let m=x.isScene===!0?x.background:null;m&&m.isTexture&&(m=t.get(m));const E=i.xr,w=E.getSession&&E.getSession();w&&w.environmentBlendMode==="additive"&&(m=null),m===null?f(s,a):m&&m.isColor&&(f(m,1),g=!0),(i.autoClear||g)&&i.clear(i.autoClearColor,i.autoClearDepth,i.autoClearStencil),m&&(m.isCubeTexture||m.mapping===uh)?(l===void 0&&(l=new rs(new Zp(1,1,1),new Oi({name:"BackgroundCubeMaterial",uniforms:ts(Ui.cube.uniforms),vertexShader:Ui.cube.vertexShader,fragmentShader:Ui.cube.fragmentShader,side:Le,depthTest:!1,depthWrite:!1,fog:!1})),l.geometry.deleteAttribute("normal"),l.geometry.deleteAttribute("uv"),l.onBeforeRender=function(S,_,T){this.matrixWorld.copyPosition(T.matrixWorld)},Object.defineProperty(l.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),n.update(l)),l.material.uniforms.envMap.value=m,l.material.uniforms.flipEnvMap.value=m.isCubeTexture&&m._needsFlipEnvMap?-1:1,(c!==m||h!==m.version||u!==i.toneMapping)&&(l.material.needsUpdate=!0,c=m,h=m.version,u=i.toneMapping),p.unshift(l,l.geometry,l.material,0,0,null)):m&&m.isTexture&&(o===void 0&&(o=new rs(new WS(2,2),new Oi({name:"BackgroundMaterial",uniforms:ts(Ui.background.uniforms),vertexShader:Ui.background.vertexShader,fragmentShader:Ui.background.fragmentShader,side:No,depthTest:!1,depthWrite:!1,fog:!1})),o.geometry.deleteAttribute("normal"),Object.defineProperty(o.material,"map",{get:function(){return this.uniforms.t2D.value}}),n.update(o)),o.material.uniforms.t2D.value=m,m.matrixAutoUpdate===!0&&m.updateMatrix(),o.material.uniforms.uvTransform.value.copy(m.matrix),(c!==m||h!==m.version||u!==i.toneMapping)&&(o.material.needsUpdate=!0,c=m,h=m.version,u=i.toneMapping),p.unshift(o,o.geometry,o.material,0,0,null))}function f(p,x){e.buffers.color.setClear(p.r,p.g,p.b,x,r)}return{getClearColor:function(){return s},setClearColor:function(p,x=1){s.set(p),a=x,f(s,a)},getClearAlpha:function(){return a},setClearAlpha:function(p){a=p,f(s,a)},render:d}}function _A(i,t,e,n){const r=i.getParameter(i.MAX_VERTEX_ATTRIBS),s=n.isWebGL2?null:t.get("OES_vertex_array_object"),a=n.isWebGL2||s!==null,o={},l=x(null);let c=l;function h(R,L,P,F,W){let j=!1;if(a){const Y=p(F,P,L);c!==Y&&(c=Y,d(c.object)),j=y(F,W),j&&g(F,W)}else{const Y=L.wireframe===!0;(c.geometry!==F.id||c.program!==P.id||c.wireframe!==Y)&&(c.geometry=F.id,c.program=P.id,c.wireframe=Y,j=!0)}R.isInstancedMesh===!0&&(j=!0),W!==null&&e.update(W,i.ELEMENT_ARRAY_BUFFER),j&&(T(R,L,P,F),W!==null&&i.bindBuffer(i.ELEMENT_ARRAY_BUFFER,e.get(W).buffer))}function u(){return n.isWebGL2?i.createVertexArray():s.createVertexArrayOES()}function d(R){return n.isWebGL2?i.bindVertexArray(R):s.bindVertexArrayOES(R)}function f(R){return n.isWebGL2?i.deleteVertexArray(R):s.deleteVertexArrayOES(R)}function p(R,L,P){const F=P.wireframe===!0;let W=o[R.id];W===void 0&&(W={},o[R.id]=W);let j=W[L.id];j===void 0&&(j={},W[L.id]=j);let Y=j[F];return Y===void 0&&(Y=x(u()),j[F]=Y),Y}function x(R){const L=[],P=[],F=[];for(let W=0;W<r;W++)L[W]=0,P[W]=0,F[W]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:L,enabledAttributes:P,attributeDivisors:F,object:R,attributes:{},index:null}}function y(R,L){const P=c.attributes,F=R.attributes;let W=0;for(const j in F){const Y=P[j],Q=F[j];if(Y===void 0||Y.attribute!==Q||Y.data!==Q.data)return!0;W++}return c.attributesNum!==W||c.index!==L}function g(R,L){const P={},F=R.attributes;let W=0;for(const j in F){const Y=F[j],Q={};Q.attribute=Y,Y.data&&(Q.data=Y.data),P[j]=Q,W++}c.attributes=P,c.attributesNum=W,c.index=L}function m(){const R=c.newAttributes;for(let L=0,P=R.length;L<P;L++)R[L]=0}function E(R){w(R,0)}function w(R,L){const P=c.newAttributes,F=c.enabledAttributes,W=c.attributeDivisors;P[R]=1,F[R]===0&&(i.enableVertexAttribArray(R),F[R]=1),W[R]!==L&&((n.isWebGL2?i:t.get("ANGLE_instanced_arrays"))[n.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](R,L),W[R]=L)}function S(){const R=c.newAttributes,L=c.enabledAttributes;for(let P=0,F=L.length;P<F;P++)L[P]!==R[P]&&(i.disableVertexAttribArray(P),L[P]=0)}function _(R,L,P,F,W,j){n.isWebGL2===!0&&(P===i.INT||P===i.UNSIGNED_INT)?i.vertexAttribIPointer(R,L,P,W,j):i.vertexAttribPointer(R,L,P,F,W,j)}function T(R,L,P,F){if(n.isWebGL2===!1&&(R.isInstancedMesh||F.isInstancedBufferGeometry)&&t.get("ANGLE_instanced_arrays")===null)return;m();const W=F.attributes,j=P.getAttributes(),Y=L.defaultAttributeValues;for(const Q in j){const K=j[Q];if(K>=0){const st=W[Q];if(st!==void 0){const ct=st.normalized,z=st.itemSize,Et=e.get(st);if(Et===void 0)continue;const At=Et.buffer,yt=Et.type,ot=Et.bytesPerElement;if(st.isInterleavedBufferAttribute){const Ct=st.data,Mt=Ct.stride,St=st.offset;Ct&&Ct.isInstancedInterleavedBuffer?(w(K,Ct.meshPerAttribute),F._maxInstanceCount===void 0&&(F._maxInstanceCount=Ct.meshPerAttribute*Ct.count)):E(K),i.bindBuffer(i.ARRAY_BUFFER,At),_(K,z,yt,ct,Mt*ot,St*ot)}else st.isInstancedBufferAttribute?(w(K,st.meshPerAttribute),F._maxInstanceCount===void 0&&(F._maxInstanceCount=st.meshPerAttribute*st.count)):E(K),i.bindBuffer(i.ARRAY_BUFFER,At),_(K,z,yt,ct,0,0)}else if(Q==="instanceMatrix"){const ct=e.get(R.instanceMatrix);if(ct===void 0)continue;const z=ct.buffer,Et=ct.type;w(K+0,1),w(K+1,1),w(K+2,1),w(K+3,1),i.bindBuffer(i.ARRAY_BUFFER,z),i.vertexAttribPointer(K+0,4,Et,!1,64,0),i.vertexAttribPointer(K+1,4,Et,!1,64,16),i.vertexAttribPointer(K+2,4,Et,!1,64,32),i.vertexAttribPointer(K+3,4,Et,!1,64,48)}else if(Q==="instanceColor"){const ct=e.get(R.instanceColor);if(ct===void 0)continue;const z=ct.buffer,Et=ct.type;w(K,1),i.bindBuffer(i.ARRAY_BUFFER,z),i.vertexAttribPointer(K,3,Et,!1,12,0)}else if(Y!==void 0){const ct=Y[Q];if(ct!==void 0)switch(ct.length){case 2:i.vertexAttrib2fv(K,ct);break;case 3:i.vertexAttrib3fv(K,ct);break;case 4:i.vertexAttrib4fv(K,ct);break;default:i.vertexAttrib1fv(K,ct)}}}}S()}function B(){D();for(const R in o){const L=o[R];for(const P in L){const F=L[P];for(const W in F)f(F[W].object),delete F[W];delete L[P]}delete o[R]}}function N(R){if(o[R.id]===void 0)return;const L=o[R.id];for(const P in L){const F=L[P];for(const W in F)f(F[W].object),delete F[W];delete L[P]}delete o[R.id]}function G(R){for(const L in o){const P=o[L];if(P[R.id]===void 0)continue;const F=P[R.id];for(const W in F)f(F[W].object),delete F[W];delete P[R.id]}}function D(){V(),c!==l&&(c=l,d(c.object))}function V(){l.geometry=null,l.program=null,l.wireframe=!1}return{setup:h,reset:D,resetDefaultState:V,dispose:B,releaseStatesOfGeometry:N,releaseStatesOfProgram:G,initAttributes:m,enableAttribute:E,disableUnusedAttributes:S}}function vA(i,t,e,n){const r=n.isWebGL2;let s;function a(c){s=c}function o(c,h){i.drawArrays(s,c,h),e.update(h,s,1)}function l(c,h,u){if(u===0)return;let d,f;if(r)d=i,f="drawArraysInstanced";else if(d=t.get("ANGLE_instanced_arrays"),f="drawArraysInstancedANGLE",d===null){console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}d[f](s,c,h,u),e.update(h,s,u)}this.setMode=a,this.render=o,this.renderInstances=l}function MA(i,t,e){let n;function r(){if(n!==void 0)return n;if(t.has("EXT_texture_filter_anisotropic")===!0){const _=t.get("EXT_texture_filter_anisotropic");n=i.getParameter(_.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else n=0;return n}function s(_){if(_==="highp"){if(i.getShaderPrecisionFormat(i.VERTEX_SHADER,i.HIGH_FLOAT).precision>0&&i.getShaderPrecisionFormat(i.FRAGMENT_SHADER,i.HIGH_FLOAT).precision>0)return"highp";_="mediump"}return _==="mediump"&&i.getShaderPrecisionFormat(i.VERTEX_SHADER,i.MEDIUM_FLOAT).precision>0&&i.getShaderPrecisionFormat(i.FRAGMENT_SHADER,i.MEDIUM_FLOAT).precision>0?"mediump":"lowp"}const a=typeof WebGL2RenderingContext!="undefined"&&i instanceof WebGL2RenderingContext||typeof WebGL2ComputeRenderingContext!="undefined"&&i instanceof WebGL2ComputeRenderingContext;let o=e.precision!==void 0?e.precision:"highp";const l=s(o);l!==o&&(console.warn("THREE.WebGLRenderer:",o,"not supported, using",l,"instead."),o=l);const c=e.logarithmicDepthBuffer===!0,h=i.getParameter(i.MAX_TEXTURE_IMAGE_UNITS),u=i.getParameter(i.MAX_VERTEX_TEXTURE_IMAGE_UNITS),d=i.getParameter(i.MAX_TEXTURE_SIZE),f=i.getParameter(i.MAX_CUBE_MAP_TEXTURE_SIZE),p=i.getParameter(i.MAX_VERTEX_ATTRIBS),x=i.getParameter(i.MAX_VERTEX_UNIFORM_VECTORS),y=i.getParameter(i.MAX_VARYING_VECTORS),g=i.getParameter(i.MAX_FRAGMENT_UNIFORM_VECTORS),m=u>0,E=a||t.has("OES_texture_float"),w=m&&E,S=a?i.getParameter(i.MAX_SAMPLES):0;return{isWebGL2:a,getMaxAnisotropy:r,getMaxPrecision:s,precision:o,logarithmicDepthBuffer:c,maxTextures:h,maxVertexTextures:u,maxTextureSize:d,maxCubemapSize:f,maxAttributes:p,maxVertexUniforms:x,maxVaryings:y,maxFragmentUniforms:g,vertexTextures:m,floatFragmentTextures:E,floatVertexTextures:w,maxSamples:S}}function bA(i){const t=this;let e=null,n=0,r=!1,s=!1;const a=new Xi,o=new gi,l={value:null,needsUpdate:!1};this.uniform=l,this.numPlanes=0,this.numIntersection=0,this.init=function(u,d,f){const p=u.length!==0||d||n!==0||r;return r=d,e=h(u,f,0),n=u.length,p},this.beginShadows=function(){s=!0,h(null)},this.endShadows=function(){s=!1,c()},this.setState=function(u,d,f){const p=u.clippingPlanes,x=u.clipIntersection,y=u.clipShadows,g=i.get(u);if(!r||p===null||p.length===0||s&&!y)s?h(null):c();else{const m=s?0:n,E=m*4;let w=g.clippingState||null;l.value=w,w=h(p,d,E,f);for(let S=0;S!==E;++S)w[S]=e[S];g.clippingState=w,this.numIntersection=x?this.numPlanes:0,this.numPlanes+=m}};function c(){l.value!==e&&(l.value=e,l.needsUpdate=n>0),t.numPlanes=n,t.numIntersection=0}function h(u,d,f,p){const x=u!==null?u.length:0;let y=null;if(x!==0){if(y=l.value,p!==!0||y===null){const g=f+x*4,m=d.matrixWorldInverse;o.getNormalMatrix(m),(y===null||y.length<g)&&(y=new Float32Array(g));for(let E=0,w=f;E!==x;++E,w+=4)a.copy(u[E]).applyMatrix4(m,o),a.normal.toArray(y,w),y[w+3]=a.constant}l.value=y,l.needsUpdate=!0}return t.numPlanes=x,t.numIntersection=0,y}}class Ma extends Zn{constructor(t,e,n){super();this.width=t,this.height=e,this.depth=1,this.scissor=new Ie(0,0,t,e),this.scissorTest=!1,this.viewport=new Ie(0,0,t,e),n=n||{},this.texture=new oi(void 0,n.mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.encoding),this.texture.image={},this.texture.image.width=t,this.texture.image.height=e,this.texture.image.depth=1,this.texture.generateMipmaps=n.generateMipmaps!==void 0?n.generateMipmaps:!1,this.texture.minFilter=n.minFilter!==void 0?n.minFilter:Fi,this.depthBuffer=n.depthBuffer!==void 0?n.depthBuffer:!0,this.stencilBuffer=n.stencilBuffer!==void 0?n.stencilBuffer:!1,this.depthTexture=n.depthTexture!==void 0?n.depthTexture:null}setTexture(t){t.image={width:this.width,height:this.height,depth:this.depth},this.texture=t}setSize(t,e,n=1){(this.width!==t||this.height!==e||this.depth!==n)&&(this.width=t,this.height=e,this.depth=n,this.texture.image.width=t,this.texture.image.height=e,this.texture.image.depth=n,this.dispose()),this.viewport.set(0,0,t,e),this.scissor.set(0,0,t,e)}clone(){return new this.constructor().copy(this)}copy(t){return this.width=t.width,this.height=t.height,this.depth=t.depth,this.viewport.copy(t.viewport),this.texture=t.texture.clone(),this.depthBuffer=t.depthBuffer,this.stencilBuffer=t.stencilBuffer,this.depthTexture=t.depthTexture,this}dispose(){this.dispatchEvent({type:"dispose"})}}Ma.prototype.isWebGLRenderTarget=!0;function ba(){he.call(this),this.type="Camera",this.matrixWorldInverse=new Ce,this.projectionMatrix=new Ce,this.projectionMatrixInverse=new Ce}ba.prototype=Object.assign(Object.create(he.prototype),{constructor:ba,isCamera:!0,copy:function(i,t){return he.prototype.copy.call(this,i,t),this.matrixWorldInverse.copy(i.matrixWorldInverse),this.projectionMatrix.copy(i.projectionMatrix),this.projectionMatrixInverse.copy(i.projectionMatrixInverse),this},getWorldDirection:function(i){i===void 0&&(console.warn("THREE.Camera: .getWorldDirection() target is now required"),i=new Z),this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return i.set(-t[8],-t[9],-t[10]).normalize()},updateMatrixWorld:function(i){he.prototype.updateMatrixWorld.call(this,i),this.matrixWorldInverse.copy(this.matrixWorld).invert()},updateWorldMatrix:function(i,t){he.prototype.updateWorldMatrix.call(this,i,t),this.matrixWorldInverse.copy(this.matrixWorld).invert()},clone:function(){return new this.constructor().copy(this)}});function Qe(i=50,t=1,e=.1,n=2e3){ba.call(this),this.type="PerspectiveCamera",this.fov=i,this.zoom=1,this.near=e,this.far=n,this.focus=10,this.aspect=t,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}Qe.prototype=Object.assign(Object.create(ba.prototype),{constructor:Qe,isPerspectiveCamera:!0,copy:function(i,t){return ba.prototype.copy.call(this,i,t),this.fov=i.fov,this.zoom=i.zoom,this.near=i.near,this.far=i.far,this.focus=i.focus,this.aspect=i.aspect,this.view=i.view===null?null:Object.assign({},i.view),this.filmGauge=i.filmGauge,this.filmOffset=i.filmOffset,this},setFocalLength:function(i){const t=.5*this.getFilmHeight()/i;this.fov=Zt.RAD2DEG*2*Math.atan(t),this.updateProjectionMatrix()},getFocalLength:function(){const i=Math.tan(Zt.DEG2RAD*.5*this.fov);return .5*this.getFilmHeight()/i},getEffectiveFOV:function(){return Zt.RAD2DEG*2*Math.atan(Math.tan(Zt.DEG2RAD*.5*this.fov)/this.zoom)},getFilmWidth:function(){return this.filmGauge*Math.min(this.aspect,1)},getFilmHeight:function(){return this.filmGauge/Math.max(this.aspect,1)},setViewOffset:function(i,t,e,n,r,s){this.aspect=i/t,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=i,this.view.fullHeight=t,this.view.offsetX=e,this.view.offsetY=n,this.view.width=r,this.view.height=s,this.updateProjectionMatrix()},clearViewOffset:function(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()},updateProjectionMatrix:function(){const i=this.near;let t=i*Math.tan(Zt.DEG2RAD*.5*this.fov)/this.zoom,e=2*t,n=this.aspect*e,r=-.5*n;const s=this.view;if(this.view!==null&&this.view.enabled){const o=s.fullWidth,l=s.fullHeight;r+=s.offsetX*n/o,t-=s.offsetY*e/l,n*=s.width/o,e*=s.height/l}const a=this.filmOffset;a!==0&&(r+=i*a/this.getFilmWidth()),this.projectionMatrix.makePerspective(r,r+n,t,t-e,i,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()},toJSON:function(i){const t=he.prototype.toJSON.call(this,i);return t.object.fov=this.fov,t.object.zoom=this.zoom,t.object.near=this.near,t.object.far=this.far,t.object.focus=this.focus,t.object.aspect=this.aspect,this.view!==null&&(t.object.view=Object.assign({},this.view)),t.object.filmGauge=this.filmGauge,t.object.filmOffset=this.filmOffset,t}});const ss=90,as=1;class wA extends he{constructor(t,e,n){super();if(this.type="CubeCamera",n.isWebGLCubeRenderTarget!==!0){console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");return}this.renderTarget=n;const r=new Qe(ss,as,t,e);r.layers=this.layers,r.up.set(0,-1,0),r.lookAt(new Z(1,0,0)),this.add(r);const s=new Qe(ss,as,t,e);s.layers=this.layers,s.up.set(0,-1,0),s.lookAt(new Z(-1,0,0)),this.add(s);const a=new Qe(ss,as,t,e);a.layers=this.layers,a.up.set(0,0,1),a.lookAt(new Z(0,1,0)),this.add(a);const o=new Qe(ss,as,t,e);o.layers=this.layers,o.up.set(0,0,-1),o.lookAt(new Z(0,-1,0)),this.add(o);const l=new Qe(ss,as,t,e);l.layers=this.layers,l.up.set(0,-1,0),l.lookAt(new Z(0,0,1)),this.add(l);const c=new Qe(ss,as,t,e);c.layers=this.layers,c.up.set(0,-1,0),c.lookAt(new Z(0,0,-1)),this.add(c)}update(t,e){this.parent===null&&this.updateMatrixWorld();const n=this.renderTarget,[r,s,a,o,l,c]=this.children,h=t.xr.enabled,u=t.getRenderTarget();t.xr.enabled=!1;const d=n.texture.generateMipmaps;n.texture.generateMipmaps=!1,t.setRenderTarget(n,0),t.render(e,r),t.setRenderTarget(n,1),t.render(e,s),t.setRenderTarget(n,2),t.render(e,a),t.setRenderTarget(n,3),t.render(e,o),t.setRenderTarget(n,4),t.render(e,l),n.texture.generateMipmaps=d,t.setRenderTarget(n,5),t.render(e,c),t.setRenderTarget(u),t.xr.enabled=h}}class Jh extends oi{constructor(t,e,n,r,s,a,o,l,c,h){t=t!==void 0?t:[],e=e!==void 0?e:ch,o=o!==void 0?o:pa;super(t,e,n,r,s,a,o,l,c,h);this._needsFlipEnvMap=!0,this.flipY=!1}get images(){return this.image}set images(t){this.image=t}}Jh.prototype.isCubeTexture=!0;class tm extends Ma{constructor(t,e,n){Number.isInteger(e)&&(console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"),e=n);super(t,t,e);e=e||{},this.texture=new Jh(void 0,e.mapping,e.wrapS,e.wrapT,e.magFilter,e.minFilter,e.format,e.type,e.anisotropy,e.encoding),this.texture.generateMipmaps=e.generateMipmaps!==void 0?e.generateMipmaps:!1,this.texture.minFilter=e.minFilter!==void 0?e.minFilter:Fi,this.texture._needsFlipEnvMap=!1}fromEquirectangularTexture(t,e){this.texture.type=e.type,this.texture.format=Ii,this.texture.encoding=e.encoding,this.texture.generateMipmaps=e.generateMipmaps,this.texture.minFilter=e.minFilter,this.texture.magFilter=e.magFilter;const n={uniforms:{tEquirect:{value:null}},vertexShader:`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},r=new Zp(5,5,5),s=new Oi({name:"CubemapFromEquirect",uniforms:ts(n.uniforms),vertexShader:n.vertexShader,fragmentShader:n.fragmentShader,side:Le,blending:ua});s.uniforms.tEquirect.value=e;const a=new rs(r,s),o=e.minFilter;return e.minFilter===mh&&(e.minFilter=Fi),new wA(1,10,this).update(t,a),e.minFilter=o,a.geometry.dispose(),a.material.dispose(),this}clear(t,e,n,r){const s=t.getRenderTarget();for(let a=0;a<6;a++)t.setRenderTarget(this,a),t.clear(e,n,r);t.setRenderTarget(s)}}tm.prototype.isWebGLCubeRenderTarget=!0;function SA(i){let t=new WeakMap;function e(a,o){return o===vp?a.mapping=ch:o===Mp&&(a.mapping=hh),a}function n(a){if(a&&a.isTexture){const o=a.mapping;if(o===vp||o===Mp)if(t.has(a)){const l=t.get(a).texture;return e(l,a.mapping)}else{const l=a.image;if(l&&l.height>0){const c=i.getRenderTarget(),h=new tm(l.height/2);return h.fromEquirectangularTexture(i,a),t.set(a,h),i.setRenderTarget(c),a.addEventListener("dispose",r),e(h.texture,a.mapping)}else return null}}return a}function r(a){const o=a.target;o.removeEventListener("dispose",r);const l=t.get(o);l!==void 0&&(t.delete(o),l.dispose())}function s(){t=new WeakMap}return{get:n,dispose:s}}function EA(i){const t={};function e(n){if(t[n]!==void 0)return t[n];let r;switch(n){case"WEBGL_depth_texture":r=i.getExtension("WEBGL_depth_texture")||i.getExtension("MOZ_WEBGL_depth_texture")||i.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":r=i.getExtension("EXT_texture_filter_anisotropic")||i.getExtension("MOZ_EXT_texture_filter_anisotropic")||i.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":r=i.getExtension("WEBGL_compressed_texture_s3tc")||i.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||i.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":r=i.getExtension("WEBGL_compressed_texture_pvrtc")||i.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:r=i.getExtension(n)}return t[n]=r,r}return{has:function(n){return e(n)!==null},init:function(n){n.isWebGL2?e("EXT_color_buffer_float"):(e("WEBGL_depth_texture"),e("OES_texture_float"),e("OES_texture_half_float"),e("OES_texture_half_float_linear"),e("OES_standard_derivatives"),e("OES_element_index_uint"),e("OES_vertex_array_object"),e("ANGLE_instanced_arrays")),e("OES_texture_float_linear"),e("EXT_color_buffer_half_float")},get:function(n){const r=e(n);return r===null&&console.warn("THREE.WebGLRenderer: "+n+" extension not supported."),r}}}function AA(i,t,e,n){const r={},s=new WeakMap;function a(u){const d=u.target;d.index!==null&&t.remove(d.index);for(const p in d.attributes)t.remove(d.attributes[p]);d.removeEventListener("dispose",a),delete r[d.id];const f=s.get(d);f&&(t.remove(f),s.delete(d)),n.releaseStatesOfGeometry(d),d.isInstancedBufferGeometry===!0&&delete d._maxInstanceCount,e.memory.geometries--}function o(u,d){return r[d.id]===!0||(d.addEventListener("dispose",a),r[d.id]=!0,e.memory.geometries++),d}function l(u){const d=u.attributes;for(const p in d)t.update(d[p],i.ARRAY_BUFFER);const f=u.morphAttributes;for(const p in f){const x=f[p];for(let y=0,g=x.length;y<g;y++)t.update(x[y],i.ARRAY_BUFFER)}}function c(u){const d=[],f=u.index,p=u.attributes.position;let x=0;if(f!==null){const m=f.array;x=f.version;for(let E=0,w=m.length;E<w;E+=3){const S=m[E+0],_=m[E+1],T=m[E+2];d.push(S,_,_,T,T,S)}}else{const m=p.array;x=p.version;for(let E=0,w=m.length/3-1;E<w;E+=3){const S=E+0,_=E+1,T=E+2;d.push(S,_,_,T,T,S)}}const y=new(jp(d)>65535?ya:xa)(d,1);y.version=x;const g=s.get(u);g&&t.remove(g),s.set(u,y)}function h(u){const d=s.get(u);if(d){const f=u.index;f!==null&&d.version<f.version&&c(u)}else c(u);return s.get(u)}return{get:o,update:l,getWireframeAttribute:h}}function TA(i,t,e,n){const r=n.isWebGL2;let s;function a(d){s=d}let o,l;function c(d){o=d.type,l=d.bytesPerElement}function h(d,f){i.drawElements(s,f,o,d*l),e.update(f,s,1)}function u(d,f,p){if(p===0)return;let x,y;if(r)x=i,y="drawElementsInstanced";else if(x=t.get("ANGLE_instanced_arrays"),y="drawElementsInstancedANGLE",x===null){console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}x[y](s,f,o,d*l,p),e.update(f,s,p)}this.setMode=a,this.setIndex=c,this.render=h,this.renderInstances=u}function LA(i){const t={geometries:0,textures:0},e={frame:0,calls:0,triangles:0,points:0,lines:0};function n(s,a,o){switch(e.calls++,a){case i.TRIANGLES:e.triangles+=o*(s/3);break;case i.LINES:e.lines+=o*(s/2);break;case i.LINE_STRIP:e.lines+=o*(s-1);break;case i.LINE_LOOP:e.lines+=o*s;break;case i.POINTS:e.points+=o*s;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",a);break}}function r(){e.frame++,e.calls=0,e.triangles=0,e.points=0,e.lines=0}return{memory:t,render:e,programs:null,autoReset:!0,reset:r,update:n}}function RA(i,t){return i[0]-t[0]}function CA(i,t){return Math.abs(t[1])-Math.abs(i[1])}function PA(i){const t={},e=new Float32Array(8),n=[];for(let s=0;s<8;s++)n[s]=[s,0];function r(s,a,o,l){const c=s.morphTargetInfluences,h=c===void 0?0:c.length;let u=t[a.id];if(u===void 0){u=[];for(let y=0;y<h;y++)u[y]=[y,0];t[a.id]=u}for(let y=0;y<h;y++){const g=u[y];g[0]=y,g[1]=c[y]}u.sort(CA);for(let y=0;y<8;y++)y<h&&u[y][1]?(n[y][0]=u[y][0],n[y][1]=u[y][1]):(n[y][0]=Number.MAX_SAFE_INTEGER,n[y][1]=0);n.sort(RA);const d=o.morphTargets&&a.morphAttributes.position,f=o.morphNormals&&a.morphAttributes.normal;let p=0;for(let y=0;y<8;y++){const g=n[y],m=g[0],E=g[1];m!==Number.MAX_SAFE_INTEGER&&E?(d&&a.getAttribute("morphTarget"+y)!==d[m]&&a.setAttribute("morphTarget"+y,d[m]),f&&a.getAttribute("morphNormal"+y)!==f[m]&&a.setAttribute("morphNormal"+y,f[m]),e[y]=E,p+=E):(d&&a.hasAttribute("morphTarget"+y)===!0&&a.deleteAttribute("morphTarget"+y),f&&a.hasAttribute("morphNormal"+y)===!0&&a.deleteAttribute("morphNormal"+y),e[y]=0)}const x=a.morphTargetsRelative?1:1-p;l.getUniforms().setValue(i,"morphTargetBaseInfluence",x),l.getUniforms().setValue(i,"morphTargetInfluences",e)}return{update:r}}function DA(i,t,e,n){let r=new WeakMap;function s(l){const c=n.render.frame,h=l.geometry,u=t.get(l,h);return r.get(u)!==c&&(t.update(u),r.set(u,c)),l.isInstancedMesh&&(l.hasEventListener("dispose",o)===!1&&l.addEventListener("dispose",o),e.update(l.instanceMatrix,i.ARRAY_BUFFER),l.instanceColor!==null&&e.update(l.instanceColor,i.ARRAY_BUFFER)),u}function a(){r=new WeakMap}function o(l){const c=l.target;c.removeEventListener("dispose",o),e.remove(c.instanceMatrix),c.instanceColor!==null&&e.remove(c.instanceColor)}return{update:s,dispose:a}}class em extends oi{constructor(t=null,e=1,n=1,r=1){super(null);this.image={data:t,width:e,height:n,depth:r},this.magFilter=je,this.minFilter=je,this.wrapR=mi,this.generateMipmaps=!1,this.flipY=!1,this.needsUpdate=!0}}em.prototype.isDataTexture2DArray=!0;class im extends oi{constructor(t=null,e=1,n=1,r=1){super(null);this.image={data:t,width:e,height:n,depth:r},this.magFilter=je,this.minFilter=je,this.wrapR=mi,this.generateMipmaps=!1,this.flipY=!1,this.needsUpdate=!0}}im.prototype.isDataTexture3D=!0;const nm=new oi,FA=new em,IA=new im,rm=new Jh,sm=[],am=[],om=new Float32Array(16),lm=new Float32Array(9),cm=new Float32Array(4);function os(i,t,e){const n=i[0];if(n<=0||n>0)return i;const r=t*e;let s=sm[r];if(s===void 0&&(s=new Float32Array(r),sm[r]=s),t!==0){n.toArray(s,0);for(let a=1,o=0;a!==t;++a)o+=e,i[a].toArray(s,o)}return s}function Ve(i,t){if(i.length!==t.length)return!1;for(let e=0,n=i.length;e<n;e++)if(i[e]!==t[e])return!1;return!0}function Ne(i,t){for(let e=0,n=t.length;e<n;e++)i[e]=t[e]}function hm(i,t){let e=am[t];e===void 0&&(e=new Int32Array(t),am[t]=e);for(let n=0;n!==t;++n)e[n]=i.allocateTextureUnit();return e}function zA(i,t){const e=this.cache;e[0]!==t&&(i.uniform1f(this.addr,t),e[0]=t)}function NA(i,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y)&&(i.uniform2f(this.addr,t.x,t.y),e[0]=t.x,e[1]=t.y);else{if(Ve(e,t))return;i.uniform2fv(this.addr,t),Ne(e,t)}}function BA(i,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y||e[2]!==t.z)&&(i.uniform3f(this.addr,t.x,t.y,t.z),e[0]=t.x,e[1]=t.y,e[2]=t.z);else if(t.r!==void 0)(e[0]!==t.r||e[1]!==t.g||e[2]!==t.b)&&(i.uniform3f(this.addr,t.r,t.g,t.b),e[0]=t.r,e[1]=t.g,e[2]=t.b);else{if(Ve(e,t))return;i.uniform3fv(this.addr,t),Ne(e,t)}}function OA(i,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y||e[2]!==t.z||e[3]!==t.w)&&(i.uniform4f(this.addr,t.x,t.y,t.z,t.w),e[0]=t.x,e[1]=t.y,e[2]=t.z,e[3]=t.w);else{if(Ve(e,t))return;i.uniform4fv(this.addr,t),Ne(e,t)}}function UA(i,t){const e=this.cache,n=t.elements;if(n===void 0){if(Ve(e,t))return;i.uniformMatrix2fv(this.addr,!1,t),Ne(e,t)}else{if(Ve(e,n))return;cm.set(n),i.uniformMatrix2fv(this.addr,!1,cm),Ne(e,n)}}function HA(i,t){const e=this.cache,n=t.elements;if(n===void 0){if(Ve(e,t))return;i.uniformMatrix3fv(this.addr,!1,t),Ne(e,t)}else{if(Ve(e,n))return;lm.set(n),i.uniformMatrix3fv(this.addr,!1,lm),Ne(e,n)}}function GA(i,t){const e=this.cache,n=t.elements;if(n===void 0){if(Ve(e,t))return;i.uniformMatrix4fv(this.addr,!1,t),Ne(e,t)}else{if(Ve(e,n))return;om.set(n),i.uniformMatrix4fv(this.addr,!1,om),Ne(e,n)}}function kA(i,t){const e=this.cache;e[0]!==t&&(i.uniform1i(this.addr,t),e[0]=t)}function VA(i,t){const e=this.cache;Ve(e,t)||(i.uniform2iv(this.addr,t),Ne(e,t))}function WA(i,t){const e=this.cache;Ve(e,t)||(i.uniform3iv(this.addr,t),Ne(e,t))}function $A(i,t){const e=this.cache;Ve(e,t)||(i.uniform4iv(this.addr,t),Ne(e,t))}function XA(i,t){const e=this.cache;e[0]!==t&&(i.uniform1ui(this.addr,t),e[0]=t)}function qA(i,t){const e=this.cache;Ve(e,t)||(i.uniform2uiv(this.addr,t),Ne(e,t))}function YA(i,t){const e=this.cache;Ve(e,t)||(i.uniform3uiv(this.addr,t),Ne(e,t))}function jA(i,t){const e=this.cache;Ve(e,t)||(i.uniform4uiv(this.addr,t),Ne(e,t))}function ZA(i,t,e){const n=this.cache,r=e.allocateTextureUnit();n[0]!==r&&(i.uniform1i(this.addr,r),n[0]=r),e.safeSetTexture2D(t||nm,r)}function JA(i,t,e){const n=this.cache,r=e.allocateTextureUnit();n[0]!==r&&(i.uniform1i(this.addr,r),n[0]=r),e.setTexture3D(t||IA,r)}function QA(i,t,e){const n=this.cache,r=e.allocateTextureUnit();n[0]!==r&&(i.uniform1i(this.addr,r),n[0]=r),e.safeSetTextureCube(t||rm,r)}function KA(i,t,e){const n=this.cache,r=e.allocateTextureUnit();n[0]!==r&&(i.uniform1i(this.addr,r),n[0]=r),e.setTexture2DArray(t||FA,r)}function tT(i){switch(i){case 5126:return zA;case 35664:return NA;case 35665:return BA;case 35666:return OA;case 35674:return UA;case 35675:return HA;case 35676:return GA;case 5124:case 35670:return kA;case 35667:case 35671:return VA;case 35668:case 35672:return WA;case 35669:case 35673:return $A;case 5125:return XA;case 36294:return qA;case 36295:return YA;case 36296:return jA;case 35678:case 36198:case 36298:case 36306:case 35682:return ZA;case 35679:case 36299:case 36307:return JA;case 35680:case 36300:case 36308:case 36293:return QA;case 36289:case 36303:case 36311:case 36292:return KA}}function eT(i,t){i.uniform1fv(this.addr,t)}function iT(i,t){const e=os(t,this.size,2);i.uniform2fv(this.addr,e)}function nT(i,t){const e=os(t,this.size,3);i.uniform3fv(this.addr,e)}function rT(i,t){const e=os(t,this.size,4);i.uniform4fv(this.addr,e)}function sT(i,t){const e=os(t,this.size,4);i.uniformMatrix2fv(this.addr,!1,e)}function aT(i,t){const e=os(t,this.size,9);i.uniformMatrix3fv(this.addr,!1,e)}function oT(i,t){const e=os(t,this.size,16);i.uniformMatrix4fv(this.addr,!1,e)}function lT(i,t){i.uniform1iv(this.addr,t)}function cT(i,t){i.uniform2iv(this.addr,t)}function hT(i,t){i.uniform3iv(this.addr,t)}function uT(i,t){i.uniform4iv(this.addr,t)}function dT(i,t){i.uniform1uiv(this.addr,t)}function fT(i,t){i.uniform2uiv(this.addr,t)}function pT(i,t){i.uniform3uiv(this.addr,t)}function mT(i,t){i.uniform4uiv(this.addr,t)}function gT(i,t,e){const n=t.length,r=hm(e,n);i.uniform1iv(this.addr,r);for(let s=0;s!==n;++s)e.safeSetTexture2D(t[s]||nm,r[s])}function xT(i,t,e){const n=t.length,r=hm(e,n);i.uniform1iv(this.addr,r);for(let s=0;s!==n;++s)e.safeSetTextureCube(t[s]||rm,r[s])}function yT(i){switch(i){case 5126:return eT;case 35664:return iT;case 35665:return nT;case 35666:return rT;case 35674:return sT;case 35675:return aT;case 35676:return oT;case 5124:case 35670:return lT;case 35667:case 35671:return cT;case 35668:case 35672:return hT;case 35669:case 35673:return uT;case 5125:return dT;case 36294:return fT;case 36295:return pT;case 36296:return mT;case 35678:case 36198:case 36298:case 36306:case 35682:return gT;case 35680:case 36300:case 36308:case 36293:return xT}}function _T(i,t,e){this.id=i,this.addr=e,this.cache=[],this.setValue=tT(t.type)}function um(i,t,e){this.id=i,this.addr=e,this.cache=[],this.size=t.size,this.setValue=yT(t.type)}um.prototype.updateCache=function(i){const t=this.cache;i instanceof Float32Array&&t.length!==i.length&&(this.cache=new Float32Array(i.length)),Ne(t,i)};function dm(i){this.id=i,this.seq=[],this.map={}}dm.prototype.setValue=function(i,t,e){const n=this.seq;for(let r=0,s=n.length;r!==s;++r){const a=n[r];a.setValue(i,t[a.id],e)}};const Qh=/(\w+)(\])?(\[|\.)?/g;function fm(i,t){i.seq.push(t),i.map[t.id]=t}function vT(i,t,e){const n=i.name,r=n.length;for(Qh.lastIndex=0;;){const s=Qh.exec(n),a=Qh.lastIndex;let o=s[1];const l=s[2]==="]",c=s[3];if(l&&(o=o|0),c===void 0||c==="["&&a+2===r){fm(e,c===void 0?new _T(o,i,t):new um(o,i,t));break}else{let u=e.map[o];u===void 0&&(u=new dm(o),fm(e,u)),e=u}}}function Dn(i,t){this.seq=[],this.map={};const e=i.getProgramParameter(t,i.ACTIVE_UNIFORMS);for(let n=0;n<e;++n){const r=i.getActiveUniform(t,n),s=i.getUniformLocation(t,r.name);vT(r,s,this)}}Dn.prototype.setValue=function(i,t,e,n){const r=this.map[t];r!==void 0&&r.setValue(i,e,n)};Dn.prototype.setOptional=function(i,t,e){const n=t[e];n!==void 0&&this.setValue(i,e,n)};Dn.upload=function(i,t,e,n){for(let r=0,s=t.length;r!==s;++r){const a=t[r],o=e[a.id];o.needsUpdate!==!1&&a.setValue(i,o.value,n)}};Dn.seqWithValue=function(i,t){const e=[];for(let n=0,r=i.length;n!==r;++n){const s=i[n];s.id in t&&e.push(s)}return e};function pm(i,t,e){const n=i.createShader(t);return i.shaderSource(n,e),i.compileShader(n),n}let MT=0;function bT(i){const t=i.split(`
`);for(let e=0;e<t.length;e++)t[e]=e+1+": "+t[e];return t.join(`
`)}function mm(i){switch(i){case Go:return["Linear","( value )"];case yS:return["sRGB","( value )"];case vS:return["RGBE","( value )"];case bS:return["RGBM","( value, 7.0 )"];case wS:return["RGBM","( value, 16.0 )"];case SS:return["RGBD","( value, 256.0 )"];case _S:return["Gamma","( value, float( GAMMA_FACTOR ) )"];case MS:return["LogLuv","( value )"];default:return console.warn("THREE.WebGLProgram: Unsupported encoding:",i),["Linear","( value )"]}}function gm(i,t,e){const n=i.getShaderParameter(t,i.COMPILE_STATUS),r=i.getShaderInfoLog(t).trim();if(n&&r==="")return"";const s=i.getShaderSource(t);return"THREE.WebGLShader: gl.getShaderInfoLog() "+e+`
`+r+bT(s)}function wa(i,t){const e=mm(t);return"vec4 "+i+"( vec4 value ) { return "+e[0]+"ToLinear"+e[1]+"; }"}function wT(i,t){const e=mm(t);return"vec4 "+i+"( vec4 value ) { return LinearTo"+e[0]+e[1]+"; }"}function ST(i,t){let e;switch(t){case Mw:e="Linear";break;case bw:e="Reinhard";break;case ww:e="OptimizedCineon";break;case Sw:e="ACESFilmic";break;case Ew:e="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",t),e="Linear"}return"vec3 "+i+"( vec3 color ) { return "+e+"ToneMapping( color ); }"}function ET(i){return[i.extensionDerivatives||i.envMapCubeUV||i.bumpMap||i.tangentSpaceNormalMap||i.clearcoatNormalMap||i.flatShading||i.shaderID==="physical"?"#extension GL_OES_standard_derivatives : enable":"",(i.extensionFragDepth||i.logarithmicDepthBuffer)&&i.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",i.extensionDrawBuffers&&i.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(i.extensionShaderTextureLOD||i.envMap)&&i.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(Sa).join(`
`)}function AT(i){const t=[];for(const e in i){const n=i[e];n!==!1&&t.push("#define "+e+" "+n)}return t.join(`
`)}function TT(i,t){const e={},n=i.getProgramParameter(t,i.ACTIVE_ATTRIBUTES);for(let r=0;r<n;r++){const a=i.getActiveAttrib(t,r).name;e[a]=i.getAttribLocation(t,a)}return e}function Sa(i){return i!==""}function xm(i,t){return i.replace(/NUM_DIR_LIGHTS/g,t.numDirLights).replace(/NUM_SPOT_LIGHTS/g,t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,t.numPointLights).replace(/NUM_HEMI_LIGHTS/g,t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g,t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,t.numPointLightShadows)}function ym(i,t){return i.replace(/NUM_CLIPPING_PLANES/g,t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,t.numClippingPlanes-t.numClipIntersection)}const LT=/^[ \t]*#include +<([\w\d./]+)>/gm;function Kh(i){return i.replace(LT,RT)}function RT(i,t){const e=Vt[t];if(e===void 0)throw new Error("Can not resolve #include <"+t+">");return Kh(e)}const CT=/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,PT=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function _m(i){return i.replace(PT,vm).replace(CT,DT)}function DT(i,t,e,n){return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."),vm(i,t,e,n)}function vm(i,t,e,n){let r="";for(let s=parseInt(t);s<parseInt(e);s++)r+=n.replace(/\[\s*i\s*\]/g,"[ "+s+" ]").replace(/UNROLLED_LOOP_INDEX/g,s);return r}function Mm(i){let t="precision "+i.precision+` float;
precision `+i.precision+" int;";return i.precision==="highp"?t+=`
#define HIGH_PRECISION`:i.precision==="mediump"?t+=`
#define MEDIUM_PRECISION`:i.precision==="lowp"&&(t+=`
#define LOW_PRECISION`),t}function FT(i){let t="SHADOWMAP_TYPE_BASIC";return i.shadowMapType===hp?t="SHADOWMAP_TYPE_PCF":i.shadowMapType===Qb?t="SHADOWMAP_TYPE_PCF_SOFT":i.shadowMapType===ha&&(t="SHADOWMAP_TYPE_VSM"),t}function IT(i){let t="ENVMAP_TYPE_CUBE";if(i.envMap)switch(i.envMapMode){case ch:case hh:t="ENVMAP_TYPE_CUBE";break;case uh:case dh:t="ENVMAP_TYPE_CUBE_UV";break}return t}function zT(i){let t="ENVMAP_MODE_REFLECTION";if(i.envMap)switch(i.envMapMode){case hh:case dh:t="ENVMAP_MODE_REFRACTION";break}return t}function NT(i){let t="ENVMAP_BLENDING_NONE";if(i.envMap)switch(i.combine){case yp:t="ENVMAP_BLENDING_MULTIPLY";break;case _w:t="ENVMAP_BLENDING_MIX";break;case vw:t="ENVMAP_BLENDING_ADD";break}return t}function BT(i,t,e,n){const r=i.getContext(),s=e.defines;let a=e.vertexShader,o=e.fragmentShader;const l=FT(e),c=IT(e),h=zT(e),u=NT(e),d=i.gammaFactor>0?i.gammaFactor:1,f=e.isWebGL2?"":ET(e),p=AT(s),x=r.createProgram();let y,g,m=e.glslVersion?"#version "+e.glslVersion+`
`:"";e.isRawShaderMaterial?(y=[p].filter(Sa).join(`
`),y.length>0&&(y+=`
`),g=[f,p].filter(Sa).join(`
`),g.length>0&&(g+=`
`)):(y=[Mm(e),"#define SHADER_NAME "+e.shaderName,p,e.instancing?"#define USE_INSTANCING":"",e.instancingColor?"#define USE_INSTANCING_COLOR":"",e.supportsVertexTextures?"#define VERTEX_TEXTURES":"","#define GAMMA_FACTOR "+d,"#define MAX_BONES "+e.maxBones,e.useFog&&e.fog?"#define USE_FOG":"",e.useFog&&e.fogExp2?"#define FOG_EXP2":"",e.map?"#define USE_MAP":"",e.envMap?"#define USE_ENVMAP":"",e.envMap?"#define "+h:"",e.lightMap?"#define USE_LIGHTMAP":"",e.aoMap?"#define USE_AOMAP":"",e.emissiveMap?"#define USE_EMISSIVEMAP":"",e.bumpMap?"#define USE_BUMPMAP":"",e.normalMap?"#define USE_NORMALMAP":"",e.normalMap&&e.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",e.normalMap&&e.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",e.clearcoatMap?"#define USE_CLEARCOATMAP":"",e.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",e.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",e.displacementMap&&e.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",e.specularMap?"#define USE_SPECULARMAP":"",e.roughnessMap?"#define USE_ROUGHNESSMAP":"",e.metalnessMap?"#define USE_METALNESSMAP":"",e.alphaMap?"#define USE_ALPHAMAP":"",e.transmissionMap?"#define USE_TRANSMISSIONMAP":"",e.vertexTangents?"#define USE_TANGENT":"",e.vertexColors?"#define USE_COLOR":"",e.vertexAlphas?"#define USE_COLOR_ALPHA":"",e.vertexUvs?"#define USE_UV":"",e.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",e.flatShading?"#define FLAT_SHADED":"",e.skinning?"#define USE_SKINNING":"",e.useVertexTexture?"#define BONE_TEXTURE":"",e.morphTargets?"#define USE_MORPHTARGETS":"",e.morphNormals&&e.flatShading===!1?"#define USE_MORPHNORMALS":"",e.doubleSided?"#define DOUBLE_SIDED":"",e.flipSided?"#define FLIP_SIDED":"",e.shadowMapEnabled?"#define USE_SHADOWMAP":"",e.shadowMapEnabled?"#define "+l:"",e.sizeAttenuation?"#define USE_SIZEATTENUATION":"",e.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",e.logarithmicDepthBuffer&&e.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","	attribute vec4 color;","#elif defined( USE_COLOR )","	attribute vec3 color;","#endif","#ifdef USE_MORPHTARGETS","	attribute vec3 morphTarget0;","	attribute vec3 morphTarget1;","	attribute vec3 morphTarget2;","	attribute vec3 morphTarget3;","	#ifdef USE_MORPHNORMALS","		attribute vec3 morphNormal0;","		attribute vec3 morphNormal1;","		attribute vec3 morphNormal2;","		attribute vec3 morphNormal3;","	#else","		attribute vec3 morphTarget4;","		attribute vec3 morphTarget5;","		attribute vec3 morphTarget6;","		attribute vec3 morphTarget7;","	#endif","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif",`
`].filter(Sa).join(`
`),g=[f,Mm(e),"#define SHADER_NAME "+e.shaderName,p,e.alphaTest?"#define ALPHATEST "+e.alphaTest+(e.alphaTest%1?"":".0"):"","#define GAMMA_FACTOR "+d,e.useFog&&e.fog?"#define USE_FOG":"",e.useFog&&e.fogExp2?"#define FOG_EXP2":"",e.map?"#define USE_MAP":"",e.matcap?"#define USE_MATCAP":"",e.envMap?"#define USE_ENVMAP":"",e.envMap?"#define "+c:"",e.envMap?"#define "+h:"",e.envMap?"#define "+u:"",e.lightMap?"#define USE_LIGHTMAP":"",e.aoMap?"#define USE_AOMAP":"",e.emissiveMap?"#define USE_EMISSIVEMAP":"",e.bumpMap?"#define USE_BUMPMAP":"",e.normalMap?"#define USE_NORMALMAP":"",e.normalMap&&e.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",e.normalMap&&e.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",e.clearcoatMap?"#define USE_CLEARCOATMAP":"",e.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",e.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",e.specularMap?"#define USE_SPECULARMAP":"",e.roughnessMap?"#define USE_ROUGHNESSMAP":"",e.metalnessMap?"#define USE_METALNESSMAP":"",e.alphaMap?"#define USE_ALPHAMAP":"",e.sheen?"#define USE_SHEEN":"",e.transmissionMap?"#define USE_TRANSMISSIONMAP":"",e.vertexTangents?"#define USE_TANGENT":"",e.vertexColors||e.instancingColor?"#define USE_COLOR":"",e.vertexAlphas?"#define USE_COLOR_ALPHA":"",e.vertexUvs?"#define USE_UV":"",e.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",e.gradientMap?"#define USE_GRADIENTMAP":"",e.flatShading?"#define FLAT_SHADED":"",e.doubleSided?"#define DOUBLE_SIDED":"",e.flipSided?"#define FLIP_SIDED":"",e.shadowMapEnabled?"#define USE_SHADOWMAP":"",e.shadowMapEnabled?"#define "+l:"",e.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",e.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":"",e.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",e.logarithmicDepthBuffer&&e.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"",(e.extensionShaderTextureLOD||e.envMap)&&e.rendererExtensionShaderTextureLod?"#define TEXTURE_LOD_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",e.toneMapping!==fa?"#define TONE_MAPPING":"",e.toneMapping!==fa?Vt.tonemapping_pars_fragment:"",e.toneMapping!==fa?ST("toneMapping",e.toneMapping):"",e.dithering?"#define DITHERING":"",Vt.encodings_pars_fragment,e.map?wa("mapTexelToLinear",e.mapEncoding):"",e.matcap?wa("matcapTexelToLinear",e.matcapEncoding):"",e.envMap?wa("envMapTexelToLinear",e.envMapEncoding):"",e.emissiveMap?wa("emissiveMapTexelToLinear",e.emissiveMapEncoding):"",e.lightMap?wa("lightMapTexelToLinear",e.lightMapEncoding):"",wT("linearToOutputTexel",e.outputEncoding),e.depthPacking?"#define DEPTH_PACKING "+e.depthPacking:"",`
`].filter(Sa).join(`
`)),a=Kh(a),a=xm(a,e),a=ym(a,e),o=Kh(o),o=xm(o,e),o=ym(o,e),a=_m(a),o=_m(o),e.isWebGL2&&e.isRawShaderMaterial!==!0&&(m=`#version 300 es
`,y=["#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+y,g=["#define varying in",e.glslVersion===zp?"":"out highp vec4 pc_fragColor;",e.glslVersion===zp?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+g);const E=m+y+a,w=m+g+o,S=pm(r,r.VERTEX_SHADER,E),_=pm(r,r.FRAGMENT_SHADER,w);if(r.attachShader(x,S),r.attachShader(x,_),e.index0AttributeName!==void 0?r.bindAttribLocation(x,0,e.index0AttributeName):e.morphTargets===!0&&r.bindAttribLocation(x,0,"position"),r.linkProgram(x),i.debug.checkShaderErrors){const N=r.getProgramInfoLog(x).trim(),G=r.getShaderInfoLog(S).trim(),D=r.getShaderInfoLog(_).trim();let V=!0,R=!0;if(r.getProgramParameter(x,r.LINK_STATUS)===!1){V=!1;const L=gm(r,S,"vertex"),P=gm(r,_,"fragment");console.error("THREE.WebGLProgram: shader error: ",r.getError(),"gl.VALIDATE_STATUS",r.getProgramParameter(x,r.VALIDATE_STATUS),"gl.getProgramInfoLog",N,L,P)}else N!==""?console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()",N):(G===""||D==="")&&(R=!1);R&&(this.diagnostics={runnable:V,programLog:N,vertexShader:{log:G,prefix:y},fragmentShader:{log:D,prefix:g}})}r.deleteShader(S),r.deleteShader(_);let T;this.getUniforms=function(){return T===void 0&&(T=new Dn(r,x)),T};let B;return this.getAttributes=function(){return B===void 0&&(B=TT(r,x)),B},this.destroy=function(){n.releaseStatesOfProgram(this),r.deleteProgram(x),this.program=void 0},this.name=e.shaderName,this.id=MT++,this.cacheKey=t,this.usedTimes=1,this.program=x,this.vertexShader=S,this.fragmentShader=_,this}function OT(i,t,e,n,r,s){const a=[],o=n.isWebGL2,l=n.logarithmicDepthBuffer,c=n.floatVertexTextures,h=n.maxVertexUniforms,u=n.vertexTextures;let d=n.precision;const f={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"},p=["precision","isWebGL2","supportsVertexTextures","outputEncoding","instancing","instancingColor","map","mapEncoding","matcap","matcapEncoding","envMap","envMapMode","envMapEncoding","envMapCubeUV","lightMap","lightMapEncoding","aoMap","emissiveMap","emissiveMapEncoding","bumpMap","normalMap","objectSpaceNormalMap","tangentSpaceNormalMap","clearcoatMap","clearcoatRoughnessMap","clearcoatNormalMap","displacementMap","specularMap","roughnessMap","metalnessMap","gradientMap","alphaMap","combine","vertexColors","vertexAlphas","vertexTangents","vertexUvs","uvsVertexOnly","fog","useFog","fogExp2","flatShading","sizeAttenuation","logarithmicDepthBuffer","skinning","maxBones","useVertexTexture","morphTargets","morphNormals","premultipliedAlpha","numDirLights","numPointLights","numSpotLights","numHemiLights","numRectAreaLights","numDirLightShadows","numPointLightShadows","numSpotLightShadows","shadowMapEnabled","shadowMapType","toneMapping","physicallyCorrectLights","alphaTest","doubleSided","flipSided","numClippingPlanes","numClipIntersection","depthPacking","dithering","sheen","transmissionMap"];function x(_){const B=_.skeleton.bones;if(c)return 1024;{const G=Math.floor((h-20)/4),D=Math.min(G,B.length);return D<B.length?(console.warn("THREE.WebGLRenderer: Skeleton has "+B.length+" bones. This GPU supports "+D+"."),0):D}}function y(_){let T;return _&&_.isTexture?T=_.encoding:_&&_.isWebGLRenderTarget?(console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."),T=_.texture.encoding):T=Go,T}function g(_,T,B,N,G){const D=N.fog,V=_.isMeshStandardMaterial?N.environment:null,R=t.get(_.envMap||V),L=f[_.type],P=G.isSkinnedMesh?x(G):0;_.precision!==null&&(d=n.getMaxPrecision(_.precision),d!==_.precision&&console.warn("THREE.WebGLProgram.getParameters:",_.precision,"not supported, using",d,"instead."));let F,W;if(L){const Q=Ui[L];F=Q.vertexShader,W=Q.fragmentShader}else F=_.vertexShader,W=_.fragmentShader;const j=i.getRenderTarget();return{isWebGL2:o,shaderID:L,shaderName:_.type,vertexShader:F,fragmentShader:W,defines:_.defines,isRawShaderMaterial:_.isRawShaderMaterial===!0,glslVersion:_.glslVersion,precision:d,instancing:G.isInstancedMesh===!0,instancingColor:G.isInstancedMesh===!0&&G.instanceColor!==null,supportsVertexTextures:u,outputEncoding:j!==null?y(j.texture):i.outputEncoding,map:!!_.map,mapEncoding:y(_.map),matcap:!!_.matcap,matcapEncoding:y(_.matcap),envMap:!!R,envMapMode:R&&R.mapping,envMapEncoding:y(R),envMapCubeUV:!!R&&(R.mapping===uh||R.mapping===dh),lightMap:!!_.lightMap,lightMapEncoding:y(_.lightMap),aoMap:!!_.aoMap,emissiveMap:!!_.emissiveMap,emissiveMapEncoding:y(_.emissiveMap),bumpMap:!!_.bumpMap,normalMap:!!_.normalMap,objectSpaceNormalMap:_.normalMapType===LS,tangentSpaceNormalMap:_.normalMapType===TS,clearcoatMap:!!_.clearcoatMap,clearcoatRoughnessMap:!!_.clearcoatRoughnessMap,clearcoatNormalMap:!!_.clearcoatNormalMap,displacementMap:!!_.displacementMap,roughnessMap:!!_.roughnessMap,metalnessMap:!!_.metalnessMap,specularMap:!!_.specularMap,alphaMap:!!_.alphaMap,gradientMap:!!_.gradientMap,sheen:!!_.sheen,transmissionMap:!!_.transmissionMap,combine:_.combine,vertexTangents:_.normalMap&&_.vertexTangents,vertexColors:_.vertexColors,vertexAlphas:_.vertexColors===!0&&G.geometry.attributes.color&&G.geometry.attributes.color.itemSize===4,vertexUvs:!!_.map||!!_.bumpMap||!!_.normalMap||!!_.specularMap||!!_.alphaMap||!!_.emissiveMap||!!_.roughnessMap||!!_.metalnessMap||!!_.clearcoatMap||!!_.clearcoatRoughnessMap||!!_.clearcoatNormalMap||!!_.displacementMap||!!_.transmissionMap,uvsVertexOnly:!(!!_.map||!!_.bumpMap||!!_.normalMap||!!_.specularMap||!!_.alphaMap||!!_.emissiveMap||!!_.roughnessMap||!!_.metalnessMap||!!_.clearcoatNormalMap||!!_.transmissionMap)&&!!_.displacementMap,fog:!!D,useFog:_.fog,fogExp2:D&&D.isFogExp2,flatShading:!!_.flatShading,sizeAttenuation:_.sizeAttenuation,logarithmicDepthBuffer:l,skinning:_.skinning&&P>0,maxBones:P,useVertexTexture:c,morphTargets:_.morphTargets,morphNormals:_.morphNormals,numDirLights:T.directional.length,numPointLights:T.point.length,numSpotLights:T.spot.length,numRectAreaLights:T.rectArea.length,numHemiLights:T.hemi.length,numDirLightShadows:T.directionalShadowMap.length,numPointLightShadows:T.pointShadowMap.length,numSpotLightShadows:T.spotShadowMap.length,numClippingPlanes:s.numPlanes,numClipIntersection:s.numIntersection,dithering:_.dithering,shadowMapEnabled:i.shadowMap.enabled&&B.length>0,shadowMapType:i.shadowMap.type,toneMapping:_.toneMapped?i.toneMapping:fa,physicallyCorrectLights:i.physicallyCorrectLights,premultipliedAlpha:_.premultipliedAlpha,alphaTest:_.alphaTest,doubleSided:_.side===Bo,flipSided:_.side===Le,depthPacking:_.depthPacking!==void 0?_.depthPacking:!1,index0AttributeName:_.index0AttributeName,extensionDerivatives:_.extensions&&_.extensions.derivatives,extensionFragDepth:_.extensions&&_.extensions.fragDepth,extensionDrawBuffers:_.extensions&&_.extensions.drawBuffers,extensionShaderTextureLOD:_.extensions&&_.extensions.shaderTextureLOD,rendererExtensionFragDepth:o||e.has("EXT_frag_depth"),rendererExtensionDrawBuffers:o||e.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:o||e.has("EXT_shader_texture_lod"),customProgramCacheKey:_.customProgramCacheKey()}}function m(_){const T=[];if(_.shaderID?T.push(_.shaderID):(T.push(_.fragmentShader),T.push(_.vertexShader)),_.defines!==void 0)for(const B in _.defines)T.push(B),T.push(_.defines[B]);if(_.isRawShaderMaterial===!1){for(let B=0;B<p.length;B++)T.push(_[p[B]]);T.push(i.outputEncoding),T.push(i.gammaFactor)}return T.push(_.customProgramCacheKey),T.join()}function E(_){const T=f[_.type];let B;if(T){const N=Ui[T];B=XS.clone(N.uniforms)}else B=_.uniforms;return B}function w(_,T){let B;for(let N=0,G=a.length;N<G;N++){const D=a[N];if(D.cacheKey===T){B=D,++B.usedTimes;break}}return B===void 0&&(B=new BT(i,T,_,r),a.push(B)),B}function S(_){if(--_.usedTimes==0){const T=a.indexOf(_);a[T]=a[a.length-1],a.pop(),_.destroy()}}return{getParameters:g,getProgramCacheKey:m,getUniforms:E,acquireProgram:w,releaseProgram:S,programs:a}}function UT(){let i=new WeakMap;function t(s){let a=i.get(s);return a===void 0&&(a={},i.set(s,a)),a}function e(s){i.delete(s)}function n(s,a,o){i.get(s)[a]=o}function r(){i=new WeakMap}return{get:t,remove:e,update:n,dispose:r}}function HT(i,t){return i.groupOrder!==t.groupOrder?i.groupOrder-t.groupOrder:i.renderOrder!==t.renderOrder?i.renderOrder-t.renderOrder:i.program!==t.program?i.program.id-t.program.id:i.material.id!==t.material.id?i.material.id-t.material.id:i.z!==t.z?i.z-t.z:i.id-t.id}function GT(i,t){return i.groupOrder!==t.groupOrder?i.groupOrder-t.groupOrder:i.renderOrder!==t.renderOrder?i.renderOrder-t.renderOrder:i.z!==t.z?t.z-i.z:i.id-t.id}function bm(i){const t=[];let e=0;const n=[],r=[],s={id:-1};function a(){e=0,n.length=0,r.length=0}function o(d,f,p,x,y,g){let m=t[e];const E=i.get(p);return m===void 0?(m={id:d.id,object:d,geometry:f,material:p,program:E.program||s,groupOrder:x,renderOrder:d.renderOrder,z:y,group:g},t[e]=m):(m.id=d.id,m.object=d,m.geometry=f,m.material=p,m.program=E.program||s,m.groupOrder=x,m.renderOrder=d.renderOrder,m.z=y,m.group=g),e++,m}function l(d,f,p,x,y,g){const m=o(d,f,p,x,y,g);(p.transparent===!0?r:n).push(m)}function c(d,f,p,x,y,g){const m=o(d,f,p,x,y,g);(p.transparent===!0?r:n).unshift(m)}function h(d,f){n.length>1&&n.sort(d||HT),r.length>1&&r.sort(f||GT)}function u(){for(let d=e,f=t.length;d<f;d++){const p=t[d];if(p.id===null)break;p.id=null,p.object=null,p.geometry=null,p.material=null,p.program=null,p.group=null}}return{opaque:n,transparent:r,init:a,push:l,unshift:c,finish:u,sort:h}}function kT(i){let t=new WeakMap;function e(r,s){let a;return t.has(r)===!1?(a=new bm(i),t.set(r,[a])):s>=t.get(r).length?(a=new bm(i),t.get(r).push(a)):a=t.get(r)[s],a}function n(){t=new WeakMap}return{get:e,dispose:n}}function VT(){const i={};return{get:function(t){if(i[t.id]!==void 0)return i[t.id];let e;switch(t.type){case"DirectionalLight":e={direction:new Z,color:new Jt};break;case"SpotLight":e={position:new Z,direction:new Z,color:new Jt,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":e={position:new Z,color:new Jt,distance:0,decay:0};break;case"HemisphereLight":e={direction:new Z,skyColor:new Jt,groundColor:new Jt};break;case"RectAreaLight":e={color:new Jt,position:new Z,halfWidth:new Z,halfHeight:new Z};break}return i[t.id]=e,e}}}function WT(){const i={};return{get:function(t){if(i[t.id]!==void 0)return i[t.id];let e;switch(t.type){case"DirectionalLight":e={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new ee};break;case"SpotLight":e={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new ee};break;case"PointLight":e={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new ee,shadowCameraNear:1,shadowCameraFar:1e3};break}return i[t.id]=e,e}}}let $T=0;function XT(i,t){return(t.castShadow?1:0)-(i.castShadow?1:0)}function qT(i,t){const e=new VT,n=WT(),r={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadow:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[]};for(let h=0;h<9;h++)r.probe.push(new Z);const s=new Z,a=new Ce,o=new Ce;function l(h){let u=0,d=0,f=0;for(let T=0;T<9;T++)r.probe[T].set(0,0,0);let p=0,x=0,y=0,g=0,m=0,E=0,w=0,S=0;h.sort(XT);for(let T=0,B=h.length;T<B;T++){const N=h[T],G=N.color,D=N.intensity,V=N.distance,R=N.shadow&&N.shadow.map?N.shadow.map.texture:null;if(N.isAmbientLight)u+=G.r*D,d+=G.g*D,f+=G.b*D;else if(N.isLightProbe)for(let L=0;L<9;L++)r.probe[L].addScaledVector(N.sh.coefficients[L],D);else if(N.isDirectionalLight){const L=e.get(N);if(L.color.copy(N.color).multiplyScalar(N.intensity),N.castShadow){const P=N.shadow,F=n.get(N);F.shadowBias=P.bias,F.shadowNormalBias=P.normalBias,F.shadowRadius=P.radius,F.shadowMapSize=P.mapSize,r.directionalShadow[p]=F,r.directionalShadowMap[p]=R,r.directionalShadowMatrix[p]=N.shadow.matrix,E++}r.directional[p]=L,p++}else if(N.isSpotLight){const L=e.get(N);if(L.position.setFromMatrixPosition(N.matrixWorld),L.color.copy(G).multiplyScalar(D),L.distance=V,L.coneCos=Math.cos(N.angle),L.penumbraCos=Math.cos(N.angle*(1-N.penumbra)),L.decay=N.decay,N.castShadow){const P=N.shadow,F=n.get(N);F.shadowBias=P.bias,F.shadowNormalBias=P.normalBias,F.shadowRadius=P.radius,F.shadowMapSize=P.mapSize,r.spotShadow[y]=F,r.spotShadowMap[y]=R,r.spotShadowMatrix[y]=N.shadow.matrix,S++}r.spot[y]=L,y++}else if(N.isRectAreaLight){const L=e.get(N);L.color.copy(G).multiplyScalar(D),L.halfWidth.set(N.width*.5,0,0),L.halfHeight.set(0,N.height*.5,0),r.rectArea[g]=L,g++}else if(N.isPointLight){const L=e.get(N);if(L.color.copy(N.color).multiplyScalar(N.intensity),L.distance=N.distance,L.decay=N.decay,N.castShadow){const P=N.shadow,F=n.get(N);F.shadowBias=P.bias,F.shadowNormalBias=P.normalBias,F.shadowRadius=P.radius,F.shadowMapSize=P.mapSize,F.shadowCameraNear=P.camera.near,F.shadowCameraFar=P.camera.far,r.pointShadow[x]=F,r.pointShadowMap[x]=R,r.pointShadowMatrix[x]=N.shadow.matrix,w++}r.point[x]=L,x++}else if(N.isHemisphereLight){const L=e.get(N);L.skyColor.copy(N.color).multiplyScalar(D),L.groundColor.copy(N.groundColor).multiplyScalar(D),r.hemi[m]=L,m++}}g>0&&(t.isWebGL2||i.has("OES_texture_float_linear")===!0?(r.rectAreaLTC1=vt.LTC_FLOAT_1,r.rectAreaLTC2=vt.LTC_FLOAT_2):i.has("OES_texture_half_float_linear")===!0?(r.rectAreaLTC1=vt.LTC_HALF_1,r.rectAreaLTC2=vt.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),r.ambient[0]=u,r.ambient[1]=d,r.ambient[2]=f;const _=r.hash;(_.directionalLength!==p||_.pointLength!==x||_.spotLength!==y||_.rectAreaLength!==g||_.hemiLength!==m||_.numDirectionalShadows!==E||_.numPointShadows!==w||_.numSpotShadows!==S)&&(r.directional.length=p,r.spot.length=y,r.rectArea.length=g,r.point.length=x,r.hemi.length=m,r.directionalShadow.length=E,r.directionalShadowMap.length=E,r.pointShadow.length=w,r.pointShadowMap.length=w,r.spotShadow.length=S,r.spotShadowMap.length=S,r.directionalShadowMatrix.length=E,r.pointShadowMatrix.length=w,r.spotShadowMatrix.length=S,_.directionalLength=p,_.pointLength=x,_.spotLength=y,_.rectAreaLength=g,_.hemiLength=m,_.numDirectionalShadows=E,_.numPointShadows=w,_.numSpotShadows=S,r.version=$T++)}function c(h,u){let d=0,f=0,p=0,x=0,y=0;const g=u.matrixWorldInverse;for(let m=0,E=h.length;m<E;m++){const w=h[m];if(w.isDirectionalLight){const S=r.directional[d];S.direction.setFromMatrixPosition(w.matrixWorld),s.setFromMatrixPosition(w.target.matrixWorld),S.direction.sub(s),S.direction.transformDirection(g),d++}else if(w.isSpotLight){const S=r.spot[p];S.position.setFromMatrixPosition(w.matrixWorld),S.position.applyMatrix4(g),S.direction.setFromMatrixPosition(w.matrixWorld),s.setFromMatrixPosition(w.target.matrixWorld),S.direction.sub(s),S.direction.transformDirection(g),p++}else if(w.isRectAreaLight){const S=r.rectArea[x];S.position.setFromMatrixPosition(w.matrixWorld),S.position.applyMatrix4(g),o.identity(),a.copy(w.matrixWorld),a.premultiply(g),o.extractRotation(a),S.halfWidth.set(w.width*.5,0,0),S.halfHeight.set(0,w.height*.5,0),S.halfWidth.applyMatrix4(o),S.halfHeight.applyMatrix4(o),x++}else if(w.isPointLight){const S=r.point[f];S.position.setFromMatrixPosition(w.matrixWorld),S.position.applyMatrix4(g),f++}else if(w.isHemisphereLight){const S=r.hemi[y];S.direction.setFromMatrixPosition(w.matrixWorld),S.direction.transformDirection(g),S.direction.normalize(),y++}}}return{setup:l,setupView:c,state:r}}function wm(i,t){const e=new qT(i,t),n=[],r=[];function s(){n.length=0,r.length=0}function a(u){n.push(u)}function o(u){r.push(u)}function l(){e.setup(n)}function c(u){e.setupView(n,u)}return{init:s,state:{lightsArray:n,shadowsArray:r,lights:e},setupLights:l,setupLightsView:c,pushLight:a,pushShadow:o}}function YT(i,t){let e=new WeakMap;function n(s,a=0){let o;return e.has(s)===!1?(o=new wm(i,t),e.set(s,[o])):a>=e.get(s).length?(o=new wm(i,t),e.get(s).push(o)):o=e.get(s)[a],o}function r(){e=new WeakMap}return{get:n,dispose:r}}class Sm extends Bi{constructor(t){super();this.type="MeshDepthMaterial",this.depthPacking=ES,this.skinning=!1,this.morphTargets=!1,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.setValues(t)}copy(t){return super.copy(t),this.depthPacking=t.depthPacking,this.skinning=t.skinning,this.morphTargets=t.morphTargets,this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this}}Sm.prototype.isMeshDepthMaterial=!0;class Em extends Bi{constructor(t){super();this.type="MeshDistanceMaterial",this.referencePosition=new Z,this.nearDistance=1,this.farDistance=1e3,this.skinning=!1,this.morphTargets=!1,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.fog=!1,this.setValues(t)}copy(t){return super.copy(t),this.referencePosition.copy(t.referencePosition),this.nearDistance=t.nearDistance,this.farDistance=t.farDistance,this.skinning=t.skinning,this.morphTargets=t.morphTargets,this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this}}Em.prototype.isMeshDistanceMaterial=!0;var jT=`
uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;

#include <packing>

void main() {

	float mean = 0.0;
	float squared_mean = 0.0;

	// This seems totally useless but it's a crazy work around for a Adreno compiler bug
	float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );

	for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {

		#ifdef HORIZONTAL_PASS

			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;

		#else

			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;

		#endif

	}

	mean = mean * HALF_SAMPLE_RATE;
	squared_mean = squared_mean * HALF_SAMPLE_RATE;

	float std_dev = sqrt( squared_mean - mean * mean );

	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );

}
`,ZT=`
void main() {

	gl_Position = vec4( position, 1.0 );

}
`;function JT(i,t,e){let n=new Up;const r=new ee,s=new ee,a=new Ie,o=[],l=[],c={},h=e.maxTextureSize,u={0:Le,1:No,2:Bo},d=new Oi({defines:{SAMPLE_RATE:2/8,HALF_SAMPLE_RATE:1/8},uniforms:{shadow_pass:{value:null},resolution:{value:new ee},radius:{value:4}},vertexShader:ZT,fragmentShader:jT}),f=d.clone();f.defines.HORIZONTAL_PASS=1;const p=new Tn;p.setAttribute("position",new te(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const x=new rs(p,d),y=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=hp,this.render=function(_,T,B){if(y.enabled===!1||y.autoUpdate===!1&&y.needsUpdate===!1||_.length===0)return;const N=i.getRenderTarget(),G=i.getActiveCubeFace(),D=i.getActiveMipmapLevel(),V=i.state;V.setBlending(ua),V.buffers.color.setClear(1,1,1,1),V.buffers.depth.setTest(!0),V.setScissorTest(!1);for(let R=0,L=_.length;R<L;R++){const P=_[R],F=P.shadow;if(F===void 0){console.warn("THREE.WebGLShadowMap:",P,"has no shadow.");continue}if(F.autoUpdate===!1&&F.needsUpdate===!1)continue;r.copy(F.mapSize);const W=F.getFrameExtents();if(r.multiply(W),s.copy(F.mapSize),(r.x>h||r.y>h)&&(r.x>h&&(s.x=Math.floor(h/W.x),r.x=s.x*W.x,F.mapSize.x=s.x),r.y>h&&(s.y=Math.floor(h/W.y),r.y=s.y*W.y,F.mapSize.y=s.y)),F.map===null&&!F.isPointLightShadow&&this.type===ha){const Y={minFilter:Fi,magFilter:Fi,format:Ii};F.map=new Ma(r.x,r.y,Y),F.map.texture.name=P.name+".shadowMap",F.mapPass=new Ma(r.x,r.y,Y),F.camera.updateProjectionMatrix()}if(F.map===null){const Y={minFilter:je,magFilter:je,format:Ii};F.map=new Ma(r.x,r.y,Y),F.map.texture.name=P.name+".shadowMap",F.camera.updateProjectionMatrix()}i.setRenderTarget(F.map),i.clear();const j=F.getViewportCount();for(let Y=0;Y<j;Y++){const Q=F.getViewport(Y);a.set(s.x*Q.x,s.y*Q.y,s.x*Q.z,s.y*Q.w),V.viewport(a),F.updateMatrices(P,Y),n=F.getFrustum(),S(T,B,F.camera,P,this.type)}!F.isPointLightShadow&&this.type===ha&&g(F,B),F.needsUpdate=!1}y.needsUpdate=!1,i.setRenderTarget(N,G,D)};function g(_,T){const B=t.update(x);d.uniforms.shadow_pass.value=_.map.texture,d.uniforms.resolution.value=_.mapSize,d.uniforms.radius.value=_.radius,i.setRenderTarget(_.mapPass),i.clear(),i.renderBufferDirect(T,null,B,d,x,null),f.uniforms.shadow_pass.value=_.mapPass.texture,f.uniforms.resolution.value=_.mapSize,f.uniforms.radius.value=_.radius,i.setRenderTarget(_.map),i.clear(),i.renderBufferDirect(T,null,B,f,x,null)}function m(_,T,B){const N=_<<0|T<<1|B<<2;let G=o[N];return G===void 0&&(G=new Sm({depthPacking:AS,morphTargets:_,skinning:T}),o[N]=G),G}function E(_,T,B){const N=_<<0|T<<1|B<<2;let G=l[N];return G===void 0&&(G=new Em({morphTargets:_,skinning:T}),l[N]=G),G}function w(_,T,B,N,G,D,V){let R=null,L=m,P=_.customDepthMaterial;if(N.isPointLight===!0&&(L=E,P=_.customDistanceMaterial),P===void 0){let F=!1;B.morphTargets===!0&&(F=T.morphAttributes&&T.morphAttributes.position&&T.morphAttributes.position.length>0);let W=!1;_.isSkinnedMesh===!0&&(B.skinning===!0?W=!0:console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:",_));const j=_.isInstancedMesh===!0;R=L(F,W,j)}else R=P;if(i.localClippingEnabled&&B.clipShadows===!0&&B.clippingPlanes.length!==0){const F=R.uuid,W=B.uuid;let j=c[F];j===void 0&&(j={},c[F]=j);let Y=j[W];Y===void 0&&(Y=R.clone(),j[W]=Y),R=Y}return R.visible=B.visible,R.wireframe=B.wireframe,V===ha?R.side=B.shadowSide!==null?B.shadowSide:B.side:R.side=B.shadowSide!==null?B.shadowSide:u[B.side],R.clipShadows=B.clipShadows,R.clippingPlanes=B.clippingPlanes,R.clipIntersection=B.clipIntersection,R.wireframeLinewidth=B.wireframeLinewidth,R.linewidth=B.linewidth,N.isPointLight===!0&&R.isMeshDistanceMaterial===!0&&(R.referencePosition.setFromMatrixPosition(N.matrixWorld),R.nearDistance=G,R.farDistance=D),R}function S(_,T,B,N,G){if(_.visible===!1)return;if(_.layers.test(T.layers)&&(_.isMesh||_.isLine||_.isPoints)&&(_.castShadow||_.receiveShadow&&G===ha)&&(!_.frustumCulled||n.intersectsObject(_))){_.modelViewMatrix.multiplyMatrices(B.matrixWorldInverse,_.matrixWorld);const R=t.update(_),L=_.material;if(Array.isArray(L)){const P=R.groups;for(let F=0,W=P.length;F<W;F++){const j=P[F],Y=L[j.materialIndex];if(Y&&Y.visible){const Q=w(_,R,Y,N,B.near,B.far,G);i.renderBufferDirect(B,null,R,Q,_,j)}}}else if(L.visible){const P=w(_,R,L,N,B.near,B.far,G);i.renderBufferDirect(B,null,R,P,_,null)}}const V=_.children;for(let R=0,L=V.length;R<L;R++)S(V[R],T,B,N,G)}}function QT(i,t,e){const n=e.isWebGL2;function r(){let A=!1;const C=new Ie;let q=null;const et=new Ie(0,0,0,0);return{setMask:function(k){q!==k&&!A&&(i.colorMask(k,k,k,k),q=k)},setLocked:function(k){A=k},setClear:function(k,at,Rt,Nt,xe){xe===!0&&(k*=Nt,at*=Nt,Rt*=Nt),C.set(k,at,Rt,Nt),et.equals(C)===!1&&(i.clearColor(k,at,Rt,Nt),et.copy(C))},reset:function(){A=!1,q=null,et.set(-1,0,0,0)}}}function s(){let A=!1,C=null,q=null,et=null;return{setTest:function(k){k?st(i.DEPTH_TEST):ct(i.DEPTH_TEST)},setMask:function(k){C!==k&&!A&&(i.depthMask(k),C=k)},setFunc:function(k){if(q!==k){if(k)switch(k){case dw:i.depthFunc(i.NEVER);break;case fw:i.depthFunc(i.ALWAYS);break;case pw:i.depthFunc(i.LESS);break;case lh:i.depthFunc(i.LEQUAL);break;case mw:i.depthFunc(i.EQUAL);break;case gw:i.depthFunc(i.GEQUAL);break;case xw:i.depthFunc(i.GREATER);break;case yw:i.depthFunc(i.NOTEQUAL);break;default:i.depthFunc(i.LEQUAL)}else i.depthFunc(i.LEQUAL);q=k}},setLocked:function(k){A=k},setClear:function(k){et!==k&&(i.clearDepth(k),et=k)},reset:function(){A=!1,C=null,q=null,et=null}}}function a(){let A=!1,C=null,q=null,et=null,k=null,at=null,Rt=null,Nt=null,xe=null;return{setTest:function(Ft){A||(Ft?st(i.STENCIL_TEST):ct(i.STENCIL_TEST))},setMask:function(Ft){C!==Ft&&!A&&(i.stencilMask(Ft),C=Ft)},setFunc:function(Ft,Xt,re){(q!==Ft||et!==Xt||k!==re)&&(i.stencilFunc(Ft,Xt,re),q=Ft,et=Xt,k=re)},setOp:function(Ft,Xt,re){(at!==Ft||Rt!==Xt||Nt!==re)&&(i.stencilOp(Ft,Xt,re),at=Ft,Rt=Xt,Nt=re)},setLocked:function(Ft){A=Ft},setClear:function(Ft){xe!==Ft&&(i.clearStencil(Ft),xe=Ft)},reset:function(){A=!1,C=null,q=null,et=null,k=null,at=null,Rt=null,Nt=null,xe=null}}}const o=new r,l=new s,c=new a;let h={},u=null,d={},f=null,p=!1,x=null,y=null,g=null,m=null,E=null,w=null,S=null,_=!1,T=null,B=null,N=null,G=null,D=null;const V=i.getParameter(i.MAX_COMBINED_TEXTURE_IMAGE_UNITS);let R=!1,L=0;const P=i.getParameter(i.VERSION);P.indexOf("WebGL")!==-1?(L=parseFloat(/^WebGL (\d)/.exec(P)[1]),R=L>=1):P.indexOf("OpenGL ES")!==-1&&(L=parseFloat(/^OpenGL ES (\d)/.exec(P)[1]),R=L>=2);let F=null,W={};const j=new Ie(0,0,i.canvas.width,i.canvas.height),Y=new Ie(0,0,i.canvas.width,i.canvas.height);function Q(A,C,q){const et=new Uint8Array(4),k=i.createTexture();i.bindTexture(A,k),i.texParameteri(A,i.TEXTURE_MIN_FILTER,i.NEAREST),i.texParameteri(A,i.TEXTURE_MAG_FILTER,i.NEAREST);for(let at=0;at<q;at++)i.texImage2D(C+at,0,i.RGBA,1,1,0,i.RGBA,i.UNSIGNED_BYTE,et);return k}const K={};K[i.TEXTURE_2D]=Q(i.TEXTURE_2D,i.TEXTURE_2D,1),K[i.TEXTURE_CUBE_MAP]=Q(i.TEXTURE_CUBE_MAP,i.TEXTURE_CUBE_MAP_POSITIVE_X,6),o.setClear(0,0,0,1),l.setClear(1),c.setClear(0),st(i.DEPTH_TEST),l.setFunc(lh),St(!1),rt(cp),st(i.CULL_FACE),Ct(ua);function st(A){h[A]!==!0&&(i.enable(A),h[A]=!0)}function ct(A){h[A]!==!1&&(i.disable(A),h[A]=!1)}function z(A){A!==u&&(i.bindFramebuffer(i.FRAMEBUFFER,A),u=A)}function Et(A,C){C===null&&u!==null&&(C=u),d[A]!==C&&(i.bindFramebuffer(A,C),d[A]=C)}function At(A){return f!==A?(i.useProgram(A),f=A,!0):!1}const yt={[Wr]:i.FUNC_ADD,[ew]:i.FUNC_SUBTRACT,[iw]:i.FUNC_REVERSE_SUBTRACT};if(n)yt[pp]=i.MIN,yt[mp]=i.MAX;else{const A=t.get("EXT_blend_minmax");A!==null&&(yt[pp]=A.MIN_EXT,yt[mp]=A.MAX_EXT)}const ot={[nw]:i.ZERO,[rw]:i.ONE,[sw]:i.SRC_COLOR,[gp]:i.SRC_ALPHA,[uw]:i.SRC_ALPHA_SATURATE,[cw]:i.DST_COLOR,[ow]:i.DST_ALPHA,[aw]:i.ONE_MINUS_SRC_COLOR,[xp]:i.ONE_MINUS_SRC_ALPHA,[hw]:i.ONE_MINUS_DST_COLOR,[lw]:i.ONE_MINUS_DST_ALPHA};function Ct(A,C,q,et,k,at,Rt,Nt){if(A===ua){p===!0&&(ct(i.BLEND),p=!1);return}if(p===!1&&(st(i.BLEND),p=!0),A!==tw){if(A!==x||Nt!==_){if((y!==Wr||E!==Wr)&&(i.blendEquation(i.FUNC_ADD),y=Wr,E=Wr),Nt)switch(A){case da:i.blendFuncSeparate(i.ONE,i.ONE_MINUS_SRC_ALPHA,i.ONE,i.ONE_MINUS_SRC_ALPHA);break;case up:i.blendFunc(i.ONE,i.ONE);break;case dp:i.blendFuncSeparate(i.ZERO,i.ZERO,i.ONE_MINUS_SRC_COLOR,i.ONE_MINUS_SRC_ALPHA);break;case fp:i.blendFuncSeparate(i.ZERO,i.SRC_COLOR,i.ZERO,i.SRC_ALPHA);break;default:console.error("THREE.WebGLState: Invalid blending: ",A);break}else switch(A){case da:i.blendFuncSeparate(i.SRC_ALPHA,i.ONE_MINUS_SRC_ALPHA,i.ONE,i.ONE_MINUS_SRC_ALPHA);break;case up:i.blendFunc(i.SRC_ALPHA,i.ONE);break;case dp:i.blendFunc(i.ZERO,i.ONE_MINUS_SRC_COLOR);break;case fp:i.blendFunc(i.ZERO,i.SRC_COLOR);break;default:console.error("THREE.WebGLState: Invalid blending: ",A);break}g=null,m=null,w=null,S=null,x=A,_=Nt}return}k=k||C,at=at||q,Rt=Rt||et,(C!==y||k!==E)&&(i.blendEquationSeparate(yt[C],yt[k]),y=C,E=k),(q!==g||et!==m||at!==w||Rt!==S)&&(i.blendFuncSeparate(ot[q],ot[et],ot[at],ot[Rt]),g=q,m=et,w=at,S=Rt),x=A,_=null}function Mt(A,C){A.side===Bo?ct(i.CULL_FACE):st(i.CULL_FACE);let q=A.side===Le;C&&(q=!q),St(q),A.blending===da&&A.transparent===!1?Ct(ua):Ct(A.blending,A.blendEquation,A.blendSrc,A.blendDst,A.blendEquationAlpha,A.blendSrcAlpha,A.blendDstAlpha,A.premultipliedAlpha),l.setFunc(A.depthFunc),l.setTest(A.depthTest),l.setMask(A.depthWrite),o.setMask(A.colorWrite);const et=A.stencilWrite;c.setTest(et),et&&(c.setMask(A.stencilWriteMask),c.setFunc(A.stencilFunc,A.stencilRef,A.stencilFuncMask),c.setOp(A.stencilFail,A.stencilZFail,A.stencilZPass)),mt(A.polygonOffset,A.polygonOffsetFactor,A.polygonOffsetUnits),A.alphaToCoverage===!0?st(i.SAMPLE_ALPHA_TO_COVERAGE):ct(i.SAMPLE_ALPHA_TO_COVERAGE)}function St(A){T!==A&&(A?i.frontFace(i.CW):i.frontFace(i.CCW),T=A)}function rt(A){A!==Zb?(st(i.CULL_FACE),A!==B&&(A===cp?i.cullFace(i.BACK):A===Jb?i.cullFace(i.FRONT):i.cullFace(i.FRONT_AND_BACK))):ct(i.CULL_FACE),B=A}function dt(A){A!==N&&(R&&i.lineWidth(A),N=A)}function mt(A,C,q){A?(st(i.POLYGON_OFFSET_FILL),(G!==C||D!==q)&&(i.polygonOffset(C,q),G=C,D=q)):ct(i.POLYGON_OFFSET_FILL)}function bt(A){A?st(i.SCISSOR_TEST):ct(i.SCISSOR_TEST)}function ft(A){A===void 0&&(A=i.TEXTURE0+V-1),F!==A&&(i.activeTexture(A),F=A)}function b(A,C){F===null&&ft();let q=W[F];q===void 0&&(q={type:void 0,texture:void 0},W[F]=q),(q.type!==A||q.texture!==C)&&(i.bindTexture(A,C||K[A]),q.type=A,q.texture=C)}function M(){const A=W[F];A!==void 0&&A.type!==void 0&&(i.bindTexture(A.type,null),A.type=void 0,A.texture=void 0)}function X(){try{i.compressedTexImage2D.apply(i,arguments)}catch(A){console.error("THREE.WebGLState:",A)}}function $(){try{i.texImage2D.apply(i,arguments)}catch(A){console.error("THREE.WebGLState:",A)}}function tt(){try{i.texImage3D.apply(i,arguments)}catch(A){console.error("THREE.WebGLState:",A)}}function nt(A){j.equals(A)===!1&&(i.scissor(A.x,A.y,A.z,A.w),j.copy(A))}function Lt(A){Y.equals(A)===!1&&(i.viewport(A.x,A.y,A.z,A.w),Y.copy(A))}function xt(){i.disable(i.BLEND),i.disable(i.CULL_FACE),i.disable(i.DEPTH_TEST),i.disable(i.POLYGON_OFFSET_FILL),i.disable(i.SCISSOR_TEST),i.disable(i.STENCIL_TEST),i.disable(i.SAMPLE_ALPHA_TO_COVERAGE),i.blendEquation(i.FUNC_ADD),i.blendFunc(i.ONE,i.ZERO),i.blendFuncSeparate(i.ONE,i.ZERO,i.ONE,i.ZERO),i.colorMask(!0,!0,!0,!0),i.clearColor(0,0,0,0),i.depthMask(!0),i.depthFunc(i.LESS),i.clearDepth(1),i.stencilMask(4294967295),i.stencilFunc(i.ALWAYS,0,4294967295),i.stencilOp(i.KEEP,i.KEEP,i.KEEP),i.clearStencil(0),i.cullFace(i.BACK),i.frontFace(i.CCW),i.polygonOffset(0,0),i.activeTexture(i.TEXTURE0),i.bindFramebuffer(i.FRAMEBUFFER,null),n===!0&&(i.bindFramebuffer(i.DRAW_FRAMEBUFFER,null),i.bindFramebuffer(i.READ_FRAMEBUFFER,null)),i.useProgram(null),i.lineWidth(1),i.scissor(0,0,i.canvas.width,i.canvas.height),i.viewport(0,0,i.canvas.width,i.canvas.height),h={},F=null,W={},u=null,d={},f=null,p=!1,x=null,y=null,g=null,m=null,E=null,w=null,S=null,_=!1,T=null,B=null,N=null,G=null,D=null,j.set(0,0,i.canvas.width,i.canvas.height),Y.set(0,0,i.canvas.width,i.canvas.height),o.reset(),l.reset(),c.reset()}return{buffers:{color:o,depth:l,stencil:c},enable:st,disable:ct,bindFramebuffer:Et,bindXRFramebuffer:z,useProgram:At,setBlending:Ct,setMaterial:Mt,setFlipSided:St,setCullFace:rt,setLineWidth:dt,setPolygonOffset:mt,setScissorTest:bt,activeTexture:ft,bindTexture:b,unbindTexture:M,compressedTexImage2D:X,texImage2D:$,texImage3D:tt,scissor:nt,viewport:Lt,reset:xt}}function KT(i,t,e,n,r,s,a){const o=r.isWebGL2,l=r.maxTextures,c=r.maxCubemapSize,h=r.maxTextureSize,u=r.maxSamples,d=new WeakMap;let f,p=!1;try{p=typeof OffscreenCanvas!="undefined"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch(b){}function x(b,M){return p?new OffscreenCanvas(b,M):document.createElementNS("http://www.w3.org/1999/xhtml","canvas")}function y(b,M,X,$){let tt=1;if((b.width>$||b.height>$)&&(tt=$/Math.max(b.width,b.height)),tt<1||M===!0)if(typeof HTMLImageElement!="undefined"&&b instanceof HTMLImageElement||typeof HTMLCanvasElement!="undefined"&&b instanceof HTMLCanvasElement||typeof ImageBitmap!="undefined"&&b instanceof ImageBitmap){const nt=M?Zt.floorPowerOfTwo:Math.floor,Lt=nt(tt*b.width),xt=nt(tt*b.height);f===void 0&&(f=x(Lt,xt));const A=X?x(Lt,xt):f;return A.width=Lt,A.height=xt,A.getContext("2d").drawImage(b,0,0,Lt,xt),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+b.width+"x"+b.height+") to ("+Lt+"x"+xt+")."),A}else return"data"in b&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+b.width+"x"+b.height+")."),b;return b}function g(b){return Zt.isPowerOfTwo(b.width)&&Zt.isPowerOfTwo(b.height)}function m(b){return o?!1:b.wrapS!==mi||b.wrapT!==mi||b.minFilter!==je&&b.minFilter!==Fi}function E(b,M){return b.generateMipmaps&&M&&b.minFilter!==je&&b.minFilter!==Fi}function w(b,M,X,$){i.generateMipmap(b);const tt=n.get(M);tt.__maxMipLevel=Math.log2(Math.max(X,$))}function S(b,M,X){if(o===!1)return M;if(b!==null){if(i[b]!==void 0)return i[b];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+b+"'")}let $=M;return M===i.RED&&(X===i.FLOAT&&($=i.R32F),X===i.HALF_FLOAT&&($=i.R16F),X===i.UNSIGNED_BYTE&&($=i.R8)),M===i.RGB&&(X===i.FLOAT&&($=i.RGB32F),X===i.HALF_FLOAT&&($=i.RGB16F),X===i.UNSIGNED_BYTE&&($=i.RGB8)),M===i.RGBA&&(X===i.FLOAT&&($=i.RGBA32F),X===i.HALF_FLOAT&&($=i.RGBA16F),X===i.UNSIGNED_BYTE&&($=i.RGBA8)),($===i.R16F||$===i.R32F||$===i.RGBA16F||$===i.RGBA32F)&&t.get("EXT_color_buffer_float"),$}function _(b){return b===je||b===bp||b===wp?i.NEAREST:i.LINEAR}function T(b){const M=b.target;M.removeEventListener("dispose",T),N(M),M.isVideoTexture&&d.delete(M),a.memory.textures--}function B(b){const M=b.target;M.removeEventListener("dispose",B),G(M),a.memory.textures--}function N(b){const M=n.get(b);M.__webglInit!==void 0&&(i.deleteTexture(M.__webglTexture),n.remove(b))}function G(b){const M=b.texture,X=n.get(b),$=n.get(M);if(!!b){if($.__webglTexture!==void 0&&i.deleteTexture($.__webglTexture),b.depthTexture&&b.depthTexture.dispose(),b.isWebGLCubeRenderTarget)for(let tt=0;tt<6;tt++)i.deleteFramebuffer(X.__webglFramebuffer[tt]),X.__webglDepthbuffer&&i.deleteRenderbuffer(X.__webglDepthbuffer[tt]);else i.deleteFramebuffer(X.__webglFramebuffer),X.__webglDepthbuffer&&i.deleteRenderbuffer(X.__webglDepthbuffer),X.__webglMultisampledFramebuffer&&i.deleteFramebuffer(X.__webglMultisampledFramebuffer),X.__webglColorRenderbuffer&&i.deleteRenderbuffer(X.__webglColorRenderbuffer),X.__webglDepthRenderbuffer&&i.deleteRenderbuffer(X.__webglDepthRenderbuffer);n.remove(M),n.remove(b)}}let D=0;function V(){D=0}function R(){const b=D;return b>=l&&console.warn("THREE.WebGLTextures: Trying to use "+b+" texture units while this GPU supports only "+l),D+=1,b}function L(b,M){const X=n.get(b);if(b.isVideoTexture&&rt(b),b.version>0&&X.__version!==b.version){const $=b.image;if($===void 0)console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");else if($.complete===!1)console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");else{st(X,b,M);return}}e.activeTexture(i.TEXTURE0+M),e.bindTexture(i.TEXTURE_2D,X.__webglTexture)}function P(b,M){const X=n.get(b);if(b.version>0&&X.__version!==b.version){st(X,b,M);return}e.activeTexture(i.TEXTURE0+M),e.bindTexture(i.TEXTURE_2D_ARRAY,X.__webglTexture)}function F(b,M){const X=n.get(b);if(b.version>0&&X.__version!==b.version){st(X,b,M);return}e.activeTexture(i.TEXTURE0+M),e.bindTexture(i.TEXTURE_3D,X.__webglTexture)}function W(b,M){const X=n.get(b);if(b.version>0&&X.__version!==b.version){ct(X,b,M);return}e.activeTexture(i.TEXTURE0+M),e.bindTexture(i.TEXTURE_CUBE_MAP,X.__webglTexture)}const j={[fh]:i.REPEAT,[mi]:i.CLAMP_TO_EDGE,[ph]:i.MIRRORED_REPEAT},Y={[je]:i.NEAREST,[bp]:i.NEAREST_MIPMAP_NEAREST,[wp]:i.NEAREST_MIPMAP_LINEAR,[Fi]:i.LINEAR,[Aw]:i.LINEAR_MIPMAP_NEAREST,[mh]:i.LINEAR_MIPMAP_LINEAR};function Q(b,M,X){if(X?(i.texParameteri(b,i.TEXTURE_WRAP_S,j[M.wrapS]),i.texParameteri(b,i.TEXTURE_WRAP_T,j[M.wrapT]),(b===i.TEXTURE_3D||b===i.TEXTURE_2D_ARRAY)&&i.texParameteri(b,i.TEXTURE_WRAP_R,j[M.wrapR]),i.texParameteri(b,i.TEXTURE_MAG_FILTER,Y[M.magFilter]),i.texParameteri(b,i.TEXTURE_MIN_FILTER,Y[M.minFilter])):(i.texParameteri(b,i.TEXTURE_WRAP_S,i.CLAMP_TO_EDGE),i.texParameteri(b,i.TEXTURE_WRAP_T,i.CLAMP_TO_EDGE),(b===i.TEXTURE_3D||b===i.TEXTURE_2D_ARRAY)&&i.texParameteri(b,i.TEXTURE_WRAP_R,i.CLAMP_TO_EDGE),(M.wrapS!==mi||M.wrapT!==mi)&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),i.texParameteri(b,i.TEXTURE_MAG_FILTER,_(M.magFilter)),i.texParameteri(b,i.TEXTURE_MIN_FILTER,_(M.minFilter)),M.minFilter!==je&&M.minFilter!==Fi&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),t.has("EXT_texture_filter_anisotropic")===!0){const $=t.get("EXT_texture_filter_anisotropic");if(M.type===wn&&t.has("OES_texture_float_linear")===!1||o===!1&&M.type===Uo&&t.has("OES_texture_half_float_linear")===!1)return;(M.anisotropy>1||n.get(M).__currentAnisotropy)&&(i.texParameterf(b,$.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(M.anisotropy,r.getMaxAnisotropy())),n.get(M).__currentAnisotropy=M.anisotropy)}}function K(b,M){b.__webglInit===void 0&&(b.__webglInit=!0,M.addEventListener("dispose",T),b.__webglTexture=i.createTexture(),a.memory.textures++)}function st(b,M,X){let $=i.TEXTURE_2D;M.isDataTexture2DArray&&($=i.TEXTURE_2D_ARRAY),M.isDataTexture3D&&($=i.TEXTURE_3D),K(b,M),e.activeTexture(i.TEXTURE0+X),e.bindTexture($,b.__webglTexture),i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL,M.flipY),i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL,M.premultiplyAlpha),i.pixelStorei(i.UNPACK_ALIGNMENT,M.unpackAlignment),i.pixelStorei(i.UNPACK_COLORSPACE_CONVERSION_WEBGL,i.NONE);const tt=m(M)&&g(M.image)===!1,nt=y(M.image,tt,!1,h),Lt=g(nt)||o,xt=s.convert(M.format);let A=s.convert(M.type),C=S(M.internalFormat,xt,A);Q($,M,Lt);let q;const et=M.mipmaps;if(M.isDepthTexture)C=i.DEPTH_COMPONENT,o?M.type===wn?C=i.DEPTH_COMPONENT32F:M.type===Oo?C=i.DEPTH_COMPONENT24:M.type===Ho?C=i.DEPTH24_STENCIL8:C=i.DEPTH_COMPONENT16:M.type===wn&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),M.format===yh&&C===i.DEPTH_COMPONENT&&M.type!==xh&&M.type!==Oo&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),M.type=xh,A=s.convert(M.type)),M.format===_h&&C===i.DEPTH_COMPONENT&&(C=i.DEPTH_STENCIL,M.type!==Ho&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),M.type=Ho,A=s.convert(M.type))),e.texImage2D(i.TEXTURE_2D,0,C,nt.width,nt.height,0,xt,A,null);else if(M.isDataTexture)if(et.length>0&&Lt){for(let k=0,at=et.length;k<at;k++)q=et[k],e.texImage2D(i.TEXTURE_2D,k,C,q.width,q.height,0,xt,A,q.data);M.generateMipmaps=!1,b.__maxMipLevel=et.length-1}else e.texImage2D(i.TEXTURE_2D,0,C,nt.width,nt.height,0,xt,A,nt.data),b.__maxMipLevel=0;else if(M.isCompressedTexture){for(let k=0,at=et.length;k<at;k++)q=et[k],M.format!==Ii&&M.format!==pa?xt!==null?e.compressedTexImage2D(i.TEXTURE_2D,k,C,q.width,q.height,0,q.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):e.texImage2D(i.TEXTURE_2D,k,C,q.width,q.height,0,xt,A,q.data);b.__maxMipLevel=et.length-1}else if(M.isDataTexture2DArray)e.texImage3D(i.TEXTURE_2D_ARRAY,0,C,nt.width,nt.height,nt.depth,0,xt,A,nt.data),b.__maxMipLevel=0;else if(M.isDataTexture3D)e.texImage3D(i.TEXTURE_3D,0,C,nt.width,nt.height,nt.depth,0,xt,A,nt.data),b.__maxMipLevel=0;else if(et.length>0&&Lt){for(let k=0,at=et.length;k<at;k++)q=et[k],e.texImage2D(i.TEXTURE_2D,k,C,xt,A,q);M.generateMipmaps=!1,b.__maxMipLevel=et.length-1}else e.texImage2D(i.TEXTURE_2D,0,C,xt,A,nt),b.__maxMipLevel=0;E(M,Lt)&&w($,M,nt.width,nt.height),b.__version=M.version,M.onUpdate&&M.onUpdate(M)}function ct(b,M,X){if(M.image.length!==6)return;K(b,M),e.activeTexture(i.TEXTURE0+X),e.bindTexture(i.TEXTURE_CUBE_MAP,b.__webglTexture),i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL,M.flipY),i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL,M.premultiplyAlpha),i.pixelStorei(i.UNPACK_ALIGNMENT,M.unpackAlignment),i.pixelStorei(i.UNPACK_COLORSPACE_CONVERSION_WEBGL,i.NONE);const $=M&&(M.isCompressedTexture||M.image[0].isCompressedTexture),tt=M.image[0]&&M.image[0].isDataTexture,nt=[];for(let k=0;k<6;k++)!$&&!tt?nt[k]=y(M.image[k],!1,!0,c):nt[k]=tt?M.image[k].image:M.image[k];const Lt=nt[0],xt=g(Lt)||o,A=s.convert(M.format),C=s.convert(M.type),q=S(M.internalFormat,A,C);Q(i.TEXTURE_CUBE_MAP,M,xt);let et;if($){for(let k=0;k<6;k++){et=nt[k].mipmaps;for(let at=0;at<et.length;at++){const Rt=et[at];M.format!==Ii&&M.format!==pa?A!==null?e.compressedTexImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X+k,at,q,Rt.width,Rt.height,0,Rt.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):e.texImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X+k,at,q,Rt.width,Rt.height,0,A,C,Rt.data)}}b.__maxMipLevel=et.length-1}else{et=M.mipmaps;for(let k=0;k<6;k++)if(tt){e.texImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X+k,0,q,nt[k].width,nt[k].height,0,A,C,nt[k].data);for(let at=0;at<et.length;at++){const Nt=et[at].image[k].image;e.texImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X+k,at+1,q,Nt.width,Nt.height,0,A,C,Nt.data)}}else{e.texImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X+k,0,q,A,C,nt[k]);for(let at=0;at<et.length;at++){const Rt=et[at];e.texImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X+k,at+1,q,A,C,Rt.image[k])}}b.__maxMipLevel=et.length}E(M,xt)&&w(i.TEXTURE_CUBE_MAP,M,Lt.width,Lt.height),b.__version=M.version,M.onUpdate&&M.onUpdate(M)}function z(b,M,X,$){const tt=M.texture,nt=s.convert(tt.format),Lt=s.convert(tt.type),xt=S(tt.internalFormat,nt,Lt);$===i.TEXTURE_3D||$===i.TEXTURE_2D_ARRAY?e.texImage3D($,0,xt,M.width,M.height,M.depth,0,nt,Lt,null):e.texImage2D($,0,xt,M.width,M.height,0,nt,Lt,null),e.bindFramebuffer(i.FRAMEBUFFER,b),i.framebufferTexture2D(i.FRAMEBUFFER,X,$,n.get(tt).__webglTexture,0),e.bindFramebuffer(i.FRAMEBUFFER,null)}function Et(b,M,X){if(i.bindRenderbuffer(i.RENDERBUFFER,b),M.depthBuffer&&!M.stencilBuffer){let $=i.DEPTH_COMPONENT16;if(X){const tt=M.depthTexture;tt&&tt.isDepthTexture&&(tt.type===wn?$=i.DEPTH_COMPONENT32F:tt.type===Oo&&($=i.DEPTH_COMPONENT24));const nt=St(M);i.renderbufferStorageMultisample(i.RENDERBUFFER,nt,$,M.width,M.height)}else i.renderbufferStorage(i.RENDERBUFFER,$,M.width,M.height);i.framebufferRenderbuffer(i.FRAMEBUFFER,i.DEPTH_ATTACHMENT,i.RENDERBUFFER,b)}else if(M.depthBuffer&&M.stencilBuffer){if(X){const $=St(M);i.renderbufferStorageMultisample(i.RENDERBUFFER,$,i.DEPTH24_STENCIL8,M.width,M.height)}else i.renderbufferStorage(i.RENDERBUFFER,i.DEPTH_STENCIL,M.width,M.height);i.framebufferRenderbuffer(i.FRAMEBUFFER,i.DEPTH_STENCIL_ATTACHMENT,i.RENDERBUFFER,b)}else{const $=M.texture,tt=s.convert($.format),nt=s.convert($.type),Lt=S($.internalFormat,tt,nt);if(X){const xt=St(M);i.renderbufferStorageMultisample(i.RENDERBUFFER,xt,Lt,M.width,M.height)}else i.renderbufferStorage(i.RENDERBUFFER,Lt,M.width,M.height)}i.bindRenderbuffer(i.RENDERBUFFER,null)}function At(b,M){if(M&&M.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(e.bindFramebuffer(i.FRAMEBUFFER,b),!(M.depthTexture&&M.depthTexture.isDepthTexture))throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");(!n.get(M.depthTexture).__webglTexture||M.depthTexture.image.width!==M.width||M.depthTexture.image.height!==M.height)&&(M.depthTexture.image.width=M.width,M.depthTexture.image.height=M.height,M.depthTexture.needsUpdate=!0),L(M.depthTexture,0);const $=n.get(M.depthTexture).__webglTexture;if(M.depthTexture.format===yh)i.framebufferTexture2D(i.FRAMEBUFFER,i.DEPTH_ATTACHMENT,i.TEXTURE_2D,$,0);else if(M.depthTexture.format===_h)i.framebufferTexture2D(i.FRAMEBUFFER,i.DEPTH_STENCIL_ATTACHMENT,i.TEXTURE_2D,$,0);else throw new Error("Unknown depthTexture format")}function yt(b){const M=n.get(b),X=b.isWebGLCubeRenderTarget===!0;if(b.depthTexture){if(X)throw new Error("target.depthTexture not supported in Cube render targets");At(M.__webglFramebuffer,b)}else if(X){M.__webglDepthbuffer=[];for(let $=0;$<6;$++)e.bindFramebuffer(i.FRAMEBUFFER,M.__webglFramebuffer[$]),M.__webglDepthbuffer[$]=i.createRenderbuffer(),Et(M.__webglDepthbuffer[$],b,!1)}else e.bindFramebuffer(i.FRAMEBUFFER,M.__webglFramebuffer),M.__webglDepthbuffer=i.createRenderbuffer(),Et(M.__webglDepthbuffer,b,!1);e.bindFramebuffer(i.FRAMEBUFFER,null)}function ot(b){const M=b.texture,X=n.get(b),$=n.get(M);b.addEventListener("dispose",B),$.__webglTexture=i.createTexture(),$.__version=M.version,a.memory.textures++;const tt=b.isWebGLCubeRenderTarget===!0,nt=b.isWebGLMultisampleRenderTarget===!0,Lt=M.isDataTexture3D||M.isDataTexture2DArray,xt=g(b)||o;if(o&&M.format===pa&&(M.type===wn||M.type===Uo)&&(M.format=Ii,console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")),tt){X.__webglFramebuffer=[];for(let A=0;A<6;A++)X.__webglFramebuffer[A]=i.createFramebuffer()}else if(X.__webglFramebuffer=i.createFramebuffer(),nt)if(o){X.__webglMultisampledFramebuffer=i.createFramebuffer(),X.__webglColorRenderbuffer=i.createRenderbuffer(),i.bindRenderbuffer(i.RENDERBUFFER,X.__webglColorRenderbuffer);const A=s.convert(M.format),C=s.convert(M.type),q=S(M.internalFormat,A,C),et=St(b);i.renderbufferStorageMultisample(i.RENDERBUFFER,et,q,b.width,b.height),e.bindFramebuffer(i.FRAMEBUFFER,X.__webglMultisampledFramebuffer),i.framebufferRenderbuffer(i.FRAMEBUFFER,i.COLOR_ATTACHMENT0,i.RENDERBUFFER,X.__webglColorRenderbuffer),i.bindRenderbuffer(i.RENDERBUFFER,null),b.depthBuffer&&(X.__webglDepthRenderbuffer=i.createRenderbuffer(),Et(X.__webglDepthRenderbuffer,b,!0)),e.bindFramebuffer(i.FRAMEBUFFER,null)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");if(tt){e.bindTexture(i.TEXTURE_CUBE_MAP,$.__webglTexture),Q(i.TEXTURE_CUBE_MAP,M,xt);for(let A=0;A<6;A++)z(X.__webglFramebuffer[A],b,i.COLOR_ATTACHMENT0,i.TEXTURE_CUBE_MAP_POSITIVE_X+A);E(M,xt)&&w(i.TEXTURE_CUBE_MAP,M,b.width,b.height),e.bindTexture(i.TEXTURE_CUBE_MAP,null)}else{let A=i.TEXTURE_2D;Lt&&(o?A=M.isDataTexture3D?i.TEXTURE_3D:i.TEXTURE_2D_ARRAY:console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.")),e.bindTexture(A,$.__webglTexture),Q(A,M,xt),z(X.__webglFramebuffer,b,i.COLOR_ATTACHMENT0,A),E(M,xt)&&w(i.TEXTURE_2D,M,b.width,b.height),e.bindTexture(i.TEXTURE_2D,null)}b.depthBuffer&&yt(b)}function Ct(b){const M=b.texture,X=g(b)||o;if(E(M,X)){const $=b.isWebGLCubeRenderTarget?i.TEXTURE_CUBE_MAP:i.TEXTURE_2D,tt=n.get(M).__webglTexture;e.bindTexture($,tt),w($,M,b.width,b.height),e.bindTexture($,null)}}function Mt(b){if(b.isWebGLMultisampleRenderTarget)if(o){const M=n.get(b);e.bindFramebuffer(i.READ_FRAMEBUFFER,M.__webglMultisampledFramebuffer),e.bindFramebuffer(i.DRAW_FRAMEBUFFER,M.__webglFramebuffer);const X=b.width,$=b.height;let tt=i.COLOR_BUFFER_BIT;b.depthBuffer&&(tt|=i.DEPTH_BUFFER_BIT),b.stencilBuffer&&(tt|=i.STENCIL_BUFFER_BIT),i.blitFramebuffer(0,0,X,$,0,0,X,$,tt,i.NEAREST),e.bindFramebuffer(i.FRAMEBUFFER,M.__webglMultisampledFramebuffer)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")}function St(b){return o&&b.isWebGLMultisampleRenderTarget?Math.min(u,b.samples):0}function rt(b){const M=a.render.frame;d.get(b)!==M&&(d.set(b,M),b.update())}let dt=!1,mt=!1;function bt(b,M){b&&b.isWebGLRenderTarget&&(dt===!1&&(console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."),dt=!0),b=b.texture),L(b,M)}function ft(b,M){b&&b.isWebGLCubeRenderTarget&&(mt===!1&&(console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."),mt=!0),b=b.texture),W(b,M)}this.allocateTextureUnit=R,this.resetTextureUnits=V,this.setTexture2D=L,this.setTexture2DArray=P,this.setTexture3D=F,this.setTextureCube=W,this.setupRenderTarget=ot,this.updateRenderTargetMipmap=Ct,this.updateMultisampleRenderTarget=Mt,this.safeSetTexture2D=bt,this.safeSetTextureCube=ft}function t2(i,t,e){const n=e.isWebGL2;function r(s){let a;if(s===gh)return i.UNSIGNED_BYTE;if(s===Cw)return i.UNSIGNED_SHORT_4_4_4_4;if(s===Pw)return i.UNSIGNED_SHORT_5_5_5_1;if(s===Dw)return i.UNSIGNED_SHORT_5_6_5;if(s===Tw)return i.BYTE;if(s===Lw)return i.SHORT;if(s===xh)return i.UNSIGNED_SHORT;if(s===Rw)return i.INT;if(s===Oo)return i.UNSIGNED_INT;if(s===wn)return i.FLOAT;if(s===Uo)return n?i.HALF_FLOAT:(a=t.get("OES_texture_half_float"),a!==null?a.HALF_FLOAT_OES:null);if(s===Fw)return i.ALPHA;if(s===pa)return i.RGB;if(s===Ii)return i.RGBA;if(s===Iw)return i.LUMINANCE;if(s===zw)return i.LUMINANCE_ALPHA;if(s===yh)return i.DEPTH_COMPONENT;if(s===_h)return i.DEPTH_STENCIL;if(s===Nw)return i.RED;if(s===Bw)return i.RED_INTEGER;if(s===Ow)return i.RG;if(s===Uw)return i.RG_INTEGER;if(s===Hw)return i.RGB_INTEGER;if(s===Gw)return i.RGBA_INTEGER;if(s===Sp||s===Ep||s===Ap||s===Tp)if(a=t.get("WEBGL_compressed_texture_s3tc"),a!==null){if(s===Sp)return a.COMPRESSED_RGB_S3TC_DXT1_EXT;if(s===Ep)return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(s===Ap)return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(s===Tp)return a.COMPRESSED_RGBA_S3TC_DXT5_EXT}else return null;if(s===Lp||s===Rp||s===Cp||s===Pp)if(a=t.get("WEBGL_compressed_texture_pvrtc"),a!==null){if(s===Lp)return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(s===Rp)return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(s===Cp)return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(s===Pp)return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}else return null;if(s===kw)return a=t.get("WEBGL_compressed_texture_etc1"),a!==null?a.COMPRESSED_RGB_ETC1_WEBGL:null;if((s===Dp||s===Fp)&&(a=t.get("WEBGL_compressed_texture_etc"),a!==null)){if(s===Dp)return a.COMPRESSED_RGB8_ETC2;if(s===Fp)return a.COMPRESSED_RGBA8_ETC2_EAC}if(s===Vw||s===Ww||s===$w||s===Xw||s===qw||s===Yw||s===jw||s===Zw||s===Jw||s===Qw||s===Kw||s===tS||s===eS||s===iS||s===rS||s===sS||s===aS||s===oS||s===lS||s===cS||s===hS||s===uS||s===dS||s===fS||s===pS||s===mS||s===gS||s===xS)return a=t.get("WEBGL_compressed_texture_astc"),a!==null?s:null;if(s===nS)return a=t.get("EXT_texture_compression_bptc"),a!==null?s:null;if(s===Ho)return n?i.UNSIGNED_INT_24_8:(a=t.get("WEBGL_depth_texture"),a!==null?a.UNSIGNED_INT_24_8_WEBGL:null)}return{convert:r}}class Am extends Qe{constructor(t=[]){super();this.cameras=t}}Am.prototype.isArrayCamera=!0;class Ea extends he{constructor(){super();this.type="Group"}}Ea.prototype.isGroup=!0;function Aa(){this._targetRay=null,this._grip=null,this._hand=null}Object.assign(Aa.prototype,{constructor:Aa,getHandSpace:function(){return this._hand===null&&(this._hand=new Ea,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand},getTargetRaySpace:function(){return this._targetRay===null&&(this._targetRay=new Ea,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1),this._targetRay},getGripSpace:function(){return this._grip===null&&(this._grip=new Ea,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1),this._grip},dispatchEvent:function(i){return this._targetRay!==null&&this._targetRay.dispatchEvent(i),this._grip!==null&&this._grip.dispatchEvent(i),this._hand!==null&&this._hand.dispatchEvent(i),this},disconnect:function(i){return this.dispatchEvent({type:"disconnected",data:i}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this},update:function(i,t,e){let n=null,r=null,s=null;const a=this._targetRay,o=this._grip,l=this._hand;if(i&&t.session.visibilityState!=="visible-blurred")if(a!==null&&(n=t.getPose(i.targetRaySpace,e),n!==null&&(a.matrix.fromArray(n.transform.matrix),a.matrix.decompose(a.position,a.rotation,a.scale))),l&&i.hand){s=!0;for(const p of i.hand.values()){const x=t.getJointPose(p,e);if(l.joints[p.jointName]===void 0){const g=new Ea;g.matrixAutoUpdate=!1,g.visible=!1,l.joints[p.jointName]=g,l.add(g)}const y=l.joints[p.jointName];x!==null&&(y.matrix.fromArray(x.transform.matrix),y.matrix.decompose(y.position,y.rotation,y.scale),y.jointRadius=x.radius),y.visible=x!==null}const c=l.joints["index-finger-tip"],h=l.joints["thumb-tip"],u=c.position.distanceTo(h.position),d=.02,f=.005;l.inputState.pinching&&u>d+f?(l.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:i.handedness,target:this})):!l.inputState.pinching&&u<=d-f&&(l.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:i.handedness,target:this}))}else o!==null&&i.gripSpace&&(r=t.getPose(i.gripSpace,e),r!==null&&(o.matrix.fromArray(r.transform.matrix),o.matrix.decompose(o.position,o.rotation,o.scale)));return a!==null&&(a.visible=n!==null),o!==null&&(o.visible=r!==null),l!==null&&(l.visible=s!==null),this}});function Tm(i,t){const e=this,n=i.state;let r=null,s=1,a=null,o="local-floor",l=null;const c=[],h=new Map,u=new Qe;u.layers.enable(1),u.viewport=new Ie;const d=new Qe;d.layers.enable(2),d.viewport=new Ie;const f=[u,d],p=new Am;p.layers.enable(1),p.layers.enable(2);let x=null,y=null;this.enabled=!1,this.isPresenting=!1,this.getController=function(D){let V=c[D];return V===void 0&&(V=new Aa,c[D]=V),V.getTargetRaySpace()},this.getControllerGrip=function(D){let V=c[D];return V===void 0&&(V=new Aa,c[D]=V),V.getGripSpace()},this.getHand=function(D){let V=c[D];return V===void 0&&(V=new Aa,c[D]=V),V.getHandSpace()};function g(D){const V=h.get(D.inputSource);V&&V.dispatchEvent({type:D.type,data:D.inputSource})}function m(){h.forEach(function(D,V){D.disconnect(V)}),h.clear(),x=null,y=null,n.bindXRFramebuffer(null),i.setRenderTarget(i.getRenderTarget()),G.stop(),e.isPresenting=!1,e.dispatchEvent({type:"sessionend"})}this.setFramebufferScaleFactor=function(D){s=D,e.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(D){o=D,e.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return a},this.getSession=function(){return r},this.setSession=async function(D){if(r=D,r!==null){r.addEventListener("select",g),r.addEventListener("selectstart",g),r.addEventListener("selectend",g),r.addEventListener("squeeze",g),r.addEventListener("squeezestart",g),r.addEventListener("squeezeend",g),r.addEventListener("end",m),r.addEventListener("inputsourceschange",E);const V=t.getContextAttributes();V.xrCompatible!==!0&&await t.makeXRCompatible();const R={antialias:V.antialias,alpha:V.alpha,depth:V.depth,stencil:V.stencil,framebufferScaleFactor:s},L=new XRWebGLLayer(r,t,R);r.updateRenderState({baseLayer:L}),a=await r.requestReferenceSpace(o),G.setContext(r),G.start(),e.isPresenting=!0,e.dispatchEvent({type:"sessionstart"})}};function E(D){const V=r.inputSources;for(let R=0;R<c.length;R++)h.set(V[R],c[R]);for(let R=0;R<D.removed.length;R++){const L=D.removed[R],P=h.get(L);P&&(P.dispatchEvent({type:"disconnected",data:L}),h.delete(L))}for(let R=0;R<D.added.length;R++){const L=D.added[R],P=h.get(L);P&&P.dispatchEvent({type:"connected",data:L})}}const w=new Z,S=new Z;function _(D,V,R){w.setFromMatrixPosition(V.matrixWorld),S.setFromMatrixPosition(R.matrixWorld);const L=w.distanceTo(S),P=V.projectionMatrix.elements,F=R.projectionMatrix.elements,W=P[14]/(P[10]-1),j=P[14]/(P[10]+1),Y=(P[9]+1)/P[5],Q=(P[9]-1)/P[5],K=(P[8]-1)/P[0],st=(F[8]+1)/F[0],ct=W*K,z=W*st,Et=L/(-K+st),At=Et*-K;V.matrixWorld.decompose(D.position,D.quaternion,D.scale),D.translateX(At),D.translateZ(Et),D.matrixWorld.compose(D.position,D.quaternion,D.scale),D.matrixWorldInverse.copy(D.matrixWorld).invert();const yt=W+Et,ot=j+Et,Ct=ct-At,Mt=z+(L-At),St=Y*j/ot*yt,rt=Q*j/ot*yt;D.projectionMatrix.makePerspective(Ct,Mt,St,rt,yt,ot)}function T(D,V){V===null?D.matrixWorld.copy(D.matrix):D.matrixWorld.multiplyMatrices(V.matrixWorld,D.matrix),D.matrixWorldInverse.copy(D.matrixWorld).invert()}this.getCamera=function(D){p.near=d.near=u.near=D.near,p.far=d.far=u.far=D.far,(x!==p.near||y!==p.far)&&(r.updateRenderState({depthNear:p.near,depthFar:p.far}),x=p.near,y=p.far);const V=D.parent,R=p.cameras;T(p,V);for(let P=0;P<R.length;P++)T(R[P],V);D.matrixWorld.copy(p.matrixWorld),D.matrix.copy(p.matrix),D.matrix.decompose(D.position,D.quaternion,D.scale);const L=D.children;for(let P=0,F=L.length;P<F;P++)L[P].updateMatrixWorld(!0);return R.length===2?_(p,u,d):p.projectionMatrix.copy(u.projectionMatrix),p};let B=null;function N(D,V){if(l=V.getViewerPose(a),l!==null){const L=l.views,P=r.renderState.baseLayer;n.bindXRFramebuffer(P.framebuffer);let F=!1;L.length!==p.cameras.length&&(p.cameras.length=0,F=!0);for(let W=0;W<L.length;W++){const j=L[W],Y=P.getViewport(j),Q=f[W];Q.matrix.fromArray(j.transform.matrix),Q.projectionMatrix.fromArray(j.projectionMatrix),Q.viewport.set(Y.x,Y.y,Y.width,Y.height),W===0&&p.matrix.copy(Q.matrix),F===!0&&p.cameras.push(Q)}}const R=r.inputSources;for(let L=0;L<c.length;L++){const P=c[L],F=R[L];P.update(F,V,a)}B&&B(D,V)}const G=new Gp;G.setAnimationLoop(N),this.setAnimationLoop=function(D){B=D},this.dispose=function(){}}Object.assign(Tm.prototype,Zn.prototype);function e2(i){function t(g,m){g.fogColor.value.copy(m.color),m.isFog?(g.fogNear.value=m.near,g.fogFar.value=m.far):m.isFogExp2&&(g.fogDensity.value=m.density)}function e(g,m,E,w){m.isMeshBasicMaterial?n(g,m):m.isMeshLambertMaterial?(n(g,m),l(g,m)):m.isMeshToonMaterial?(n(g,m),h(g,m)):m.isMeshPhongMaterial?(n(g,m),c(g,m)):m.isMeshStandardMaterial?(n(g,m),m.isMeshPhysicalMaterial?d(g,m):u(g,m)):m.isMeshMatcapMaterial?(n(g,m),f(g,m)):m.isMeshDepthMaterial?(n(g,m),p(g,m)):m.isMeshDistanceMaterial?(n(g,m),x(g,m)):m.isMeshNormalMaterial?(n(g,m),y(g,m)):m.isLineBasicMaterial?(r(g,m),m.isLineDashedMaterial&&s(g,m)):m.isPointsMaterial?a(g,m,E,w):m.isSpriteMaterial?o(g,m):m.isShadowMaterial?(g.color.value.copy(m.color),g.opacity.value=m.opacity):m.isShaderMaterial&&(m.uniformsNeedUpdate=!1)}function n(g,m){g.opacity.value=m.opacity,m.color&&g.diffuse.value.copy(m.color),m.emissive&&g.emissive.value.copy(m.emissive).multiplyScalar(m.emissiveIntensity),m.map&&(g.map.value=m.map),m.alphaMap&&(g.alphaMap.value=m.alphaMap),m.specularMap&&(g.specularMap.value=m.specularMap);const E=i.get(m).envMap;if(E){g.envMap.value=E,g.flipEnvMap.value=E.isCubeTexture&&E._needsFlipEnvMap?-1:1,g.reflectivity.value=m.reflectivity,g.refractionRatio.value=m.refractionRatio;const _=i.get(E).__maxMipLevel;_!==void 0&&(g.maxMipLevel.value=_)}m.lightMap&&(g.lightMap.value=m.lightMap,g.lightMapIntensity.value=m.lightMapIntensity),m.aoMap&&(g.aoMap.value=m.aoMap,g.aoMapIntensity.value=m.aoMapIntensity);let w;m.map?w=m.map:m.specularMap?w=m.specularMap:m.displacementMap?w=m.displacementMap:m.normalMap?w=m.normalMap:m.bumpMap?w=m.bumpMap:m.roughnessMap?w=m.roughnessMap:m.metalnessMap?w=m.metalnessMap:m.alphaMap?w=m.alphaMap:m.emissiveMap?w=m.emissiveMap:m.clearcoatMap?w=m.clearcoatMap:m.clearcoatNormalMap?w=m.clearcoatNormalMap:m.clearcoatRoughnessMap&&(w=m.clearcoatRoughnessMap),w!==void 0&&(w.isWebGLRenderTarget&&(w=w.texture),w.matrixAutoUpdate===!0&&w.updateMatrix(),g.uvTransform.value.copy(w.matrix));let S;m.aoMap?S=m.aoMap:m.lightMap&&(S=m.lightMap),S!==void 0&&(S.isWebGLRenderTarget&&(S=S.texture),S.matrixAutoUpdate===!0&&S.updateMatrix(),g.uv2Transform.value.copy(S.matrix))}function r(g,m){g.diffuse.value.copy(m.color),g.opacity.value=m.opacity}function s(g,m){g.dashSize.value=m.dashSize,g.totalSize.value=m.dashSize+m.gapSize,g.scale.value=m.scale}function a(g,m,E,w){g.diffuse.value.copy(m.color),g.opacity.value=m.opacity,g.size.value=m.size*E,g.scale.value=w*.5,m.map&&(g.map.value=m.map),m.alphaMap&&(g.alphaMap.value=m.alphaMap);let S;m.map?S=m.map:m.alphaMap&&(S=m.alphaMap),S!==void 0&&(S.matrixAutoUpdate===!0&&S.updateMatrix(),g.uvTransform.value.copy(S.matrix))}function o(g,m){g.diffuse.value.copy(m.color),g.opacity.value=m.opacity,g.rotation.value=m.rotation,m.map&&(g.map.value=m.map),m.alphaMap&&(g.alphaMap.value=m.alphaMap);let E;m.map?E=m.map:m.alphaMap&&(E=m.alphaMap),E!==void 0&&(E.matrixAutoUpdate===!0&&E.updateMatrix(),g.uvTransform.value.copy(E.matrix))}function l(g,m){m.emissiveMap&&(g.emissiveMap.value=m.emissiveMap)}function c(g,m){g.specular.value.copy(m.specular),g.shininess.value=Math.max(m.shininess,1e-4),m.emissiveMap&&(g.emissiveMap.value=m.emissiveMap),m.bumpMap&&(g.bumpMap.value=m.bumpMap,g.bumpScale.value=m.bumpScale,m.side===Le&&(g.bumpScale.value*=-1)),m.normalMap&&(g.normalMap.value=m.normalMap,g.normalScale.value.copy(m.normalScale),m.side===Le&&g.normalScale.value.negate()),m.displacementMap&&(g.displacementMap.value=m.displacementMap,g.displacementScale.value=m.displacementScale,g.displacementBias.value=m.displacementBias)}function h(g,m){m.gradientMap&&(g.gradientMap.value=m.gradientMap),m.emissiveMap&&(g.emissiveMap.value=m.emissiveMap),m.bumpMap&&(g.bumpMap.value=m.bumpMap,g.bumpScale.value=m.bumpScale,m.side===Le&&(g.bumpScale.value*=-1)),m.normalMap&&(g.normalMap.value=m.normalMap,g.normalScale.value.copy(m.normalScale),m.side===Le&&g.normalScale.value.negate()),m.displacementMap&&(g.displacementMap.value=m.displacementMap,g.displacementScale.value=m.displacementScale,g.displacementBias.value=m.displacementBias)}function u(g,m){g.roughness.value=m.roughness,g.metalness.value=m.metalness,m.roughnessMap&&(g.roughnessMap.value=m.roughnessMap),m.metalnessMap&&(g.metalnessMap.value=m.metalnessMap),m.emissiveMap&&(g.emissiveMap.value=m.emissiveMap),m.bumpMap&&(g.bumpMap.value=m.bumpMap,g.bumpScale.value=m.bumpScale,m.side===Le&&(g.bumpScale.value*=-1)),m.normalMap&&(g.normalMap.value=m.normalMap,g.normalScale.value.copy(m.normalScale),m.side===Le&&g.normalScale.value.negate()),m.displacementMap&&(g.displacementMap.value=m.displacementMap,g.displacementScale.value=m.displacementScale,g.displacementBias.value=m.displacementBias),i.get(m).envMap&&(g.envMapIntensity.value=m.envMapIntensity)}function d(g,m){u(g,m),g.reflectivity.value=m.reflectivity,g.clearcoat.value=m.clearcoat,g.clearcoatRoughness.value=m.clearcoatRoughness,m.sheen&&g.sheen.value.copy(m.sheen),m.clearcoatMap&&(g.clearcoatMap.value=m.clearcoatMap),m.clearcoatRoughnessMap&&(g.clearcoatRoughnessMap.value=m.clearcoatRoughnessMap),m.clearcoatNormalMap&&(g.clearcoatNormalScale.value.copy(m.clearcoatNormalScale),g.clearcoatNormalMap.value=m.clearcoatNormalMap,m.side===Le&&g.clearcoatNormalScale.value.negate()),g.transmission.value=m.transmission,m.transmissionMap&&(g.transmissionMap.value=m.transmissionMap)}function f(g,m){m.matcap&&(g.matcap.value=m.matcap),m.bumpMap&&(g.bumpMap.value=m.bumpMap,g.bumpScale.value=m.bumpScale,m.side===Le&&(g.bumpScale.value*=-1)),m.normalMap&&(g.normalMap.value=m.normalMap,g.normalScale.value.copy(m.normalScale),m.side===Le&&g.normalScale.value.negate()),m.displacementMap&&(g.displacementMap.value=m.displacementMap,g.displacementScale.value=m.displacementScale,g.displacementBias.value=m.displacementBias)}function p(g,m){m.displacementMap&&(g.displacementMap.value=m.displacementMap,g.displacementScale.value=m.displacementScale,g.displacementBias.value=m.displacementBias)}function x(g,m){m.displacementMap&&(g.displacementMap.value=m.displacementMap,g.displacementScale.value=m.displacementScale,g.displacementBias.value=m.displacementBias),g.referencePosition.value.copy(m.referencePosition),g.nearDistance.value=m.nearDistance,g.farDistance.value=m.farDistance}function y(g,m){m.bumpMap&&(g.bumpMap.value=m.bumpMap,g.bumpScale.value=m.bumpScale,m.side===Le&&(g.bumpScale.value*=-1)),m.normalMap&&(g.normalMap.value=m.normalMap,g.normalScale.value.copy(m.normalScale),m.side===Le&&g.normalScale.value.negate()),m.displacementMap&&(g.displacementMap.value=m.displacementMap,g.displacementScale.value=m.displacementScale,g.displacementBias.value=m.displacementBias)}return{refreshFogUniforms:t,refreshMaterialUniforms:e}}function i2(){const i=document.createElementNS("http://www.w3.org/1999/xhtml","canvas");return i.style.display="block",i}function Lm(i){i=i||{};const t=i.canvas!==void 0?i.canvas:i2(),e=i.context!==void 0?i.context:null,n=i.alpha!==void 0?i.alpha:!1,r=i.depth!==void 0?i.depth:!0,s=i.stencil!==void 0?i.stencil:!0,a=i.antialias!==void 0?i.antialias:!1,o=i.premultipliedAlpha!==void 0?i.premultipliedAlpha:!0,l=i.preserveDrawingBuffer!==void 0?i.preserveDrawingBuffer:!1,c=i.powerPreference!==void 0?i.powerPreference:"default",h=i.failIfMajorPerformanceCaveat!==void 0?i.failIfMajorPerformanceCaveat:!1;let u=null,d=null;const f=[],p=[];this.domElement=t,this.debug={checkShaderErrors:!0},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.gammaFactor=2,this.outputEncoding=Go,this.physicallyCorrectLights=!1,this.toneMapping=fa,this.toneMappingExposure=1;const x=this;let y=!1,g=0,m=0,E=null,w=-1,S=null;const _=new Ie,T=new Ie;let B=null,N=t.width,G=t.height,D=1,V=null,R=null;const L=new Ie(0,0,N,G),P=new Ie(0,0,N,G);let F=!1;const W=new Up;let j=!1,Y=!1;const Q=new Ce,K=new Z,st={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function ct(){return E===null?D:1}let z=e;function Et(v,O){for(let I=0;I<v.length;I++){const H=v[I],J=t.getContext(H,O);if(J!==null)return J}return null}try{const v={alpha:n,depth:r,stencil:s,antialias:a,premultipliedAlpha:o,preserveDrawingBuffer:l,powerPreference:c,failIfMajorPerformanceCaveat:h};if(t.addEventListener("webglcontextlost",at,!1),t.addEventListener("webglcontextrestored",Rt,!1),z===null){const O=["webgl2","webgl","experimental-webgl"];if(x.isWebGL1Renderer===!0&&O.shift(),z=Et(O,v),z===null)throw Et(O)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}z.getShaderPrecisionFormat===void 0&&(z.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(v){throw console.error("THREE.WebGLRenderer: "+v.message),v}let At,yt,ot,Ct,Mt,St,rt,dt,mt,bt,ft,b,M,X,$,tt,nt,Lt,xt,A,C,q;function et(){At=new EA(z),yt=new MA(z,At,i),At.init(yt),C=new t2(z,At,yt),ot=new QT(z,At,yt),Ct=new LA(z),Mt=new UT,St=new KT(z,At,ot,Mt,yt,C,Ct),rt=new SA(x),dt=new BS(z,yt),q=new _A(z,At,dt,yt),mt=new AA(z,dt,Ct,q),bt=new DA(z,mt,dt,Ct),Lt=new PA(z),$=new bA(Mt),ft=new OT(x,rt,At,yt,q,$),b=new e2(Mt),M=new kT(Mt),X=new YT(At,yt),nt=new yA(x,rt,ot,bt,o),tt=new JT(x,bt,yt),xt=new vA(z,At,Ct,yt),A=new TA(z,At,Ct,yt),Ct.programs=ft.programs,x.capabilities=yt,x.extensions=At,x.properties=Mt,x.renderLists=M,x.shadowMap=tt,x.state=ot,x.info=Ct}et();const k=new Tm(x,z);this.xr=k,this.getContext=function(){return z},this.getContextAttributes=function(){return z.getContextAttributes()},this.forceContextLoss=function(){const v=At.get("WEBGL_lose_context");v&&v.loseContext()},this.forceContextRestore=function(){const v=At.get("WEBGL_lose_context");v&&v.restoreContext()},this.getPixelRatio=function(){return D},this.setPixelRatio=function(v){v!==void 0&&(D=v,this.setSize(N,G,!1))},this.getSize=function(v){return v===void 0&&(console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"),v=new ee),v.set(N,G)},this.setSize=function(v,O,I){if(k.isPresenting){console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");return}N=v,G=O,t.width=Math.floor(v*D),t.height=Math.floor(O*D),I!==!1&&(t.style.width=v+"px",t.style.height=O+"px"),this.setViewport(0,0,v,O)},this.getDrawingBufferSize=function(v){return v===void 0&&(console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"),v=new ee),v.set(N*D,G*D).floor()},this.setDrawingBufferSize=function(v,O,I){N=v,G=O,D=I,t.width=Math.floor(v*I),t.height=Math.floor(O*I),this.setViewport(0,0,v,O)},this.getCurrentViewport=function(v){return v===void 0&&(console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"),v=new Ie),v.copy(_)},this.getViewport=function(v){return v.copy(L)},this.setViewport=function(v,O,I,H){v.isVector4?L.set(v.x,v.y,v.z,v.w):L.set(v,O,I,H),ot.viewport(_.copy(L).multiplyScalar(D).floor())},this.getScissor=function(v){return v.copy(P)},this.setScissor=function(v,O,I,H){v.isVector4?P.set(v.x,v.y,v.z,v.w):P.set(v,O,I,H),ot.scissor(T.copy(P).multiplyScalar(D).floor())},this.getScissorTest=function(){return F},this.setScissorTest=function(v){ot.setScissorTest(F=v)},this.setOpaqueSort=function(v){V=v},this.setTransparentSort=function(v){R=v},this.getClearColor=function(v){return v===void 0&&(console.warn("WebGLRenderer: .getClearColor() now requires a Color as an argument"),v=new Jt),v.copy(nt.getClearColor())},this.setClearColor=function(){nt.setClearColor.apply(nt,arguments)},this.getClearAlpha=function(){return nt.getClearAlpha()},this.setClearAlpha=function(){nt.setClearAlpha.apply(nt,arguments)},this.clear=function(v,O,I){let H=0;(v===void 0||v)&&(H|=z.COLOR_BUFFER_BIT),(O===void 0||O)&&(H|=z.DEPTH_BUFFER_BIT),(I===void 0||I)&&(H|=z.STENCIL_BUFFER_BIT),z.clear(H)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){t.removeEventListener("webglcontextlost",at,!1),t.removeEventListener("webglcontextrestored",Rt,!1),M.dispose(),X.dispose(),Mt.dispose(),rt.dispose(),bt.dispose(),q.dispose(),k.dispose(),k.removeEventListener("sessionstart",ws),k.removeEventListener("sessionend",Ss),Oe.stop()};function at(v){v.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),y=!0}function Rt(){console.log("THREE.WebGLRenderer: Context Restored."),y=!1;const v=Ct.autoReset,O=tt.enabled,I=tt.autoUpdate,H=tt.needsUpdate,J=tt.type;et(),Ct.autoReset=v,tt.enabled=O,tt.autoUpdate=I,tt.needsUpdate=H,tt.type=J}function Nt(v){const O=v.target;O.removeEventListener("dispose",Nt),xe(O)}function xe(v){Ft(v),Mt.remove(v)}function Ft(v){const O=Mt.get(v).programs;O!==void 0&&O.forEach(function(I){ft.releaseProgram(I)})}function Xt(v,O){v.render(function(I){x.renderBufferImmediate(I,O)})}this.renderBufferImmediate=function(v,O){q.initAttributes();const I=Mt.get(v);v.hasPositions&&!I.position&&(I.position=z.createBuffer()),v.hasNormals&&!I.normal&&(I.normal=z.createBuffer()),v.hasUvs&&!I.uv&&(I.uv=z.createBuffer()),v.hasColors&&!I.color&&(I.color=z.createBuffer());const H=O.getAttributes();v.hasPositions&&(z.bindBuffer(z.ARRAY_BUFFER,I.position),z.bufferData(z.ARRAY_BUFFER,v.positionArray,z.DYNAMIC_DRAW),q.enableAttribute(H.position),z.vertexAttribPointer(H.position,3,z.FLOAT,!1,0,0)),v.hasNormals&&(z.bindBuffer(z.ARRAY_BUFFER,I.normal),z.bufferData(z.ARRAY_BUFFER,v.normalArray,z.DYNAMIC_DRAW),q.enableAttribute(H.normal),z.vertexAttribPointer(H.normal,3,z.FLOAT,!1,0,0)),v.hasUvs&&(z.bindBuffer(z.ARRAY_BUFFER,I.uv),z.bufferData(z.ARRAY_BUFFER,v.uvArray,z.DYNAMIC_DRAW),q.enableAttribute(H.uv),z.vertexAttribPointer(H.uv,2,z.FLOAT,!1,0,0)),v.hasColors&&(z.bindBuffer(z.ARRAY_BUFFER,I.color),z.bufferData(z.ARRAY_BUFFER,v.colorArray,z.DYNAMIC_DRAW),q.enableAttribute(H.color),z.vertexAttribPointer(H.color,3,z.FLOAT,!1,0,0)),q.disableUnusedAttributes(),z.drawArrays(z.TRIANGLES,0,v.count),v.count=0},this.renderBufferDirect=function(v,O,I,H,J,wt){O===null&&(O=st);const ht=J.isMesh&&J.matrixWorld.determinant()<0,gt=Rs(v,O,H,J);ot.setMaterial(H,ht);let Dt=I.index;const pt=I.attributes.position;if(Dt===null){if(pt===void 0||pt.count===0)return}else if(Dt.count===0)return;let Tt=1;H.wireframe===!0&&(Dt=mt.getWireframeAttribute(I),Tt=2),(H.morphTargets||H.morphNormals)&&Lt.update(J,I,H,gt),q.setup(J,H,gt,I,Dt);let ut,Pt=xt;Dt!==null&&(ut=dt.get(Dt),Pt=A,Pt.setIndex(ut));const oe=Dt!==null?Dt.count:pt.count,Wt=I.drawRange.start*Tt,Ue=I.drawRange.count*Tt,Ht=wt!==null?wt.start*Tt:0,He=wt!==null?wt.count*Tt:1/0,Ut=Math.max(Wt,Ht),Vn=Math.min(oe,Wt+Ue,Ht+He)-1,qt=Math.max(0,Vn-Ut+1);if(qt!==0){if(J.isMesh)H.wireframe===!0?(ot.setLineWidth(H.wireframeLinewidth*ct()),Pt.setMode(z.LINES)):Pt.setMode(z.TRIANGLES);else if(J.isLine){let fe=H.linewidth;fe===void 0&&(fe=1),ot.setLineWidth(fe*ct()),J.isLineSegments?Pt.setMode(z.LINES):J.isLineLoop?Pt.setMode(z.LINE_LOOP):Pt.setMode(z.LINE_STRIP)}else J.isPoints?Pt.setMode(z.POINTS):J.isSprite&&Pt.setMode(z.TRIANGLES);if(J.isInstancedMesh)Pt.renderInstances(Ut,qt,J.count);else if(I.isInstancedBufferGeometry){const fe=Math.min(I.instanceCount,I._maxInstanceCount);Pt.renderInstances(Ut,qt,fe)}else Pt.render(Ut,qt)}},this.compile=function(v,O){d=X.get(v),d.init(),v.traverseVisible(function(I){I.isLight&&I.layers.test(O.layers)&&(d.pushLight(I),I.castShadow&&d.pushShadow(I))}),d.setupLights(),v.traverse(function(I){const H=I.material;if(H)if(Array.isArray(H))for(let J=0;J<H.length;J++){const wt=H[J];kn(wt,v,I)}else kn(H,v,I)})};let re=null;function Bl(v){re&&re(v)}function ws(){Oe.stop()}function Ss(){Oe.start()}const Oe=new Gp;Oe.setAnimationLoop(Bl),typeof window!="undefined"&&Oe.setContext(window),this.setAnimationLoop=function(v){re=v,k.setAnimationLoop(v),v===null?Oe.stop():Oe.start()},k.addEventListener("sessionstart",ws),k.addEventListener("sessionend",Ss),this.render=function(v,O){let I,H;if(arguments[2]!==void 0&&(console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."),I=arguments[2]),arguments[3]!==void 0&&(console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."),H=arguments[3]),O!==void 0&&O.isCamera!==!0){console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(y===!0)return;v.autoUpdate===!0&&v.updateMatrixWorld(),O.parent===null&&O.updateMatrixWorld(),k.enabled===!0&&k.isPresenting===!0&&(O=k.getCamera(O)),v.isScene===!0&&v.onBeforeRender(x,v,O,I||E),d=X.get(v,p.length),d.init(),p.push(d),Q.multiplyMatrices(O.projectionMatrix,O.matrixWorldInverse),W.setFromProjectionMatrix(Q),Y=this.localClippingEnabled,j=$.init(this.clippingPlanes,Y,O),u=M.get(v,f.length),u.init(),f.push(u),Es(v,O,0,x.sortObjects),u.finish(),x.sortObjects===!0&&u.sort(V,R),j===!0&&$.beginShadows();const J=d.state.shadowsArray;tt.render(J,v,O),d.setupLights(),d.setupLightsView(O),j===!0&&$.endShadows(),this.info.autoReset===!0&&this.info.reset(),I!==void 0&&this.setRenderTarget(I),nt.render(u,v,O,H);const wt=u.opaque,ht=u.transparent;wt.length>0&&As(wt,v,O),ht.length>0&&As(ht,v,O),E!==null&&(St.updateRenderTargetMipmap(E),St.updateMultisampleRenderTarget(E)),v.isScene===!0&&v.onAfterRender(x,v,O),ot.buffers.depth.setTest(!0),ot.buffers.depth.setMask(!0),ot.buffers.color.setMask(!0),ot.setPolygonOffset(!1),q.resetDefaultState(),w=-1,S=null,p.pop(),p.length>0?d=p[p.length-1]:d=null,f.pop(),f.length>0?u=f[f.length-1]:u=null};function Es(v,O,I,H){if(v.visible===!1)return;if(v.layers.test(O.layers)){if(v.isGroup)I=v.renderOrder;else if(v.isLOD)v.autoUpdate===!0&&v.update(O);else if(v.isLight)d.pushLight(v),v.castShadow&&d.pushShadow(v);else if(v.isSprite){if(!v.frustumCulled||W.intersectsSprite(v)){H&&K.setFromMatrixPosition(v.matrixWorld).applyMatrix4(Q);const ht=bt.update(v),gt=v.material;gt.visible&&u.push(v,ht,gt,I,K.z,null)}}else if(v.isImmediateRenderObject)H&&K.setFromMatrixPosition(v.matrixWorld).applyMatrix4(Q),u.push(v,null,v.material,I,K.z,null);else if((v.isMesh||v.isLine||v.isPoints)&&(v.isSkinnedMesh&&v.skeleton.frame!==Ct.render.frame&&(v.skeleton.update(),v.skeleton.frame=Ct.render.frame),!v.frustumCulled||W.intersectsObject(v))){H&&K.setFromMatrixPosition(v.matrixWorld).applyMatrix4(Q);const ht=bt.update(v),gt=v.material;if(Array.isArray(gt)){const Dt=ht.groups;for(let pt=0,Tt=Dt.length;pt<Tt;pt++){const ut=Dt[pt],Pt=gt[ut.materialIndex];Pt&&Pt.visible&&u.push(v,ht,Pt,I,K.z,ut)}}else gt.visible&&u.push(v,ht,gt,I,K.z,null)}}const wt=v.children;for(let ht=0,gt=wt.length;ht<gt;ht++)Es(wt[ht],O,I,H)}function As(v,O,I){const H=O.isScene===!0?O.overrideMaterial:null;for(let J=0,wt=v.length;J<wt;J++){const ht=v[J],gt=ht.object,Dt=ht.geometry,pt=H===null?ht.material:H,Tt=ht.group;if(I.isArrayCamera){const ut=I.cameras;for(let Pt=0,oe=ut.length;Pt<oe;Pt++){const Wt=ut[Pt];gt.layers.test(Wt.layers)&&(ot.viewport(_.copy(Wt.viewport)),d.setupLightsView(Wt),Ts(gt,O,Wt,Dt,pt,Tt))}}else Ts(gt,O,I,Dt,pt,Tt)}}function Ts(v,O,I,H,J,wt){if(v.onBeforeRender(x,O,I,H,J,wt),v.modelViewMatrix.multiplyMatrices(I.matrixWorldInverse,v.matrixWorld),v.normalMatrix.getNormalMatrix(v.modelViewMatrix),v.isImmediateRenderObject){const ht=Rs(I,O,J,v);ot.setMaterial(J),q.reset(),Xt(v,ht)}else x.renderBufferDirect(I,O,H,J,v,wt);v.onAfterRender(x,O,I,H,J,wt)}function kn(v,O,I){O.isScene!==!0&&(O=st);const H=Mt.get(v),J=d.state.lights,wt=d.state.shadowsArray,ht=J.state.version,gt=ft.getParameters(v,J.state,wt,O,I),Dt=ft.getProgramCacheKey(gt);let pt=H.programs;H.environment=v.isMeshStandardMaterial?O.environment:null,H.fog=O.fog,H.envMap=rt.get(v.envMap||H.environment),pt===void 0&&(v.addEventListener("dispose",Nt),pt=new Map,H.programs=pt);let Tt=pt.get(Dt);if(Tt!==void 0){if(H.currentProgram===Tt&&H.lightsStateVersion===ht)return Ls(v,gt),Tt}else gt.uniforms=ft.getUniforms(v),v.onBeforeCompile(gt,x),Tt=ft.acquireProgram(gt,Dt),pt.set(Dt,Tt),H.uniforms=gt.uniforms;const ut=H.uniforms;(!v.isShaderMaterial&&!v.isRawShaderMaterial||v.clipping===!0)&&(ut.clippingPlanes=$.uniform),Ls(v,gt),H.needsLights=Ul(v),H.lightsStateVersion=ht,H.needsLights&&(ut.ambientLightColor.value=J.state.ambient,ut.lightProbe.value=J.state.probe,ut.directionalLights.value=J.state.directional,ut.directionalLightShadows.value=J.state.directionalShadow,ut.spotLights.value=J.state.spot,ut.spotLightShadows.value=J.state.spotShadow,ut.rectAreaLights.value=J.state.rectArea,ut.ltc_1.value=J.state.rectAreaLTC1,ut.ltc_2.value=J.state.rectAreaLTC2,ut.pointLights.value=J.state.point,ut.pointLightShadows.value=J.state.pointShadow,ut.hemisphereLights.value=J.state.hemi,ut.directionalShadowMap.value=J.state.directionalShadowMap,ut.directionalShadowMatrix.value=J.state.directionalShadowMatrix,ut.spotShadowMap.value=J.state.spotShadowMap,ut.spotShadowMatrix.value=J.state.spotShadowMatrix,ut.pointShadowMap.value=J.state.pointShadowMap,ut.pointShadowMatrix.value=J.state.pointShadowMatrix);const Pt=Tt.getUniforms(),oe=Dn.seqWithValue(Pt.seq,ut);return H.currentProgram=Tt,H.uniformsList=oe,Tt}function Ls(v,O){const I=Mt.get(v);I.outputEncoding=O.outputEncoding,I.instancing=O.instancing,I.numClippingPlanes=O.numClippingPlanes,I.numIntersection=O.numClipIntersection,I.vertexAlphas=O.vertexAlphas}function Rs(v,O,I,H){O.isScene!==!0&&(O=st),St.resetTextureUnits();const J=O.fog,wt=I.isMeshStandardMaterial?O.environment:null,ht=E===null?x.outputEncoding:E.texture.encoding,gt=rt.get(I.envMap||wt),Dt=I.vertexColors===!0&&H.geometry.attributes.color&&H.geometry.attributes.color.itemSize===4,pt=Mt.get(I),Tt=d.state.lights;if(j===!0&&(Y===!0||v!==S)){const Ut=v===S&&I.id===w;$.setState(I,v,Ut)}let ut=!1;I.version===pt.__version?(pt.needsLights&&pt.lightsStateVersion!==Tt.state.version||pt.outputEncoding!==ht||H.isInstancedMesh&&pt.instancing===!1||!H.isInstancedMesh&&pt.instancing===!0||pt.envMap!==gt||I.fog&&pt.fog!==J||pt.numClippingPlanes!==void 0&&(pt.numClippingPlanes!==$.numPlanes||pt.numIntersection!==$.numIntersection)||pt.vertexAlphas!==Dt)&&(ut=!0):(ut=!0,pt.__version=I.version);let Pt=pt.currentProgram;ut===!0&&(Pt=kn(I,O,H));let oe=!1,Wt=!1,Ue=!1;const Ht=Pt.getUniforms(),He=pt.uniforms;if(ot.useProgram(Pt.program)&&(oe=!0,Wt=!0,Ue=!0),I.id!==w&&(w=I.id,Wt=!0),oe||S!==v){if(Ht.setValue(z,"projectionMatrix",v.projectionMatrix),yt.logarithmicDepthBuffer&&Ht.setValue(z,"logDepthBufFC",2/(Math.log(v.far+1)/Math.LN2)),S!==v&&(S=v,Wt=!0,Ue=!0),I.isShaderMaterial||I.isMeshPhongMaterial||I.isMeshToonMaterial||I.isMeshStandardMaterial||I.envMap){const Ut=Ht.map.cameraPosition;Ut!==void 0&&Ut.setValue(z,K.setFromMatrixPosition(v.matrixWorld))}(I.isMeshPhongMaterial||I.isMeshToonMaterial||I.isMeshLambertMaterial||I.isMeshBasicMaterial||I.isMeshStandardMaterial||I.isShaderMaterial)&&Ht.setValue(z,"isOrthographic",v.isOrthographicCamera===!0),(I.isMeshPhongMaterial||I.isMeshToonMaterial||I.isMeshLambertMaterial||I.isMeshBasicMaterial||I.isMeshStandardMaterial||I.isShaderMaterial||I.isShadowMaterial||I.skinning)&&Ht.setValue(z,"viewMatrix",v.matrixWorldInverse)}if(I.skinning){Ht.setOptional(z,H,"bindMatrix"),Ht.setOptional(z,H,"bindMatrixInverse");const Ut=H.skeleton;if(Ut){const Vn=Ut.bones;if(yt.floatVertexTextures){if(Ut.boneTexture===null){let qt=Math.sqrt(Vn.length*4);qt=Zt.ceilPowerOfTwo(qt),qt=Math.max(qt,4);const fe=new Float32Array(qt*qt*4);fe.set(Ut.boneMatrices);const Hl=new Np(fe,qt,qt,Ii,wn);Ut.boneMatrices=fe,Ut.boneTexture=Hl,Ut.boneTextureSize=qt}Ht.setValue(z,"boneTexture",Ut.boneTexture,St),Ht.setValue(z,"boneTextureSize",Ut.boneTextureSize)}else Ht.setOptional(z,Ut,"boneMatrices")}}return(Wt||pt.receiveShadow!==H.receiveShadow)&&(pt.receiveShadow=H.receiveShadow,Ht.setValue(z,"receiveShadow",H.receiveShadow)),Wt&&(Ht.setValue(z,"toneMappingExposure",x.toneMappingExposure),pt.needsLights&&Ol(He,Ue),J&&I.fog&&b.refreshFogUniforms(He,J),b.refreshMaterialUniforms(He,I,D,G),Dn.upload(z,pt.uniformsList,He,St)),I.isShaderMaterial&&I.uniformsNeedUpdate===!0&&(Dn.upload(z,pt.uniformsList,He,St),I.uniformsNeedUpdate=!1),I.isSpriteMaterial&&Ht.setValue(z,"center",H.center),Ht.setValue(z,"modelViewMatrix",H.modelViewMatrix),Ht.setValue(z,"normalMatrix",H.normalMatrix),Ht.setValue(z,"modelMatrix",H.matrixWorld),Pt}function Ol(v,O){v.ambientLightColor.needsUpdate=O,v.lightProbe.needsUpdate=O,v.directionalLights.needsUpdate=O,v.directionalLightShadows.needsUpdate=O,v.pointLights.needsUpdate=O,v.pointLightShadows.needsUpdate=O,v.spotLights.needsUpdate=O,v.spotLightShadows.needsUpdate=O,v.rectAreaLights.needsUpdate=O,v.hemisphereLights.needsUpdate=O}function Ul(v){return v.isMeshLambertMaterial||v.isMeshToonMaterial||v.isMeshPhongMaterial||v.isMeshStandardMaterial||v.isShadowMaterial||v.isShaderMaterial&&v.lights===!0}this.getActiveCubeFace=function(){return g},this.getActiveMipmapLevel=function(){return m},this.getRenderTarget=function(){return E},this.setRenderTarget=function(v,O=0,I=0){E=v,g=O,m=I,v&&Mt.get(v).__webglFramebuffer===void 0&&St.setupRenderTarget(v);let H=null,J=!1,wt=!1;if(v){const ht=v.texture;(ht.isDataTexture3D||ht.isDataTexture2DArray)&&(wt=!0);const gt=Mt.get(v).__webglFramebuffer;v.isWebGLCubeRenderTarget?(H=gt[O],J=!0):v.isWebGLMultisampleRenderTarget?H=Mt.get(v).__webglMultisampledFramebuffer:H=gt,_.copy(v.viewport),T.copy(v.scissor),B=v.scissorTest}else _.copy(L).multiplyScalar(D).floor(),T.copy(P).multiplyScalar(D).floor(),B=F;if(ot.bindFramebuffer(z.FRAMEBUFFER,H),ot.viewport(_),ot.scissor(T),ot.setScissorTest(B),J){const ht=Mt.get(v.texture);z.framebufferTexture2D(z.FRAMEBUFFER,z.COLOR_ATTACHMENT0,z.TEXTURE_CUBE_MAP_POSITIVE_X+O,ht.__webglTexture,I)}else if(wt){const ht=Mt.get(v.texture),gt=O||0;z.framebufferTextureLayer(z.FRAMEBUFFER,z.COLOR_ATTACHMENT0,ht.__webglTexture,I||0,gt)}},this.readRenderTargetPixels=function(v,O,I,H,J,wt,ht){if(!(v&&v.isWebGLRenderTarget)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let gt=Mt.get(v).__webglFramebuffer;if(v.isWebGLCubeRenderTarget&&ht!==void 0&&(gt=gt[ht]),gt){ot.bindFramebuffer(z.FRAMEBUFFER,gt);try{const Dt=v.texture,pt=Dt.format,Tt=Dt.type;if(pt!==Ii&&C.convert(pt)!==z.getParameter(z.IMPLEMENTATION_COLOR_READ_FORMAT)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}const ut=Tt===Uo&&(At.has("EXT_color_buffer_half_float")||yt.isWebGL2&&At.has("EXT_color_buffer_float"));if(Tt!==gh&&C.convert(Tt)!==z.getParameter(z.IMPLEMENTATION_COLOR_READ_TYPE)&&!(Tt===wn&&(yt.isWebGL2||At.has("OES_texture_float")||At.has("WEBGL_color_buffer_float")))&&!ut){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}z.checkFramebufferStatus(z.FRAMEBUFFER)===z.FRAMEBUFFER_COMPLETE?O>=0&&O<=v.width-H&&I>=0&&I<=v.height-J&&z.readPixels(O,I,H,J,C.convert(pt),C.convert(Tt),wt):console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")}finally{const Dt=E!==null?Mt.get(E).__webglFramebuffer:null;ot.bindFramebuffer(z.FRAMEBUFFER,Dt)}}},this.copyFramebufferToTexture=function(v,O,I=0){const H=Math.pow(2,-I),J=Math.floor(O.image.width*H),wt=Math.floor(O.image.height*H),ht=C.convert(O.format);St.setTexture2D(O,0),z.copyTexImage2D(z.TEXTURE_2D,I,ht,v.x,v.y,J,wt,0),ot.unbindTexture()},this.copyTextureToTexture=function(v,O,I,H=0){const J=O.image.width,wt=O.image.height,ht=C.convert(I.format),gt=C.convert(I.type);St.setTexture2D(I,0),z.pixelStorei(z.UNPACK_FLIP_Y_WEBGL,I.flipY),z.pixelStorei(z.UNPACK_PREMULTIPLY_ALPHA_WEBGL,I.premultiplyAlpha),z.pixelStorei(z.UNPACK_ALIGNMENT,I.unpackAlignment),O.isDataTexture?z.texSubImage2D(z.TEXTURE_2D,H,v.x,v.y,J,wt,ht,gt,O.image.data):O.isCompressedTexture?z.compressedTexSubImage2D(z.TEXTURE_2D,H,v.x,v.y,O.mipmaps[0].width,O.mipmaps[0].height,ht,O.mipmaps[0].data):z.texSubImage2D(z.TEXTURE_2D,H,v.x,v.y,ht,gt,O.image),H===0&&I.generateMipmaps&&z.generateMipmap(z.TEXTURE_2D),ot.unbindTexture()},this.copyTextureToTexture3D=function(v,O,I,H,J=0){if(x.isWebGL1Renderer){console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");return}const{width:wt,height:ht,data:gt}=I.image,Dt=C.convert(H.format),pt=C.convert(H.type);let Tt;if(H.isDataTexture3D)St.setTexture3D(H,0),Tt=z.TEXTURE_3D;else if(H.isDataTexture2DArray)St.setTexture2DArray(H,0),Tt=z.TEXTURE_2D_ARRAY;else{console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");return}z.pixelStorei(z.UNPACK_FLIP_Y_WEBGL,H.flipY),z.pixelStorei(z.UNPACK_PREMULTIPLY_ALPHA_WEBGL,H.premultiplyAlpha),z.pixelStorei(z.UNPACK_ALIGNMENT,H.unpackAlignment);const ut=z.getParameter(z.UNPACK_ROW_LENGTH),Pt=z.getParameter(z.UNPACK_IMAGE_HEIGHT),oe=z.getParameter(z.UNPACK_SKIP_PIXELS),Wt=z.getParameter(z.UNPACK_SKIP_ROWS),Ue=z.getParameter(z.UNPACK_SKIP_IMAGES);z.pixelStorei(z.UNPACK_ROW_LENGTH,wt),z.pixelStorei(z.UNPACK_IMAGE_HEIGHT,ht),z.pixelStorei(z.UNPACK_SKIP_PIXELS,v.min.x),z.pixelStorei(z.UNPACK_SKIP_ROWS,v.min.y),z.pixelStorei(z.UNPACK_SKIP_IMAGES,v.min.z),z.texSubImage3D(Tt,J,O.x,O.y,O.z,v.max.x-v.min.x+1,v.max.y-v.min.y+1,v.max.z-v.min.z+1,Dt,pt,gt),z.pixelStorei(z.UNPACK_ROW_LENGTH,ut),z.pixelStorei(z.UNPACK_IMAGE_HEIGHT,Pt),z.pixelStorei(z.UNPACK_SKIP_PIXELS,oe),z.pixelStorei(z.UNPACK_SKIP_ROWS,Wt),z.pixelStorei(z.UNPACK_SKIP_IMAGES,Ue),J===0&&H.generateMipmaps&&z.generateMipmap(Tt),ot.unbindTexture()},this.initTexture=function(v){St.setTexture2D(v,0),ot.unbindTexture()},this.resetState=function(){g=0,m=0,E=null,ot.reset(),q.reset()},typeof __THREE_DEVTOOLS__!="undefined"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}class tu extends he{constructor(){super();this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.overrideMaterial=null,this.autoUpdate=!0,typeof __THREE_DEVTOOLS__!="undefined"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(t,e){return super.copy(t,e),t.background!==null&&(this.background=t.background.clone()),t.environment!==null&&(this.environment=t.environment.clone()),t.fog!==null&&(this.fog=t.fog.clone()),t.overrideMaterial!==null&&(this.overrideMaterial=t.overrideMaterial.clone()),this.autoUpdate=t.autoUpdate,this.matrixAutoUpdate=t.matrixAutoUpdate,this}toJSON(t){const e=super.toJSON(t);return this.background!==null&&(e.object.background=this.background.toJSON(t)),this.environment!==null&&(e.object.environment=this.environment.toJSON(t)),this.fog!==null&&(e.object.fog=this.fog.toJSON()),e}}tu.prototype.isScene=!0;class Rm extends he{constructor(t,e=1){super();this.type="Light",this.color=new Jt(t),this.intensity=e}copy(t){return super.copy(t),this.color.copy(t.color),this.intensity=t.intensity,this}toJSON(t){const e=super.toJSON(t);return e.object.color=this.color.getHex(),e.object.intensity=this.intensity,this.groundColor!==void 0&&(e.object.groundColor=this.groundColor.getHex()),this.distance!==void 0&&(e.object.distance=this.distance),this.angle!==void 0&&(e.object.angle=this.angle),this.decay!==void 0&&(e.object.decay=this.decay),this.penumbra!==void 0&&(e.object.penumbra=this.penumbra),this.shadow!==void 0&&(e.object.shadow=this.shadow.toJSON()),e}}Rm.prototype.isLight=!0;class Cm extends Rm{constructor(t,e){super(t,e);this.type="AmbientLight"}}Cm.prototype.isAmbientLight=!0;const Pm=0,n2=1,Dm=2,r2=1,Fm=1,s2=100,a2=204,o2=205,l2=3,Im=0,zm=300,Nm=1e3,ol=1001,Bm=1002,Ta=1003,Om=1006,c2=1008,h2=1009,u2=1023,d2=3e3,Qi="srgb",er="srgb-linear",eu=7680,f2=519,Um=35044,Be=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"];function La(){const i=Math.random()*4294967295|0,t=Math.random()*4294967295|0,e=Math.random()*4294967295|0,n=Math.random()*4294967295|0;return(Be[i&255]+Be[i>>8&255]+Be[i>>16&255]+Be[i>>24&255]+"-"+Be[t&255]+Be[t>>8&255]+"-"+Be[t>>16&15|64]+Be[t>>24&255]+"-"+Be[e&63|128]+Be[e>>8&255]+"-"+Be[e>>16&255]+Be[e>>24&255]+Be[n&255]+Be[n>>8&255]+Be[n>>16&255]+Be[n>>24&255]).toLowerCase()}function Ke(i,t,e){return Math.max(t,Math.min(e,i))}function p2(i,t){return(i%t+t)%t}function iu(i,t,e){return(1-e)*i+e*t}class Ra{constructor(t=0,e=0,n=0,r=1){this.isQuaternion=!0,this._x=t,this._y=e,this._z=n,this._w=r}static slerp(t,e,n,r){return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."),n.slerpQuaternions(t,e,r)}static slerpFlat(t,e,n,r,s,a,o){let l=n[r+0],c=n[r+1],h=n[r+2],u=n[r+3];const d=s[a+0],f=s[a+1],p=s[a+2],x=s[a+3];if(o===0){t[e+0]=l,t[e+1]=c,t[e+2]=h,t[e+3]=u;return}if(o===1){t[e+0]=d,t[e+1]=f,t[e+2]=p,t[e+3]=x;return}if(u!==x||l!==d||c!==f||h!==p){let y=1-o;const g=l*d+c*f+h*p+u*x,m=g>=0?1:-1,E=1-g*g;if(E>Number.EPSILON){const S=Math.sqrt(E),_=Math.atan2(S,g*m);y=Math.sin(y*_)/S,o=Math.sin(o*_)/S}const w=o*m;if(l=l*y+d*w,c=c*y+f*w,h=h*y+p*w,u=u*y+x*w,y===1-o){const S=1/Math.sqrt(l*l+c*c+h*h+u*u);l*=S,c*=S,h*=S,u*=S}}t[e]=l,t[e+1]=c,t[e+2]=h,t[e+3]=u}static multiplyQuaternionsFlat(t,e,n,r,s,a){const o=n[r],l=n[r+1],c=n[r+2],h=n[r+3],u=s[a],d=s[a+1],f=s[a+2],p=s[a+3];return t[e]=o*p+h*u+l*f-c*d,t[e+1]=l*p+h*d+c*u-o*f,t[e+2]=c*p+h*f+o*d-l*u,t[e+3]=h*p-o*u-l*d-c*f,t}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get w(){return this._w}set w(t){this._w=t,this._onChangeCallback()}set(t,e,n,r){return this._x=t,this._y=e,this._z=n,this._w=r,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(t){return this._x=t.x,this._y=t.y,this._z=t.z,this._w=t.w,this._onChangeCallback(),this}setFromEuler(t,e){if(!(t&&t.isEuler))throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");const n=t._x,r=t._y,s=t._z,a=t._order,o=Math.cos,l=Math.sin,c=o(n/2),h=o(r/2),u=o(s/2),d=l(n/2),f=l(r/2),p=l(s/2);switch(a){case"XYZ":this._x=d*h*u+c*f*p,this._y=c*f*u-d*h*p,this._z=c*h*p+d*f*u,this._w=c*h*u-d*f*p;break;case"YXZ":this._x=d*h*u+c*f*p,this._y=c*f*u-d*h*p,this._z=c*h*p-d*f*u,this._w=c*h*u+d*f*p;break;case"ZXY":this._x=d*h*u-c*f*p,this._y=c*f*u+d*h*p,this._z=c*h*p+d*f*u,this._w=c*h*u-d*f*p;break;case"ZYX":this._x=d*h*u-c*f*p,this._y=c*f*u+d*h*p,this._z=c*h*p-d*f*u,this._w=c*h*u+d*f*p;break;case"YZX":this._x=d*h*u+c*f*p,this._y=c*f*u+d*h*p,this._z=c*h*p-d*f*u,this._w=c*h*u-d*f*p;break;case"XZY":this._x=d*h*u-c*f*p,this._y=c*f*u-d*h*p,this._z=c*h*p+d*f*u,this._w=c*h*u+d*f*p;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+a)}return e!==!1&&this._onChangeCallback(),this}setFromAxisAngle(t,e){const n=e/2,r=Math.sin(n);return this._x=t.x*r,this._y=t.y*r,this._z=t.z*r,this._w=Math.cos(n),this._onChangeCallback(),this}setFromRotationMatrix(t){const e=t.elements,n=e[0],r=e[4],s=e[8],a=e[1],o=e[5],l=e[9],c=e[2],h=e[6],u=e[10],d=n+o+u;if(d>0){const f=.5/Math.sqrt(d+1);this._w=.25/f,this._x=(h-l)*f,this._y=(s-c)*f,this._z=(a-r)*f}else if(n>o&&n>u){const f=2*Math.sqrt(1+n-o-u);this._w=(h-l)/f,this._x=.25*f,this._y=(r+a)/f,this._z=(s+c)/f}else if(o>u){const f=2*Math.sqrt(1+o-n-u);this._w=(s-c)/f,this._x=(r+a)/f,this._y=.25*f,this._z=(l+h)/f}else{const f=2*Math.sqrt(1+u-n-o);this._w=(a-r)/f,this._x=(s+c)/f,this._y=(l+h)/f,this._z=.25*f}return this._onChangeCallback(),this}setFromUnitVectors(t,e){let n=t.dot(e)+1;return n<Number.EPSILON?(n=0,Math.abs(t.x)>Math.abs(t.z)?(this._x=-t.y,this._y=t.x,this._z=0,this._w=n):(this._x=0,this._y=-t.z,this._z=t.y,this._w=n)):(this._x=t.y*e.z-t.z*e.y,this._y=t.z*e.x-t.x*e.z,this._z=t.x*e.y-t.y*e.x,this._w=n),this.normalize()}angleTo(t){return 2*Math.acos(Math.abs(Ke(this.dot(t),-1,1)))}rotateTowards(t,e){const n=this.angleTo(t);if(n===0)return this;const r=Math.min(1,e/n);return this.slerp(t,r),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(t){return this._x*t._x+this._y*t._y+this._z*t._z+this._w*t._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let t=this.length();return t===0?(this._x=0,this._y=0,this._z=0,this._w=1):(t=1/t,this._x=this._x*t,this._y=this._y*t,this._z=this._z*t,this._w=this._w*t),this._onChangeCallback(),this}multiply(t,e){return e!==void 0?(console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),this.multiplyQuaternions(t,e)):this.multiplyQuaternions(this,t)}premultiply(t){return this.multiplyQuaternions(t,this)}multiplyQuaternions(t,e){const n=t._x,r=t._y,s=t._z,a=t._w,o=e._x,l=e._y,c=e._z,h=e._w;return this._x=n*h+a*o+r*c-s*l,this._y=r*h+a*l+s*o-n*c,this._z=s*h+a*c+n*l-r*o,this._w=a*h-n*o-r*l-s*c,this._onChangeCallback(),this}slerp(t,e){if(e===0)return this;if(e===1)return this.copy(t);const n=this._x,r=this._y,s=this._z,a=this._w;let o=a*t._w+n*t._x+r*t._y+s*t._z;if(o<0?(this._w=-t._w,this._x=-t._x,this._y=-t._y,this._z=-t._z,o=-o):this.copy(t),o>=1)return this._w=a,this._x=n,this._y=r,this._z=s,this;const l=1-o*o;if(l<=Number.EPSILON){const f=1-e;return this._w=f*a+e*this._w,this._x=f*n+e*this._x,this._y=f*r+e*this._y,this._z=f*s+e*this._z,this.normalize(),this._onChangeCallback(),this}const c=Math.sqrt(l),h=Math.atan2(c,o),u=Math.sin((1-e)*h)/c,d=Math.sin(e*h)/c;return this._w=a*u+this._w*d,this._x=n*u+this._x*d,this._y=r*u+this._y*d,this._z=s*u+this._z*d,this._onChangeCallback(),this}slerpQuaternions(t,e,n){return this.copy(t).slerp(e,n)}random(){const t=Math.random(),e=Math.sqrt(1-t),n=Math.sqrt(t),r=2*Math.PI*Math.random(),s=2*Math.PI*Math.random();return this.set(e*Math.cos(r),n*Math.sin(s),n*Math.cos(s),e*Math.sin(r))}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._w===this._w}fromArray(t,e=0){return this._x=t[e],this._y=t[e+1],this._z=t[e+2],this._w=t[e+3],this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._w,t}fromBufferAttribute(t,e){return this._x=t.getX(e),this._y=t.getY(e),this._z=t.getZ(e),this._w=t.getW(e),this}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class it{constructor(t=0,e=0,n=0){it.prototype.isVector3=!0,this.x=t,this.y=e,this.z=n}set(t,e,n){return n===void 0&&(n=this.z),this.x=t,this.y=e,this.z=n,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}add(t,e){return e!==void 0?(console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this.z+=t.z,this)}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this}sub(t,e){return e!==void 0?(console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this.z-=t.z,this)}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this}multiply(t,e){return e!==void 0?(console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(t,e)):(this.x*=t.x,this.y*=t.y,this.z*=t.z,this)}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}multiplyVectors(t,e){return this.x=t.x*e.x,this.y=t.y*e.y,this.z=t.z*e.z,this}applyEuler(t){return t&&t.isEuler||console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),this.applyQuaternion(Hm.setFromEuler(t))}applyAxisAngle(t,e){return this.applyQuaternion(Hm.setFromAxisAngle(t,e))}applyMatrix3(t){const e=this.x,n=this.y,r=this.z,s=t.elements;return this.x=s[0]*e+s[3]*n+s[6]*r,this.y=s[1]*e+s[4]*n+s[7]*r,this.z=s[2]*e+s[5]*n+s[8]*r,this}applyNormalMatrix(t){return this.applyMatrix3(t).normalize()}applyMatrix4(t){const e=this.x,n=this.y,r=this.z,s=t.elements,a=1/(s[3]*e+s[7]*n+s[11]*r+s[15]);return this.x=(s[0]*e+s[4]*n+s[8]*r+s[12])*a,this.y=(s[1]*e+s[5]*n+s[9]*r+s[13])*a,this.z=(s[2]*e+s[6]*n+s[10]*r+s[14])*a,this}applyQuaternion(t){const e=this.x,n=this.y,r=this.z,s=t.x,a=t.y,o=t.z,l=t.w,c=l*e+a*r-o*n,h=l*n+o*e-s*r,u=l*r+s*n-a*e,d=-s*e-a*n-o*r;return this.x=c*l+d*-s+h*-o-u*-a,this.y=h*l+d*-a+u*-s-c*-o,this.z=u*l+d*-o+c*-a-h*-s,this}project(t){return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)}unproject(t){return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)}transformDirection(t){const e=this.x,n=this.y,r=this.z,s=t.elements;return this.x=s[0]*e+s[4]*n+s[8]*r,this.y=s[1]*e+s[5]*n+s[9]*r,this.z=s[2]*e+s[6]*n+s[10]*r,this.normalize()}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this}divideScalar(t){return this.multiplyScalar(1/t)}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this.z=t.z+(e.z-t.z)*n,this}cross(t,e){return e!==void 0?(console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(t,e)):this.crossVectors(this,t)}crossVectors(t,e){const n=t.x,r=t.y,s=t.z,a=e.x,o=e.y,l=e.z;return this.x=r*l-s*o,this.y=s*a-n*l,this.z=n*o-r*a,this}projectOnVector(t){const e=t.lengthSq();if(e===0)return this.set(0,0,0);const n=t.dot(this)/e;return this.copy(t).multiplyScalar(n)}projectOnPlane(t){return nu.copy(this).projectOnVector(t),this.sub(nu)}reflect(t){return this.sub(nu.copy(t).multiplyScalar(2*this.dot(t)))}angleTo(t){const e=Math.sqrt(this.lengthSq()*t.lengthSq());if(e===0)return Math.PI/2;const n=this.dot(t)/e;return Math.acos(Ke(n,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,n=this.y-t.y,r=this.z-t.z;return e*e+n*n+r*r}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)+Math.abs(this.z-t.z)}setFromSpherical(t){return this.setFromSphericalCoords(t.radius,t.phi,t.theta)}setFromSphericalCoords(t,e,n){const r=Math.sin(e)*t;return this.x=r*Math.sin(n),this.y=Math.cos(e)*t,this.z=r*Math.cos(n),this}setFromCylindrical(t){return this.setFromCylindricalCoords(t.radius,t.theta,t.y)}setFromCylindricalCoords(t,e,n){return this.x=t*Math.sin(e),this.y=n,this.z=t*Math.cos(e),this}setFromMatrixPosition(t){const e=t.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this}setFromMatrixScale(t){const e=this.setFromMatrixColumn(t,0).length(),n=this.setFromMatrixColumn(t,1).length(),r=this.setFromMatrixColumn(t,2).length();return this.x=e,this.y=n,this.z=r,this}setFromMatrixColumn(t,e){return this.fromArray(t.elements,e*4)}setFromMatrix3Column(t,e){return this.fromArray(t.elements,e*3)}setFromEuler(t){return this.x=t._x,this.y=t._y,this.z=t._z,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t}fromBufferAttribute(t,e,n){return n!==void 0&&console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const t=(Math.random()-.5)*2,e=Math.random()*Math.PI*2,n=Math.sqrt(1-t**2);return this.x=n*Math.cos(e),this.y=n*Math.sin(e),this.z=t,this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const nu=new it,Hm=new Ra;class li{constructor(){li.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")}set(t,e,n,r,s,a,o,l,c,h,u,d,f,p,x,y){const g=this.elements;return g[0]=t,g[4]=e,g[8]=n,g[12]=r,g[1]=s,g[5]=a,g[9]=o,g[13]=l,g[2]=c,g[6]=h,g[10]=u,g[14]=d,g[3]=f,g[7]=p,g[11]=x,g[15]=y,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new li().fromArray(this.elements)}copy(t){const e=this.elements,n=t.elements;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],e[9]=n[9],e[10]=n[10],e[11]=n[11],e[12]=n[12],e[13]=n[13],e[14]=n[14],e[15]=n[15],this}copyPosition(t){const e=this.elements,n=t.elements;return e[12]=n[12],e[13]=n[13],e[14]=n[14],this}setFromMatrix3(t){const e=t.elements;return this.set(e[0],e[3],e[6],0,e[1],e[4],e[7],0,e[2],e[5],e[8],0,0,0,0,1),this}extractBasis(t,e,n){return t.setFromMatrixColumn(this,0),e.setFromMatrixColumn(this,1),n.setFromMatrixColumn(this,2),this}makeBasis(t,e,n){return this.set(t.x,e.x,n.x,0,t.y,e.y,n.y,0,t.z,e.z,n.z,0,0,0,0,1),this}extractRotation(t){const e=this.elements,n=t.elements,r=1/ls.setFromMatrixColumn(t,0).length(),s=1/ls.setFromMatrixColumn(t,1).length(),a=1/ls.setFromMatrixColumn(t,2).length();return e[0]=n[0]*r,e[1]=n[1]*r,e[2]=n[2]*r,e[3]=0,e[4]=n[4]*s,e[5]=n[5]*s,e[6]=n[6]*s,e[7]=0,e[8]=n[8]*a,e[9]=n[9]*a,e[10]=n[10]*a,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromEuler(t){t&&t.isEuler||console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");const e=this.elements,n=t.x,r=t.y,s=t.z,a=Math.cos(n),o=Math.sin(n),l=Math.cos(r),c=Math.sin(r),h=Math.cos(s),u=Math.sin(s);if(t.order==="XYZ"){const d=a*h,f=a*u,p=o*h,x=o*u;e[0]=l*h,e[4]=-l*u,e[8]=c,e[1]=f+p*c,e[5]=d-x*c,e[9]=-o*l,e[2]=x-d*c,e[6]=p+f*c,e[10]=a*l}else if(t.order==="YXZ"){const d=l*h,f=l*u,p=c*h,x=c*u;e[0]=d+x*o,e[4]=p*o-f,e[8]=a*c,e[1]=a*u,e[5]=a*h,e[9]=-o,e[2]=f*o-p,e[6]=x+d*o,e[10]=a*l}else if(t.order==="ZXY"){const d=l*h,f=l*u,p=c*h,x=c*u;e[0]=d-x*o,e[4]=-a*u,e[8]=p+f*o,e[1]=f+p*o,e[5]=a*h,e[9]=x-d*o,e[2]=-a*c,e[6]=o,e[10]=a*l}else if(t.order==="ZYX"){const d=a*h,f=a*u,p=o*h,x=o*u;e[0]=l*h,e[4]=p*c-f,e[8]=d*c+x,e[1]=l*u,e[5]=x*c+d,e[9]=f*c-p,e[2]=-c,e[6]=o*l,e[10]=a*l}else if(t.order==="YZX"){const d=a*l,f=a*c,p=o*l,x=o*c;e[0]=l*h,e[4]=x-d*u,e[8]=p*u+f,e[1]=u,e[5]=a*h,e[9]=-o*h,e[2]=-c*h,e[6]=f*u+p,e[10]=d-x*u}else if(t.order==="XZY"){const d=a*l,f=a*c,p=o*l,x=o*c;e[0]=l*h,e[4]=-u,e[8]=c*h,e[1]=d*u+x,e[5]=a*h,e[9]=f*u-p,e[2]=p*u-f,e[6]=o*h,e[10]=x*u+d}return e[3]=0,e[7]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromQuaternion(t){return this.compose(m2,t,g2)}lookAt(t,e,n){const r=this.elements;return ti.subVectors(t,e),ti.lengthSq()===0&&(ti.z=1),ti.normalize(),Fn.crossVectors(n,ti),Fn.lengthSq()===0&&(Math.abs(n.z)===1?ti.x+=1e-4:ti.z+=1e-4,ti.normalize(),Fn.crossVectors(n,ti)),Fn.normalize(),ll.crossVectors(ti,Fn),r[0]=Fn.x,r[4]=ll.x,r[8]=ti.x,r[1]=Fn.y,r[5]=ll.y,r[9]=ti.y,r[2]=Fn.z,r[6]=ll.z,r[10]=ti.z,this}multiply(t,e){return e!==void 0?(console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),this.multiplyMatrices(t,e)):this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const n=t.elements,r=e.elements,s=this.elements,a=n[0],o=n[4],l=n[8],c=n[12],h=n[1],u=n[5],d=n[9],f=n[13],p=n[2],x=n[6],y=n[10],g=n[14],m=n[3],E=n[7],w=n[11],S=n[15],_=r[0],T=r[4],B=r[8],N=r[12],G=r[1],D=r[5],V=r[9],R=r[13],L=r[2],P=r[6],F=r[10],W=r[14],j=r[3],Y=r[7],Q=r[11],K=r[15];return s[0]=a*_+o*G+l*L+c*j,s[4]=a*T+o*D+l*P+c*Y,s[8]=a*B+o*V+l*F+c*Q,s[12]=a*N+o*R+l*W+c*K,s[1]=h*_+u*G+d*L+f*j,s[5]=h*T+u*D+d*P+f*Y,s[9]=h*B+u*V+d*F+f*Q,s[13]=h*N+u*R+d*W+f*K,s[2]=p*_+x*G+y*L+g*j,s[6]=p*T+x*D+y*P+g*Y,s[10]=p*B+x*V+y*F+g*Q,s[14]=p*N+x*R+y*W+g*K,s[3]=m*_+E*G+w*L+S*j,s[7]=m*T+E*D+w*P+S*Y,s[11]=m*B+E*V+w*F+S*Q,s[15]=m*N+E*R+w*W+S*K,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[4]*=t,e[8]*=t,e[12]*=t,e[1]*=t,e[5]*=t,e[9]*=t,e[13]*=t,e[2]*=t,e[6]*=t,e[10]*=t,e[14]*=t,e[3]*=t,e[7]*=t,e[11]*=t,e[15]*=t,this}determinant(){const t=this.elements,e=t[0],n=t[4],r=t[8],s=t[12],a=t[1],o=t[5],l=t[9],c=t[13],h=t[2],u=t[6],d=t[10],f=t[14],p=t[3],x=t[7],y=t[11],g=t[15];return p*(+s*l*u-r*c*u-s*o*d+n*c*d+r*o*f-n*l*f)+x*(+e*l*f-e*c*d+s*a*d-r*a*f+r*c*h-s*l*h)+y*(+e*c*u-e*o*f-s*a*u+n*a*f+s*o*h-n*c*h)+g*(-r*o*h-e*l*u+e*o*d+r*a*u-n*a*d+n*l*h)}transpose(){const t=this.elements;let e;return e=t[1],t[1]=t[4],t[4]=e,e=t[2],t[2]=t[8],t[8]=e,e=t[6],t[6]=t[9],t[9]=e,e=t[3],t[3]=t[12],t[12]=e,e=t[7],t[7]=t[13],t[13]=e,e=t[11],t[11]=t[14],t[14]=e,this}setPosition(t,e,n){const r=this.elements;return t.isVector3?(r[12]=t.x,r[13]=t.y,r[14]=t.z):(r[12]=t,r[13]=e,r[14]=n),this}invert(){const t=this.elements,e=t[0],n=t[1],r=t[2],s=t[3],a=t[4],o=t[5],l=t[6],c=t[7],h=t[8],u=t[9],d=t[10],f=t[11],p=t[12],x=t[13],y=t[14],g=t[15],m=u*y*c-x*d*c+x*l*f-o*y*f-u*l*g+o*d*g,E=p*d*c-h*y*c-p*l*f+a*y*f+h*l*g-a*d*g,w=h*x*c-p*u*c+p*o*f-a*x*f-h*o*g+a*u*g,S=p*u*l-h*x*l-p*o*d+a*x*d+h*o*y-a*u*y,_=e*m+n*E+r*w+s*S;if(_===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const T=1/_;return t[0]=m*T,t[1]=(x*d*s-u*y*s-x*r*f+n*y*f+u*r*g-n*d*g)*T,t[2]=(o*y*s-x*l*s+x*r*c-n*y*c-o*r*g+n*l*g)*T,t[3]=(u*l*s-o*d*s-u*r*c+n*d*c+o*r*f-n*l*f)*T,t[4]=E*T,t[5]=(h*y*s-p*d*s+p*r*f-e*y*f-h*r*g+e*d*g)*T,t[6]=(p*l*s-a*y*s-p*r*c+e*y*c+a*r*g-e*l*g)*T,t[7]=(a*d*s-h*l*s+h*r*c-e*d*c-a*r*f+e*l*f)*T,t[8]=w*T,t[9]=(p*u*s-h*x*s-p*n*f+e*x*f+h*n*g-e*u*g)*T,t[10]=(a*x*s-p*o*s+p*n*c-e*x*c-a*n*g+e*o*g)*T,t[11]=(h*o*s-a*u*s-h*n*c+e*u*c+a*n*f-e*o*f)*T,t[12]=S*T,t[13]=(h*x*r-p*u*r+p*n*d-e*x*d-h*n*y+e*u*y)*T,t[14]=(p*o*r-a*x*r-p*n*l+e*x*l+a*n*y-e*o*y)*T,t[15]=(a*u*r-h*o*r+h*n*l-e*u*l-a*n*d+e*o*d)*T,this}scale(t){const e=this.elements,n=t.x,r=t.y,s=t.z;return e[0]*=n,e[4]*=r,e[8]*=s,e[1]*=n,e[5]*=r,e[9]*=s,e[2]*=n,e[6]*=r,e[10]*=s,e[3]*=n,e[7]*=r,e[11]*=s,this}getMaxScaleOnAxis(){const t=this.elements,e=t[0]*t[0]+t[1]*t[1]+t[2]*t[2],n=t[4]*t[4]+t[5]*t[5]+t[6]*t[6],r=t[8]*t[8]+t[9]*t[9]+t[10]*t[10];return Math.sqrt(Math.max(e,n,r))}makeTranslation(t,e,n){return this.set(1,0,0,t,0,1,0,e,0,0,1,n,0,0,0,1),this}makeRotationX(t){const e=Math.cos(t),n=Math.sin(t);return this.set(1,0,0,0,0,e,-n,0,0,n,e,0,0,0,0,1),this}makeRotationY(t){const e=Math.cos(t),n=Math.sin(t);return this.set(e,0,n,0,0,1,0,0,-n,0,e,0,0,0,0,1),this}makeRotationZ(t){const e=Math.cos(t),n=Math.sin(t);return this.set(e,-n,0,0,n,e,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(t,e){const n=Math.cos(e),r=Math.sin(e),s=1-n,a=t.x,o=t.y,l=t.z,c=s*a,h=s*o;return this.set(c*a+n,c*o-r*l,c*l+r*o,0,c*o+r*l,h*o+n,h*l-r*a,0,c*l-r*o,h*l+r*a,s*l*l+n,0,0,0,0,1),this}makeScale(t,e,n){return this.set(t,0,0,0,0,e,0,0,0,0,n,0,0,0,0,1),this}makeShear(t,e,n,r,s,a){return this.set(1,n,s,0,t,1,a,0,e,r,1,0,0,0,0,1),this}compose(t,e,n){const r=this.elements,s=e._x,a=e._y,o=e._z,l=e._w,c=s+s,h=a+a,u=o+o,d=s*c,f=s*h,p=s*u,x=a*h,y=a*u,g=o*u,m=l*c,E=l*h,w=l*u,S=n.x,_=n.y,T=n.z;return r[0]=(1-(x+g))*S,r[1]=(f+w)*S,r[2]=(p-E)*S,r[3]=0,r[4]=(f-w)*_,r[5]=(1-(d+g))*_,r[6]=(y+m)*_,r[7]=0,r[8]=(p+E)*T,r[9]=(y-m)*T,r[10]=(1-(d+x))*T,r[11]=0,r[12]=t.x,r[13]=t.y,r[14]=t.z,r[15]=1,this}decompose(t,e,n){const r=this.elements;let s=ls.set(r[0],r[1],r[2]).length();const a=ls.set(r[4],r[5],r[6]).length(),o=ls.set(r[8],r[9],r[10]).length();this.determinant()<0&&(s=-s),t.x=r[12],t.y=r[13],t.z=r[14],vi.copy(this);const c=1/s,h=1/a,u=1/o;return vi.elements[0]*=c,vi.elements[1]*=c,vi.elements[2]*=c,vi.elements[4]*=h,vi.elements[5]*=h,vi.elements[6]*=h,vi.elements[8]*=u,vi.elements[9]*=u,vi.elements[10]*=u,e.setFromRotationMatrix(vi),n.x=s,n.y=a,n.z=o,this}makePerspective(t,e,n,r,s,a){a===void 0&&console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");const o=this.elements,l=2*s/(e-t),c=2*s/(n-r),h=(e+t)/(e-t),u=(n+r)/(n-r),d=-(a+s)/(a-s),f=-2*a*s/(a-s);return o[0]=l,o[4]=0,o[8]=h,o[12]=0,o[1]=0,o[5]=c,o[9]=u,o[13]=0,o[2]=0,o[6]=0,o[10]=d,o[14]=f,o[3]=0,o[7]=0,o[11]=-1,o[15]=0,this}makeOrthographic(t,e,n,r,s,a){const o=this.elements,l=1/(e-t),c=1/(n-r),h=1/(a-s),u=(e+t)*l,d=(n+r)*c,f=(a+s)*h;return o[0]=2*l,o[4]=0,o[8]=0,o[12]=-u,o[1]=0,o[5]=2*c,o[9]=0,o[13]=-d,o[2]=0,o[6]=0,o[10]=-2*h,o[14]=-f,o[3]=0,o[7]=0,o[11]=0,o[15]=1,this}equals(t){const e=this.elements,n=t.elements;for(let r=0;r<16;r++)if(e[r]!==n[r])return!1;return!0}fromArray(t,e=0){for(let n=0;n<16;n++)this.elements[n]=t[n+e];return this}toArray(t=[],e=0){const n=this.elements;return t[e]=n[0],t[e+1]=n[1],t[e+2]=n[2],t[e+3]=n[3],t[e+4]=n[4],t[e+5]=n[5],t[e+6]=n[6],t[e+7]=n[7],t[e+8]=n[8],t[e+9]=n[9],t[e+10]=n[10],t[e+11]=n[11],t[e+12]=n[12],t[e+13]=n[13],t[e+14]=n[14],t[e+15]=n[15],t}}const ls=new it,vi=new li,m2=new it(0,0,0),g2=new it(1,1,1),Fn=new it,ll=new it,ti=new it;class cl{addEventListener(t,e){this._listeners===void 0&&(this._listeners={});const n=this._listeners;n[t]===void 0&&(n[t]=[]),n[t].indexOf(e)===-1&&n[t].push(e)}hasEventListener(t,e){if(this._listeners===void 0)return!1;const n=this._listeners;return n[t]!==void 0&&n[t].indexOf(e)!==-1}removeEventListener(t,e){if(this._listeners===void 0)return;const r=this._listeners[t];if(r!==void 0){const s=r.indexOf(e);s!==-1&&r.splice(s,1)}}dispatchEvent(t){if(this._listeners===void 0)return;const n=this._listeners[t.type];if(n!==void 0){t.target=this;const r=n.slice(0);for(let s=0,a=r.length;s<a;s++)r[s].call(this,t);t.target=null}}}const Gm=new li,km=new Ra;class Ca{constructor(t=0,e=0,n=0,r=Ca.DefaultOrder){this.isEuler=!0,this._x=t,this._y=e,this._z=n,this._order=r}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get order(){return this._order}set order(t){this._order=t,this._onChangeCallback()}set(t,e,n,r=this._order){return this._x=t,this._y=e,this._z=n,this._order=r,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(t){return this._x=t._x,this._y=t._y,this._z=t._z,this._order=t._order,this._onChangeCallback(),this}setFromRotationMatrix(t,e=this._order,n=!0){const r=t.elements,s=r[0],a=r[4],o=r[8],l=r[1],c=r[5],h=r[9],u=r[2],d=r[6],f=r[10];switch(e){case"XYZ":this._y=Math.asin(Ke(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(-h,f),this._z=Math.atan2(-a,s)):(this._x=Math.atan2(d,c),this._z=0);break;case"YXZ":this._x=Math.asin(-Ke(h,-1,1)),Math.abs(h)<.9999999?(this._y=Math.atan2(o,f),this._z=Math.atan2(l,c)):(this._y=Math.atan2(-u,s),this._z=0);break;case"ZXY":this._x=Math.asin(Ke(d,-1,1)),Math.abs(d)<.9999999?(this._y=Math.atan2(-u,f),this._z=Math.atan2(-a,c)):(this._y=0,this._z=Math.atan2(l,s));break;case"ZYX":this._y=Math.asin(-Ke(u,-1,1)),Math.abs(u)<.9999999?(this._x=Math.atan2(d,f),this._z=Math.atan2(l,s)):(this._x=0,this._z=Math.atan2(-a,c));break;case"YZX":this._z=Math.asin(Ke(l,-1,1)),Math.abs(l)<.9999999?(this._x=Math.atan2(-h,c),this._y=Math.atan2(-u,s)):(this._x=0,this._y=Math.atan2(o,f));break;case"XZY":this._z=Math.asin(-Ke(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(d,c),this._y=Math.atan2(o,s)):(this._x=Math.atan2(-h,f),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+e)}return this._order=e,n===!0&&this._onChangeCallback(),this}setFromQuaternion(t,e,n){return Gm.makeRotationFromQuaternion(t),this.setFromRotationMatrix(Gm,e,n)}setFromVector3(t,e=this._order){return this.set(t.x,t.y,t.z,e)}reorder(t){return km.setFromEuler(this),this.setFromQuaternion(km,t)}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._order===this._order}fromArray(t){return this._x=t[0],this._y=t[1],this._z=t[2],t[3]!==void 0&&(this._order=t[3]),this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._order,t}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}toVector3(){console.error("THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead")}}Ca.DefaultOrder="XYZ";Ca.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"];class x2{constructor(){this.mask=1|0}set(t){this.mask=(1<<t|0)>>>0}enable(t){this.mask|=1<<t|0}enableAll(){this.mask=4294967295|0}toggle(t){this.mask^=1<<t|0}disable(t){this.mask&=~(1<<t|0)}disableAll(){this.mask=0}test(t){return(this.mask&t.mask)!=0}isEnabled(t){return(this.mask&(1<<t|0))!=0}}class Pa{constructor(){Pa.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")}set(t,e,n,r,s,a,o,l,c){const h=this.elements;return h[0]=t,h[1]=r,h[2]=o,h[3]=e,h[4]=s,h[5]=l,h[6]=n,h[7]=a,h[8]=c,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(t){const e=this.elements,n=t.elements;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],this}extractBasis(t,e,n){return t.setFromMatrix3Column(this,0),e.setFromMatrix3Column(this,1),n.setFromMatrix3Column(this,2),this}setFromMatrix4(t){const e=t.elements;return this.set(e[0],e[4],e[8],e[1],e[5],e[9],e[2],e[6],e[10]),this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const n=t.elements,r=e.elements,s=this.elements,a=n[0],o=n[3],l=n[6],c=n[1],h=n[4],u=n[7],d=n[2],f=n[5],p=n[8],x=r[0],y=r[3],g=r[6],m=r[1],E=r[4],w=r[7],S=r[2],_=r[5],T=r[8];return s[0]=a*x+o*m+l*S,s[3]=a*y+o*E+l*_,s[6]=a*g+o*w+l*T,s[1]=c*x+h*m+u*S,s[4]=c*y+h*E+u*_,s[7]=c*g+h*w+u*T,s[2]=d*x+f*m+p*S,s[5]=d*y+f*E+p*_,s[8]=d*g+f*w+p*T,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[3]*=t,e[6]*=t,e[1]*=t,e[4]*=t,e[7]*=t,e[2]*=t,e[5]*=t,e[8]*=t,this}determinant(){const t=this.elements,e=t[0],n=t[1],r=t[2],s=t[3],a=t[4],o=t[5],l=t[6],c=t[7],h=t[8];return e*a*h-e*o*c-n*s*h+n*o*l+r*s*c-r*a*l}invert(){const t=this.elements,e=t[0],n=t[1],r=t[2],s=t[3],a=t[4],o=t[5],l=t[6],c=t[7],h=t[8],u=h*a-o*c,d=o*l-h*s,f=c*s-a*l,p=e*u+n*d+r*f;if(p===0)return this.set(0,0,0,0,0,0,0,0,0);const x=1/p;return t[0]=u*x,t[1]=(r*c-h*n)*x,t[2]=(o*n-r*a)*x,t[3]=d*x,t[4]=(h*e-r*l)*x,t[5]=(r*s-o*e)*x,t[6]=f*x,t[7]=(n*l-c*e)*x,t[8]=(a*e-n*s)*x,this}transpose(){let t;const e=this.elements;return t=e[1],e[1]=e[3],e[3]=t,t=e[2],e[2]=e[6],e[6]=t,t=e[5],e[5]=e[7],e[7]=t,this}getNormalMatrix(t){return this.setFromMatrix4(t).invert().transpose()}transposeIntoArray(t){const e=this.elements;return t[0]=e[0],t[1]=e[3],t[2]=e[6],t[3]=e[1],t[4]=e[4],t[5]=e[7],t[6]=e[2],t[7]=e[5],t[8]=e[8],this}setUvTransform(t,e,n,r,s,a,o){const l=Math.cos(s),c=Math.sin(s);return this.set(n*l,n*c,-n*(l*a+c*o)+a+t,-r*c,r*l,-r*(-c*a+l*o)+o+e,0,0,1),this}scale(t,e){const n=this.elements;return n[0]*=t,n[3]*=t,n[6]*=t,n[1]*=e,n[4]*=e,n[7]*=e,this}rotate(t){const e=Math.cos(t),n=Math.sin(t),r=this.elements,s=r[0],a=r[3],o=r[6],l=r[1],c=r[4],h=r[7];return r[0]=e*s+n*l,r[3]=e*a+n*c,r[6]=e*o+n*h,r[1]=-n*s+e*l,r[4]=-n*a+e*c,r[7]=-n*o+e*h,this}translate(t,e){const n=this.elements;return n[0]+=t*n[2],n[3]+=t*n[5],n[6]+=t*n[8],n[1]+=e*n[2],n[4]+=e*n[5],n[7]+=e*n[8],this}equals(t){const e=this.elements,n=t.elements;for(let r=0;r<9;r++)if(e[r]!==n[r])return!1;return!0}fromArray(t,e=0){for(let n=0;n<9;n++)this.elements[n]=t[n+e];return this}toArray(t=[],e=0){const n=this.elements;return t[e]=n[0],t[e+1]=n[1],t[e+2]=n[2],t[e+3]=n[3],t[e+4]=n[4],t[e+5]=n[5],t[e+6]=n[6],t[e+7]=n[7],t[e+8]=n[8],t}clone(){return new this.constructor().fromArray(this.elements)}}let y2=0;const Vm=new it,cs=new Ra,Ki=new li,hl=new it,Da=new it,_2=new it,v2=new Ra,Wm=new it(1,0,0),$m=new it(0,1,0),Xm=new it(0,0,1),M2={type:"added"},qm={type:"removed"};class Mi extends cl{constructor(){super();this.isObject3D=!0,Object.defineProperty(this,"id",{value:y2++}),this.uuid=La(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=Mi.DefaultUp.clone();const t=new it,e=new Ca,n=new Ra,r=new it(1,1,1);function s(){n.setFromEuler(e,!1)}function a(){e.setFromQuaternion(n,void 0,!1)}e._onChange(s),n._onChange(a),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:t},rotation:{configurable:!0,enumerable:!0,value:e},quaternion:{configurable:!0,enumerable:!0,value:n},scale:{configurable:!0,enumerable:!0,value:r},modelViewMatrix:{value:new li},normalMatrix:{value:new Pa}}),this.matrix=new li,this.matrixWorld=new li,this.matrixAutoUpdate=Mi.DefaultMatrixAutoUpdate,this.matrixWorldNeedsUpdate=!1,this.layers=new x2,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeRender(){}onAfterRender(){}applyMatrix4(t){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(t),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(t){return this.quaternion.premultiply(t),this}setRotationFromAxisAngle(t,e){this.quaternion.setFromAxisAngle(t,e)}setRotationFromEuler(t){this.quaternion.setFromEuler(t,!0)}setRotationFromMatrix(t){this.quaternion.setFromRotationMatrix(t)}setRotationFromQuaternion(t){this.quaternion.copy(t)}rotateOnAxis(t,e){return cs.setFromAxisAngle(t,e),this.quaternion.multiply(cs),this}rotateOnWorldAxis(t,e){return cs.setFromAxisAngle(t,e),this.quaternion.premultiply(cs),this}rotateX(t){return this.rotateOnAxis(Wm,t)}rotateY(t){return this.rotateOnAxis($m,t)}rotateZ(t){return this.rotateOnAxis(Xm,t)}translateOnAxis(t,e){return Vm.copy(t).applyQuaternion(this.quaternion),this.position.add(Vm.multiplyScalar(e)),this}translateX(t){return this.translateOnAxis(Wm,t)}translateY(t){return this.translateOnAxis($m,t)}translateZ(t){return this.translateOnAxis(Xm,t)}localToWorld(t){return t.applyMatrix4(this.matrixWorld)}worldToLocal(t){return t.applyMatrix4(Ki.copy(this.matrixWorld).invert())}lookAt(t,e,n){t.isVector3?hl.copy(t):hl.set(t,e,n);const r=this.parent;this.updateWorldMatrix(!0,!1),Da.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?Ki.lookAt(Da,hl,this.up):Ki.lookAt(hl,Da,this.up),this.quaternion.setFromRotationMatrix(Ki),r&&(Ki.extractRotation(r.matrixWorld),cs.setFromRotationMatrix(Ki),this.quaternion.premultiply(cs.invert()))}add(t){if(arguments.length>1){for(let e=0;e<arguments.length;e++)this.add(arguments[e]);return this}return t===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",t),this):(t&&t.isObject3D?(t.parent!==null&&t.parent.remove(t),t.parent=this,this.children.push(t),t.dispatchEvent(M2)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",t),this)}remove(t){if(arguments.length>1){for(let n=0;n<arguments.length;n++)this.remove(arguments[n]);return this}const e=this.children.indexOf(t);return e!==-1&&(t.parent=null,this.children.splice(e,1),t.dispatchEvent(qm)),this}removeFromParent(){const t=this.parent;return t!==null&&t.remove(this),this}clear(){for(let t=0;t<this.children.length;t++){const e=this.children[t];e.parent=null,e.dispatchEvent(qm)}return this.children.length=0,this}attach(t){return this.updateWorldMatrix(!0,!1),Ki.copy(this.matrixWorld).invert(),t.parent!==null&&(t.parent.updateWorldMatrix(!0,!1),Ki.multiply(t.parent.matrixWorld)),t.applyMatrix4(Ki),this.add(t),t.updateWorldMatrix(!1,!0),this}getObjectById(t){return this.getObjectByProperty("id",t)}getObjectByName(t){return this.getObjectByProperty("name",t)}getObjectByProperty(t,e){if(this[t]===e)return this;for(let n=0,r=this.children.length;n<r;n++){const a=this.children[n].getObjectByProperty(t,e);if(a!==void 0)return a}}getWorldPosition(t){return this.updateWorldMatrix(!0,!1),t.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Da,t,_2),t}getWorldScale(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Da,v2,t),t}getWorldDirection(t){this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return t.set(e[8],e[9],e[10]).normalize()}raycast(){}traverse(t){t(this);const e=this.children;for(let n=0,r=e.length;n<r;n++)e[n].traverse(t)}traverseVisible(t){if(this.visible===!1)return;t(this);const e=this.children;for(let n=0,r=e.length;n<r;n++)e[n].traverseVisible(t)}traverseAncestors(t){const e=this.parent;e!==null&&(t(e),e.traverseAncestors(t))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(t){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||t)&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,t=!0);const e=this.children;for(let n=0,r=e.length;n<r;n++)e[n].updateMatrixWorld(t)}updateWorldMatrix(t,e){const n=this.parent;if(t===!0&&n!==null&&n.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),e===!0){const r=this.children;for(let s=0,a=r.length;s<a;s++)r[s].updateWorldMatrix(!1,!0)}}toJSON(t){const e=t===void 0||typeof t=="string",n={};e&&(t={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},n.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});const r={};r.uuid=this.uuid,r.type=this.type,this.name!==""&&(r.name=this.name),this.castShadow===!0&&(r.castShadow=!0),this.receiveShadow===!0&&(r.receiveShadow=!0),this.visible===!1&&(r.visible=!1),this.frustumCulled===!1&&(r.frustumCulled=!1),this.renderOrder!==0&&(r.renderOrder=this.renderOrder),JSON.stringify(this.userData)!=="{}"&&(r.userData=this.userData),r.layers=this.layers.mask,r.matrix=this.matrix.toArray(),this.matrixAutoUpdate===!1&&(r.matrixAutoUpdate=!1),this.isInstancedMesh&&(r.type="InstancedMesh",r.count=this.count,r.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(r.instanceColor=this.instanceColor.toJSON()));function s(o,l){return o[l.uuid]===void 0&&(o[l.uuid]=l.toJSON(t)),l.uuid}if(this.isScene)this.background&&(this.background.isColor?r.background=this.background.toJSON():this.background.isTexture&&(r.background=this.background.toJSON(t).uuid)),this.environment&&this.environment.isTexture&&(r.environment=this.environment.toJSON(t).uuid);else if(this.isMesh||this.isLine||this.isPoints){r.geometry=s(t.geometries,this.geometry);const o=this.geometry.parameters;if(o!==void 0&&o.shapes!==void 0){const l=o.shapes;if(Array.isArray(l))for(let c=0,h=l.length;c<h;c++){const u=l[c];s(t.shapes,u)}else s(t.shapes,l)}}if(this.isSkinnedMesh&&(r.bindMode=this.bindMode,r.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(s(t.skeletons,this.skeleton),r.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const o=[];for(let l=0,c=this.material.length;l<c;l++)o.push(s(t.materials,this.material[l]));r.material=o}else r.material=s(t.materials,this.material);if(this.children.length>0){r.children=[];for(let o=0;o<this.children.length;o++)r.children.push(this.children[o].toJSON(t).object)}if(this.animations.length>0){r.animations=[];for(let o=0;o<this.animations.length;o++){const l=this.animations[o];r.animations.push(s(t.animations,l))}}if(e){const o=a(t.geometries),l=a(t.materials),c=a(t.textures),h=a(t.images),u=a(t.shapes),d=a(t.skeletons),f=a(t.animations),p=a(t.nodes);o.length>0&&(n.geometries=o),l.length>0&&(n.materials=l),c.length>0&&(n.textures=c),h.length>0&&(n.images=h),u.length>0&&(n.shapes=u),d.length>0&&(n.skeletons=d),f.length>0&&(n.animations=f),p.length>0&&(n.nodes=p)}return n.object=r,n;function a(o){const l=[];for(const c in o){const h=o[c];delete h.metadata,l.push(h)}return l}}clone(t){return new this.constructor().copy(this,t)}copy(t,e=!0){if(this.name=t.name,this.up.copy(t.up),this.position.copy(t.position),this.rotation.order=t.rotation.order,this.quaternion.copy(t.quaternion),this.scale.copy(t.scale),this.matrix.copy(t.matrix),this.matrixWorld.copy(t.matrixWorld),this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrixWorldNeedsUpdate=t.matrixWorldNeedsUpdate,this.layers.mask=t.layers.mask,this.visible=t.visible,this.castShadow=t.castShadow,this.receiveShadow=t.receiveShadow,this.frustumCulled=t.frustumCulled,this.renderOrder=t.renderOrder,this.userData=JSON.parse(JSON.stringify(t.userData)),e===!0)for(let n=0;n<t.children.length;n++){const r=t.children[n];this.add(r.clone())}return this}}Mi.DefaultUp=new it(0,1,0);Mi.DefaultMatrixAutoUpdate=!0;const Ym={enabled:!1,files:{},add:function(i,t){this.enabled!==!1&&(this.files[i]=t)},get:function(i){if(this.enabled!==!1)return this.files[i]},remove:function(i){delete this.files[i]},clear:function(){this.files={}}};class b2{constructor(t,e,n){const r=this;let s=!1,a=0,o=0,l;const c=[];this.onStart=void 0,this.onLoad=t,this.onProgress=e,this.onError=n,this.itemStart=function(h){o++,s===!1&&r.onStart!==void 0&&r.onStart(h,a,o),s=!0},this.itemEnd=function(h){a++,r.onProgress!==void 0&&r.onProgress(h,a,o),a===o&&(s=!1,r.onLoad!==void 0&&r.onLoad())},this.itemError=function(h){r.onError!==void 0&&r.onError(h)},this.resolveURL=function(h){return l?l(h):h},this.setURLModifier=function(h){return l=h,this},this.addHandler=function(h,u){return c.push(h,u),this},this.removeHandler=function(h){const u=c.indexOf(h);return u!==-1&&c.splice(u,2),this},this.getHandler=function(h){for(let u=0,d=c.length;u<d;u+=2){const f=c[u],p=c[u+1];if(f.global&&(f.lastIndex=0),f.test(h))return p}return null}}}const w2=new b2;class jm{constructor(t){this.manager=t!==void 0?t:w2,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(t,e){const n=this;return new Promise(function(r,s){n.load(t,r,e,s)})}parse(){}setCrossOrigin(t){return this.crossOrigin=t,this}setWithCredentials(t){return this.withCredentials=t,this}setPath(t){return this.path=t,this}setResourcePath(t){return this.resourcePath=t,this}setRequestHeader(t){return this.requestHeader=t,this}}function S2(i){for(let t=i.length-1;t>=0;--t)if(i[t]>65535)return!0;return!1}function ru(i){return document.createElementNS("http://www.w3.org/1999/xhtml",i)}class E2 extends jm{constructor(t){super(t)}load(t,e,n,r){this.path!==void 0&&(t=this.path+t),t=this.manager.resolveURL(t);const s=this,a=Ym.get(t);if(a!==void 0)return s.manager.itemStart(t),setTimeout(function(){e&&e(a),s.manager.itemEnd(t)},0),a;const o=ru("img");function l(){h(),Ym.add(t,this),e&&e(this),s.manager.itemEnd(t)}function c(u){h(),r&&r(u),s.manager.itemError(t),s.manager.itemEnd(t)}function h(){o.removeEventListener("load",l,!1),o.removeEventListener("error",c,!1)}return o.addEventListener("load",l,!1),o.addEventListener("error",c,!1),t.slice(0,5)!=="data:"&&this.crossOrigin!==void 0&&(o.crossOrigin=this.crossOrigin),s.manager.itemStart(t),o.src=t,o}}class pe{constructor(t=0,e=0){pe.prototype.isVector2=!0,this.x=t,this.y=e}get width(){return this.x}set width(t){this.x=t}get height(){return this.y}set height(t){this.y=t}set(t,e){return this.x=t,this.y=e,this}setScalar(t){return this.x=t,this.y=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y)}copy(t){return this.x=t.x,this.y=t.y,this}add(t,e){return e!==void 0?(console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this)}addScalar(t){return this.x+=t,this.y+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this}sub(t,e){return e!==void 0?(console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this)}subScalar(t){return this.x-=t,this.y-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this}multiply(t){return this.x*=t.x,this.y*=t.y,this}multiplyScalar(t){return this.x*=t,this.y*=t,this}divide(t){return this.x/=t.x,this.y/=t.y,this}divideScalar(t){return this.multiplyScalar(1/t)}applyMatrix3(t){const e=this.x,n=this.y,r=t.elements;return this.x=r[0]*e+r[3]*n+r[6],this.y=r[1]*e+r[4]*n+r[7],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,n=this.y-t.y;return e*e+n*n}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this}equals(t){return t.x===this.x&&t.y===this.y}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t}fromBufferAttribute(t,e,n){return n!==void 0&&console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this}rotateAround(t,e){const n=Math.cos(e),r=Math.sin(e),s=this.x-t.x,a=this.y-t.y;return this.x=s*n-a*r+t.x,this.y=s*r+a*n+t.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}function ir(i){return i<.04045?i*.0773993808:Math.pow(i*.9478672986+.0521327014,2.4)}function ul(i){return i<.0031308?i*12.92:1.055*Math.pow(i,.41666)-.055}const su={[Qi]:{[er]:ir},[er]:{[Qi]:ul}},bi={legacyMode:!0,get workingColorSpace(){return er},set workingColorSpace(i){console.warn("THREE.ColorManagement: .workingColorSpace is readonly.")},convert:function(i,t,e){if(this.legacyMode||t===e||!t||!e)return i;if(su[t]&&su[t][e]!==void 0){const n=su[t][e];return i.r=n(i.r),i.g=n(i.g),i.b=n(i.b),i}throw new Error("Unsupported color space conversion.")},fromWorkingColorSpace:function(i,t){return this.convert(i,this.workingColorSpace,t)},toWorkingColorSpace:function(i,t){return this.convert(i,t,this.workingColorSpace)}},Zm={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},me={r:0,g:0,b:0},wi={h:0,s:0,l:0},dl={h:0,s:0,l:0};function au(i,t,e){return e<0&&(e+=1),e>1&&(e-=1),e<1/6?i+(t-i)*6*e:e<1/2?t:e<2/3?i+(t-i)*6*(2/3-e):i}function fl(i,t){return t.r=i.r,t.g=i.g,t.b=i.b,t}class nr{constructor(t,e,n){return this.isColor=!0,this.r=1,this.g=1,this.b=1,e===void 0&&n===void 0?this.set(t):this.setRGB(t,e,n)}set(t){return t&&t.isColor?this.copy(t):typeof t=="number"?this.setHex(t):typeof t=="string"&&this.setStyle(t),this}setScalar(t){return this.r=t,this.g=t,this.b=t,this}setHex(t,e=Qi){return t=Math.floor(t),this.r=(t>>16&255)/255,this.g=(t>>8&255)/255,this.b=(t&255)/255,bi.toWorkingColorSpace(this,e),this}setRGB(t,e,n,r=er){return this.r=t,this.g=e,this.b=n,bi.toWorkingColorSpace(this,r),this}setHSL(t,e,n,r=er){if(t=p2(t,1),e=Ke(e,0,1),n=Ke(n,0,1),e===0)this.r=this.g=this.b=n;else{const s=n<=.5?n*(1+e):n+e-n*e,a=2*n-s;this.r=au(a,s,t+1/3),this.g=au(a,s,t),this.b=au(a,s,t-1/3)}return bi.toWorkingColorSpace(this,r),this}setStyle(t,e=Qi){function n(s){s!==void 0&&parseFloat(s)<1&&console.warn("THREE.Color: Alpha component of "+t+" will be ignored.")}let r;if(r=/^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t)){let s;const a=r[1],o=r[2];switch(a){case"rgb":case"rgba":if(s=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return this.r=Math.min(255,parseInt(s[1],10))/255,this.g=Math.min(255,parseInt(s[2],10))/255,this.b=Math.min(255,parseInt(s[3],10))/255,bi.toWorkingColorSpace(this,e),n(s[4]),this;if(s=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return this.r=Math.min(100,parseInt(s[1],10))/100,this.g=Math.min(100,parseInt(s[2],10))/100,this.b=Math.min(100,parseInt(s[3],10))/100,bi.toWorkingColorSpace(this,e),n(s[4]),this;break;case"hsl":case"hsla":if(s=/^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)){const l=parseFloat(s[1])/360,c=parseInt(s[2],10)/100,h=parseInt(s[3],10)/100;return n(s[4]),this.setHSL(l,c,h,e)}break}}else if(r=/^\#([A-Fa-f\d]+)$/.exec(t)){const s=r[1],a=s.length;if(a===3)return this.r=parseInt(s.charAt(0)+s.charAt(0),16)/255,this.g=parseInt(s.charAt(1)+s.charAt(1),16)/255,this.b=parseInt(s.charAt(2)+s.charAt(2),16)/255,bi.toWorkingColorSpace(this,e),this;if(a===6)return this.r=parseInt(s.charAt(0)+s.charAt(1),16)/255,this.g=parseInt(s.charAt(2)+s.charAt(3),16)/255,this.b=parseInt(s.charAt(4)+s.charAt(5),16)/255,bi.toWorkingColorSpace(this,e),this}return t&&t.length>0?this.setColorName(t,e):this}setColorName(t,e=Qi){const n=Zm[t.toLowerCase()];return n!==void 0?this.setHex(n,e):console.warn("THREE.Color: Unknown color "+t),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(t){return this.r=t.r,this.g=t.g,this.b=t.b,this}copySRGBToLinear(t){return this.r=ir(t.r),this.g=ir(t.g),this.b=ir(t.b),this}copyLinearToSRGB(t){return this.r=ul(t.r),this.g=ul(t.g),this.b=ul(t.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(t=Qi){return bi.fromWorkingColorSpace(fl(this,me),t),Ke(me.r*255,0,255)<<16^Ke(me.g*255,0,255)<<8^Ke(me.b*255,0,255)<<0}getHexString(t=Qi){return("000000"+this.getHex(t).toString(16)).slice(-6)}getHSL(t,e=er){bi.fromWorkingColorSpace(fl(this,me),e);const n=me.r,r=me.g,s=me.b,a=Math.max(n,r,s),o=Math.min(n,r,s);let l,c;const h=(o+a)/2;if(o===a)l=0,c=0;else{const u=a-o;switch(c=h<=.5?u/(a+o):u/(2-a-o),a){case n:l=(r-s)/u+(r<s?6:0);break;case r:l=(s-n)/u+2;break;case s:l=(n-r)/u+4;break}l/=6}return t.h=l,t.s=c,t.l=h,t}getRGB(t,e=er){return bi.fromWorkingColorSpace(fl(this,me),e),t.r=me.r,t.g=me.g,t.b=me.b,t}getStyle(t=Qi){return bi.fromWorkingColorSpace(fl(this,me),t),t!==Qi?`color(${t} ${me.r} ${me.g} ${me.b})`:`rgb(${me.r*255|0},${me.g*255|0},${me.b*255|0})`}offsetHSL(t,e,n){return this.getHSL(wi),wi.h+=t,wi.s+=e,wi.l+=n,this.setHSL(wi.h,wi.s,wi.l),this}add(t){return this.r+=t.r,this.g+=t.g,this.b+=t.b,this}addColors(t,e){return this.r=t.r+e.r,this.g=t.g+e.g,this.b=t.b+e.b,this}addScalar(t){return this.r+=t,this.g+=t,this.b+=t,this}sub(t){return this.r=Math.max(0,this.r-t.r),this.g=Math.max(0,this.g-t.g),this.b=Math.max(0,this.b-t.b),this}multiply(t){return this.r*=t.r,this.g*=t.g,this.b*=t.b,this}multiplyScalar(t){return this.r*=t,this.g*=t,this.b*=t,this}lerp(t,e){return this.r+=(t.r-this.r)*e,this.g+=(t.g-this.g)*e,this.b+=(t.b-this.b)*e,this}lerpColors(t,e,n){return this.r=t.r+(e.r-t.r)*n,this.g=t.g+(e.g-t.g)*n,this.b=t.b+(e.b-t.b)*n,this}lerpHSL(t,e){this.getHSL(wi),t.getHSL(dl);const n=iu(wi.h,dl.h,e),r=iu(wi.s,dl.s,e),s=iu(wi.l,dl.l,e);return this.setHSL(n,r,s),this}equals(t){return t.r===this.r&&t.g===this.g&&t.b===this.b}fromArray(t,e=0){return this.r=t[e],this.g=t[e+1],this.b=t[e+2],this}toArray(t=[],e=0){return t[e]=this.r,t[e+1]=this.g,t[e+2]=this.b,t}fromBufferAttribute(t,e){return this.r=t.getX(e),this.g=t.getY(e),this.b=t.getZ(e),t.normalized===!0&&(this.r/=255,this.g/=255,this.b/=255),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}nr.NAMES=Zm;let hs;class A2{static getDataURL(t){if(/^data:/i.test(t.src)||typeof HTMLCanvasElement=="undefined")return t.src;let e;if(t instanceof HTMLCanvasElement)e=t;else{hs===void 0&&(hs=ru("canvas")),hs.width=t.width,hs.height=t.height;const n=hs.getContext("2d");t instanceof ImageData?n.putImageData(t,0,0):n.drawImage(t,0,0,t.width,t.height),e=hs}return e.width>2048||e.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",t),e.toDataURL("image/jpeg",.6)):e.toDataURL("image/png")}static sRGBToLinear(t){if(typeof HTMLImageElement!="undefined"&&t instanceof HTMLImageElement||typeof HTMLCanvasElement!="undefined"&&t instanceof HTMLCanvasElement||typeof ImageBitmap!="undefined"&&t instanceof ImageBitmap){const e=ru("canvas");e.width=t.width,e.height=t.height;const n=e.getContext("2d");n.drawImage(t,0,0,t.width,t.height);const r=n.getImageData(0,0,t.width,t.height),s=r.data;for(let a=0;a<s.length;a++)s[a]=ir(s[a]/255)*255;return n.putImageData(r,0,0),e}else if(t.data){const e=t.data.slice(0);for(let n=0;n<e.length;n++)e instanceof Uint8Array||e instanceof Uint8ClampedArray?e[n]=Math.floor(ir(e[n]/255)*255):e[n]=ir(e[n]);return{data:e,width:t.width,height:t.height}}else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),t}}class T2{constructor(t=null){this.isSource=!0,this.uuid=La(),this.data=t,this.version=0}set needsUpdate(t){t===!0&&this.version++}toJSON(t){const e=t===void 0||typeof t=="string";if(!e&&t.images[this.uuid]!==void 0)return t.images[this.uuid];const n={uuid:this.uuid,url:""},r=this.data;if(r!==null){let s;if(Array.isArray(r)){s=[];for(let a=0,o=r.length;a<o;a++)r[a].isDataTexture?s.push(ou(r[a].image)):s.push(ou(r[a]))}else s=ou(r);n.url=s}return e||(t.images[this.uuid]=n),n}}function ou(i){return typeof HTMLImageElement!="undefined"&&i instanceof HTMLImageElement||typeof HTMLCanvasElement!="undefined"&&i instanceof HTMLCanvasElement||typeof ImageBitmap!="undefined"&&i instanceof ImageBitmap?A2.getDataURL(i):i.data?{data:Array.from(i.data),width:i.width,height:i.height,type:i.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}let L2=0;class rr extends cl{constructor(t=rr.DEFAULT_IMAGE,e=rr.DEFAULT_MAPPING,n=ol,r=ol,s=Om,a=c2,o=u2,l=h2,c=1,h=d2){super();this.isTexture=!0,Object.defineProperty(this,"id",{value:L2++}),this.uuid=La(),this.name="",this.source=new T2(t),this.mipmaps=[],this.mapping=e,this.wrapS=n,this.wrapT=r,this.magFilter=s,this.minFilter=a,this.anisotropy=c,this.format=o,this.internalFormat=null,this.type=l,this.offset=new pe(0,0),this.repeat=new pe(1,1),this.center=new pe(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new Pa,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.encoding=h,this.userData={},this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1,this.needsPMREMUpdate=!1}get image(){return this.source.data}set image(t){this.source.data=t}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(t){return this.name=t.name,this.source=t.source,this.mipmaps=t.mipmaps.slice(0),this.mapping=t.mapping,this.wrapS=t.wrapS,this.wrapT=t.wrapT,this.magFilter=t.magFilter,this.minFilter=t.minFilter,this.anisotropy=t.anisotropy,this.format=t.format,this.internalFormat=t.internalFormat,this.type=t.type,this.offset.copy(t.offset),this.repeat.copy(t.repeat),this.center.copy(t.center),this.rotation=t.rotation,this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrix.copy(t.matrix),this.generateMipmaps=t.generateMipmaps,this.premultiplyAlpha=t.premultiplyAlpha,this.flipY=t.flipY,this.unpackAlignment=t.unpackAlignment,this.encoding=t.encoding,this.userData=JSON.parse(JSON.stringify(t.userData)),this.needsUpdate=!0,this}toJSON(t){const e=t===void 0||typeof t=="string";if(!e&&t.textures[this.uuid]!==void 0)return t.textures[this.uuid];const n={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(t).uuid,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return JSON.stringify(this.userData)!=="{}"&&(n.userData=this.userData),e||(t.textures[this.uuid]=n),n}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(t){if(this.mapping!==zm)return t;if(t.applyMatrix3(this.matrix),t.x<0||t.x>1)switch(this.wrapS){case Nm:t.x=t.x-Math.floor(t.x);break;case ol:t.x=t.x<0?0:1;break;case Bm:Math.abs(Math.floor(t.x)%2)===1?t.x=Math.ceil(t.x)-t.x:t.x=t.x-Math.floor(t.x);break}if(t.y<0||t.y>1)switch(this.wrapT){case Nm:t.y=t.y-Math.floor(t.y);break;case ol:t.y=t.y<0?0:1;break;case Bm:Math.abs(Math.floor(t.y)%2)===1?t.y=Math.ceil(t.y)-t.y:t.y=t.y-Math.floor(t.y);break}return this.flipY&&(t.y=1-t.y),t}set needsUpdate(t){t===!0&&(this.version++,this.source.needsUpdate=!0)}}rr.DEFAULT_IMAGE=null;rr.DEFAULT_MAPPING=zm;class R2 extends jm{constructor(t){super(t)}load(t,e,n,r){const s=new rr,a=new E2(this.manager);return a.setCrossOrigin(this.crossOrigin),a.setPath(this.path),a.load(t,function(o){s.image=o,s.needsUpdate=!0,e!==void 0&&e(s)},n,r),s}}let C2=0;class lu extends cl{constructor(){super();this.isMaterial=!0,Object.defineProperty(this,"id",{value:C2++}),this.uuid=La(),this.name="",this.type="Material",this.blending=Fm,this.side=Pm,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.blendSrc=a2,this.blendDst=o2,this.blendEquation=s2,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=l2,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=f2,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=eu,this.stencilZFail=eu,this.stencilZPass=eu,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(t){this._alphaTest>0!=t>0&&this.version++,this._alphaTest=t}onBuild(){}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(t){if(t!==void 0)for(const e in t){const n=t[e];if(n===void 0){console.warn("THREE.Material: '"+e+"' parameter is undefined.");continue}if(e==="shading"){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=n===r2;continue}const r=this[e];if(r===void 0){console.warn("THREE."+this.type+": '"+e+"' is not a property of this material.");continue}r&&r.isColor?r.set(n):r&&r.isVector3&&n&&n.isVector3?r.copy(n):this[e]=n}}toJSON(t){const e=t===void 0||typeof t=="string";e&&(t={textures:{},images:{}});const n={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};n.uuid=this.uuid,n.type=this.type,this.name!==""&&(n.name=this.name),this.color&&this.color.isColor&&(n.color=this.color.getHex()),this.roughness!==void 0&&(n.roughness=this.roughness),this.metalness!==void 0&&(n.metalness=this.metalness),this.sheen!==void 0&&(n.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(n.sheenColor=this.sheenColor.getHex()),this.sheenRoughness!==void 0&&(n.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(n.emissive=this.emissive.getHex()),this.emissiveIntensity&&this.emissiveIntensity!==1&&(n.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(n.specular=this.specular.getHex()),this.specularIntensity!==void 0&&(n.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(n.specularColor=this.specularColor.getHex()),this.shininess!==void 0&&(n.shininess=this.shininess),this.clearcoat!==void 0&&(n.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(n.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(n.clearcoatMap=this.clearcoatMap.toJSON(t).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(n.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(t).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(n.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(t).uuid,n.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.iridescence!==void 0&&(n.iridescence=this.iridescence),this.iridescenceIOR!==void 0&&(n.iridescenceIOR=this.iridescenceIOR),this.iridescenceThicknessRange!==void 0&&(n.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(n.iridescenceMap=this.iridescenceMap.toJSON(t).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(n.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(t).uuid),this.map&&this.map.isTexture&&(n.map=this.map.toJSON(t).uuid),this.matcap&&this.matcap.isTexture&&(n.matcap=this.matcap.toJSON(t).uuid),this.alphaMap&&this.alphaMap.isTexture&&(n.alphaMap=this.alphaMap.toJSON(t).uuid),this.lightMap&&this.lightMap.isTexture&&(n.lightMap=this.lightMap.toJSON(t).uuid,n.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(n.aoMap=this.aoMap.toJSON(t).uuid,n.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(n.bumpMap=this.bumpMap.toJSON(t).uuid,n.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(n.normalMap=this.normalMap.toJSON(t).uuid,n.normalMapType=this.normalMapType,n.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(n.displacementMap=this.displacementMap.toJSON(t).uuid,n.displacementScale=this.displacementScale,n.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(n.roughnessMap=this.roughnessMap.toJSON(t).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(n.metalnessMap=this.metalnessMap.toJSON(t).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(n.emissiveMap=this.emissiveMap.toJSON(t).uuid),this.specularMap&&this.specularMap.isTexture&&(n.specularMap=this.specularMap.toJSON(t).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(n.specularIntensityMap=this.specularIntensityMap.toJSON(t).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(n.specularColorMap=this.specularColorMap.toJSON(t).uuid),this.envMap&&this.envMap.isTexture&&(n.envMap=this.envMap.toJSON(t).uuid,this.combine!==void 0&&(n.combine=this.combine)),this.envMapIntensity!==void 0&&(n.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(n.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(n.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(n.gradientMap=this.gradientMap.toJSON(t).uuid),this.transmission!==void 0&&(n.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(n.transmissionMap=this.transmissionMap.toJSON(t).uuid),this.thickness!==void 0&&(n.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(n.thicknessMap=this.thicknessMap.toJSON(t).uuid),this.attenuationDistance!==void 0&&(n.attenuationDistance=this.attenuationDistance),this.attenuationColor!==void 0&&(n.attenuationColor=this.attenuationColor.getHex()),this.size!==void 0&&(n.size=this.size),this.shadowSide!==null&&(n.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(n.sizeAttenuation=this.sizeAttenuation),this.blending!==Fm&&(n.blending=this.blending),this.side!==Pm&&(n.side=this.side),this.vertexColors&&(n.vertexColors=!0),this.opacity<1&&(n.opacity=this.opacity),this.transparent===!0&&(n.transparent=this.transparent),n.depthFunc=this.depthFunc,n.depthTest=this.depthTest,n.depthWrite=this.depthWrite,n.colorWrite=this.colorWrite,n.stencilWrite=this.stencilWrite,n.stencilWriteMask=this.stencilWriteMask,n.stencilFunc=this.stencilFunc,n.stencilRef=this.stencilRef,n.stencilFuncMask=this.stencilFuncMask,n.stencilFail=this.stencilFail,n.stencilZFail=this.stencilZFail,n.stencilZPass=this.stencilZPass,this.rotation!==void 0&&this.rotation!==0&&(n.rotation=this.rotation),this.polygonOffset===!0&&(n.polygonOffset=!0),this.polygonOffsetFactor!==0&&(n.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(n.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth!==void 0&&this.linewidth!==1&&(n.linewidth=this.linewidth),this.dashSize!==void 0&&(n.dashSize=this.dashSize),this.gapSize!==void 0&&(n.gapSize=this.gapSize),this.scale!==void 0&&(n.scale=this.scale),this.dithering===!0&&(n.dithering=!0),this.alphaTest>0&&(n.alphaTest=this.alphaTest),this.alphaToCoverage===!0&&(n.alphaToCoverage=this.alphaToCoverage),this.premultipliedAlpha===!0&&(n.premultipliedAlpha=this.premultipliedAlpha),this.wireframe===!0&&(n.wireframe=this.wireframe),this.wireframeLinewidth>1&&(n.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(n.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(n.wireframeLinejoin=this.wireframeLinejoin),this.flatShading===!0&&(n.flatShading=this.flatShading),this.visible===!1&&(n.visible=!1),this.toneMapped===!1&&(n.toneMapped=!1),this.fog===!1&&(n.fog=!1),JSON.stringify(this.userData)!=="{}"&&(n.userData=this.userData);function r(s){const a=[];for(const o in s){const l=s[o];delete l.metadata,a.push(l)}return a}if(e){const s=r(t.textures),a=r(t.images);s.length>0&&(n.textures=s),a.length>0&&(n.images=a)}return n}clone(){return new this.constructor().copy(this)}copy(t){this.name=t.name,this.blending=t.blending,this.side=t.side,this.vertexColors=t.vertexColors,this.opacity=t.opacity,this.transparent=t.transparent,this.blendSrc=t.blendSrc,this.blendDst=t.blendDst,this.blendEquation=t.blendEquation,this.blendSrcAlpha=t.blendSrcAlpha,this.blendDstAlpha=t.blendDstAlpha,this.blendEquationAlpha=t.blendEquationAlpha,this.depthFunc=t.depthFunc,this.depthTest=t.depthTest,this.depthWrite=t.depthWrite,this.stencilWriteMask=t.stencilWriteMask,this.stencilFunc=t.stencilFunc,this.stencilRef=t.stencilRef,this.stencilFuncMask=t.stencilFuncMask,this.stencilFail=t.stencilFail,this.stencilZFail=t.stencilZFail,this.stencilZPass=t.stencilZPass,this.stencilWrite=t.stencilWrite;const e=t.clippingPlanes;let n=null;if(e!==null){const r=e.length;n=new Array(r);for(let s=0;s!==r;++s)n[s]=e[s].clone()}return this.clippingPlanes=n,this.clipIntersection=t.clipIntersection,this.clipShadows=t.clipShadows,this.shadowSide=t.shadowSide,this.colorWrite=t.colorWrite,this.precision=t.precision,this.polygonOffset=t.polygonOffset,this.polygonOffsetFactor=t.polygonOffsetFactor,this.polygonOffsetUnits=t.polygonOffsetUnits,this.dithering=t.dithering,this.alphaTest=t.alphaTest,this.alphaToCoverage=t.alphaToCoverage,this.premultipliedAlpha=t.premultipliedAlpha,this.visible=t.visible,this.toneMapped=t.toneMapped,this.userData=JSON.parse(JSON.stringify(t.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(t){t===!0&&this.version++}}class Fa extends lu{constructor(t){super();this.isMeshBasicMaterial=!0,this.type="MeshBasicMaterial",this.color=new nr(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=Im,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.fog=t.fog,this}}class P2 extends lu{constructor(t){super();this.isMeshLambertMaterial=!0,this.type="MeshLambertMaterial",this.color=new nr(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new nr(0),this.emissiveIntensity=1,this.emissiveMap=null,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=Im,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.fog=t.fog,this}}class us{constructor(t=new it(1/0,1/0,1/0),e=new it(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=t,this.max=e}set(t,e){return this.min.copy(t),this.max.copy(e),this}setFromArray(t){let e=1/0,n=1/0,r=1/0,s=-1/0,a=-1/0,o=-1/0;for(let l=0,c=t.length;l<c;l+=3){const h=t[l],u=t[l+1],d=t[l+2];h<e&&(e=h),u<n&&(n=u),d<r&&(r=d),h>s&&(s=h),u>a&&(a=u),d>o&&(o=d)}return this.min.set(e,n,r),this.max.set(s,a,o),this}setFromBufferAttribute(t){let e=1/0,n=1/0,r=1/0,s=-1/0,a=-1/0,o=-1/0;for(let l=0,c=t.count;l<c;l++){const h=t.getX(l),u=t.getY(l),d=t.getZ(l);h<e&&(e=h),u<n&&(n=u),d<r&&(r=d),h>s&&(s=h),u>a&&(a=u),d>o&&(o=d)}return this.min.set(e,n,r),this.max.set(s,a,o),this}setFromPoints(t){this.makeEmpty();for(let e=0,n=t.length;e<n;e++)this.expandByPoint(t[e]);return this}setFromCenterAndSize(t,e){const n=sr.copy(e).multiplyScalar(.5);return this.min.copy(t).sub(n),this.max.copy(t).add(n),this}setFromObject(t,e=!1){return this.makeEmpty(),this.expandByObject(t,e)}clone(){return new this.constructor().copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(t){return this.isEmpty()?t.set(0,0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return this.isEmpty()?t.set(0,0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}expandByObject(t,e=!1){t.updateWorldMatrix(!1,!1);const n=t.geometry;if(n!==void 0)if(e&&n.attributes!=null&&n.attributes.position!==void 0){const s=n.attributes.position;for(let a=0,o=s.count;a<o;a++)sr.fromBufferAttribute(s,a).applyMatrix4(t.matrixWorld),this.expandByPoint(sr)}else n.boundingBox===null&&n.computeBoundingBox(),cu.copy(n.boundingBox),cu.applyMatrix4(t.matrixWorld),this.union(cu);const r=t.children;for(let s=0,a=r.length;s<a;s++)this.expandByObject(r[s],e);return this}containsPoint(t){return!(t.x<this.min.x||t.x>this.max.x||t.y<this.min.y||t.y>this.max.y||t.z<this.min.z||t.z>this.max.z)}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y&&this.min.z<=t.min.z&&t.max.z<=this.max.z}getParameter(t,e){return e.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y),(t.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(t){return!(t.max.x<this.min.x||t.min.x>this.max.x||t.max.y<this.min.y||t.min.y>this.max.y||t.max.z<this.min.z||t.min.z>this.max.z)}intersectsSphere(t){return this.clampPoint(t.center,sr),sr.distanceToSquared(t.center)<=t.radius*t.radius}intersectsPlane(t){let e,n;return t.normal.x>0?(e=t.normal.x*this.min.x,n=t.normal.x*this.max.x):(e=t.normal.x*this.max.x,n=t.normal.x*this.min.x),t.normal.y>0?(e+=t.normal.y*this.min.y,n+=t.normal.y*this.max.y):(e+=t.normal.y*this.max.y,n+=t.normal.y*this.min.y),t.normal.z>0?(e+=t.normal.z*this.min.z,n+=t.normal.z*this.max.z):(e+=t.normal.z*this.max.z,n+=t.normal.z*this.min.z),e<=-t.constant&&n>=-t.constant}intersectsTriangle(t){if(this.isEmpty())return!1;this.getCenter(Ia),pl.subVectors(this.max,Ia),ds.subVectors(t.a,Ia),fs.subVectors(t.b,Ia),ps.subVectors(t.c,Ia),In.subVectors(fs,ds),zn.subVectors(ps,fs),ar.subVectors(ds,ps);let e=[0,-In.z,In.y,0,-zn.z,zn.y,0,-ar.z,ar.y,In.z,0,-In.x,zn.z,0,-zn.x,ar.z,0,-ar.x,-In.y,In.x,0,-zn.y,zn.x,0,-ar.y,ar.x,0];return!hu(e,ds,fs,ps,pl)||(e=[1,0,0,0,1,0,0,0,1],!hu(e,ds,fs,ps,pl))?!1:(ml.crossVectors(In,zn),e=[ml.x,ml.y,ml.z],hu(e,ds,fs,ps,pl))}clampPoint(t,e){return e.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return sr.copy(t).clamp(this.min,this.max).sub(t).length()}getBoundingSphere(t){return this.getCenter(t.center),t.radius=this.getSize(sr).length()*.5,t}intersect(t){return this.min.max(t.min),this.max.min(t.max),this.isEmpty()&&this.makeEmpty(),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}applyMatrix4(t){return this.isEmpty()?this:(tn[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(t),tn[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(t),tn[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(t),tn[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(t),tn[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(t),tn[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(t),tn[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(t),tn[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(t),this.setFromPoints(tn),this)}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}}const tn=[new it,new it,new it,new it,new it,new it,new it,new it],sr=new it,cu=new us,ds=new it,fs=new it,ps=new it,In=new it,zn=new it,ar=new it,Ia=new it,pl=new it,ml=new it,or=new it;function hu(i,t,e,n,r){for(let s=0,a=i.length-3;s<=a;s+=3){or.fromArray(i,s);const o=r.x*Math.abs(or.x)+r.y*Math.abs(or.y)+r.z*Math.abs(or.z),l=t.dot(or),c=e.dot(or),h=n.dot(or);if(Math.max(-Math.max(l,c,h),Math.min(l,c,h))>o)return!1}return!0}const D2=new us,Jm=new it,gl=new it,uu=new it;class du{constructor(t=new it,e=-1){this.center=t,this.radius=e}set(t,e){return this.center.copy(t),this.radius=e,this}setFromPoints(t,e){const n=this.center;e!==void 0?n.copy(e):D2.setFromPoints(t).getCenter(n);let r=0;for(let s=0,a=t.length;s<a;s++)r=Math.max(r,n.distanceToSquared(t[s]));return this.radius=Math.sqrt(r),this}copy(t){return this.center.copy(t.center),this.radius=t.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(t){return t.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(t){return t.distanceTo(this.center)-this.radius}intersectsSphere(t){const e=this.radius+t.radius;return t.center.distanceToSquared(this.center)<=e*e}intersectsBox(t){return t.intersectsSphere(this)}intersectsPlane(t){return Math.abs(t.distanceToPoint(this.center))<=this.radius}clampPoint(t,e){const n=this.center.distanceToSquared(t);return e.copy(t),n>this.radius*this.radius&&(e.sub(this.center).normalize(),e.multiplyScalar(this.radius).add(this.center)),e}getBoundingBox(t){return this.isEmpty()?(t.makeEmpty(),t):(t.set(this.center,this.center),t.expandByScalar(this.radius),t)}applyMatrix4(t){return this.center.applyMatrix4(t),this.radius=this.radius*t.getMaxScaleOnAxis(),this}translate(t){return this.center.add(t),this}expandByPoint(t){uu.subVectors(t,this.center);const e=uu.lengthSq();if(e>this.radius*this.radius){const n=Math.sqrt(e),r=(n-this.radius)*.5;this.center.add(uu.multiplyScalar(r/n)),this.radius+=r}return this}union(t){return this.center.equals(t.center)===!0?gl.set(0,0,1).multiplyScalar(t.radius):gl.subVectors(t.center,this.center).normalize().multiplyScalar(t.radius),this.expandByPoint(Jm.copy(t.center).add(gl)),this.expandByPoint(Jm.copy(t.center).sub(gl)),this}equals(t){return t.center.equals(this.center)&&t.radius===this.radius}clone(){return new this.constructor().copy(this)}}const en=new it,fu=new it,xl=new it,Nn=new it,pu=new it,yl=new it,mu=new it;class Qm{constructor(t=new it,e=new it(0,0,-1)){this.origin=t,this.direction=e}set(t,e){return this.origin.copy(t),this.direction.copy(e),this}copy(t){return this.origin.copy(t.origin),this.direction.copy(t.direction),this}at(t,e){return e.copy(this.direction).multiplyScalar(t).add(this.origin)}lookAt(t){return this.direction.copy(t).sub(this.origin).normalize(),this}recast(t){return this.origin.copy(this.at(t,en)),this}closestPointToPoint(t,e){e.subVectors(t,this.origin);const n=e.dot(this.direction);return n<0?e.copy(this.origin):e.copy(this.direction).multiplyScalar(n).add(this.origin)}distanceToPoint(t){return Math.sqrt(this.distanceSqToPoint(t))}distanceSqToPoint(t){const e=en.subVectors(t,this.origin).dot(this.direction);return e<0?this.origin.distanceToSquared(t):(en.copy(this.direction).multiplyScalar(e).add(this.origin),en.distanceToSquared(t))}distanceSqToSegment(t,e,n,r){fu.copy(t).add(e).multiplyScalar(.5),xl.copy(e).sub(t).normalize(),Nn.copy(this.origin).sub(fu);const s=t.distanceTo(e)*.5,a=-this.direction.dot(xl),o=Nn.dot(this.direction),l=-Nn.dot(xl),c=Nn.lengthSq(),h=Math.abs(1-a*a);let u,d,f,p;if(h>0)if(u=a*l-o,d=a*o-l,p=s*h,u>=0)if(d>=-p)if(d<=p){const x=1/h;u*=x,d*=x,f=u*(u+a*d+2*o)+d*(a*u+d+2*l)+c}else d=s,u=Math.max(0,-(a*d+o)),f=-u*u+d*(d+2*l)+c;else d=-s,u=Math.max(0,-(a*d+o)),f=-u*u+d*(d+2*l)+c;else d<=-p?(u=Math.max(0,-(-a*s+o)),d=u>0?-s:Math.min(Math.max(-s,-l),s),f=-u*u+d*(d+2*l)+c):d<=p?(u=0,d=Math.min(Math.max(-s,-l),s),f=d*(d+2*l)+c):(u=Math.max(0,-(a*s+o)),d=u>0?s:Math.min(Math.max(-s,-l),s),f=-u*u+d*(d+2*l)+c);else d=a>0?-s:s,u=Math.max(0,-(a*d+o)),f=-u*u+d*(d+2*l)+c;return n&&n.copy(this.direction).multiplyScalar(u).add(this.origin),r&&r.copy(xl).multiplyScalar(d).add(fu),f}intersectSphere(t,e){en.subVectors(t.center,this.origin);const n=en.dot(this.direction),r=en.dot(en)-n*n,s=t.radius*t.radius;if(r>s)return null;const a=Math.sqrt(s-r),o=n-a,l=n+a;return o<0&&l<0?null:o<0?this.at(l,e):this.at(o,e)}intersectsSphere(t){return this.distanceSqToPoint(t.center)<=t.radius*t.radius}distanceToPlane(t){const e=t.normal.dot(this.direction);if(e===0)return t.distanceToPoint(this.origin)===0?0:null;const n=-(this.origin.dot(t.normal)+t.constant)/e;return n>=0?n:null}intersectPlane(t,e){const n=this.distanceToPlane(t);return n===null?null:this.at(n,e)}intersectsPlane(t){const e=t.distanceToPoint(this.origin);return e===0||t.normal.dot(this.direction)*e<0}intersectBox(t,e){let n,r,s,a,o,l;const c=1/this.direction.x,h=1/this.direction.y,u=1/this.direction.z,d=this.origin;return c>=0?(n=(t.min.x-d.x)*c,r=(t.max.x-d.x)*c):(n=(t.max.x-d.x)*c,r=(t.min.x-d.x)*c),h>=0?(s=(t.min.y-d.y)*h,a=(t.max.y-d.y)*h):(s=(t.max.y-d.y)*h,a=(t.min.y-d.y)*h),n>a||s>r||((s>n||n!==n)&&(n=s),(a<r||r!==r)&&(r=a),u>=0?(o=(t.min.z-d.z)*u,l=(t.max.z-d.z)*u):(o=(t.max.z-d.z)*u,l=(t.min.z-d.z)*u),n>l||o>r)||((o>n||n!==n)&&(n=o),(l<r||r!==r)&&(r=l),r<0)?null:this.at(n>=0?n:r,e)}intersectsBox(t){return this.intersectBox(t,en)!==null}intersectTriangle(t,e,n,r,s){pu.subVectors(e,t),yl.subVectors(n,t),mu.crossVectors(pu,yl);let a=this.direction.dot(mu),o;if(a>0){if(r)return null;o=1}else if(a<0)o=-1,a=-a;else return null;Nn.subVectors(this.origin,t);const l=o*this.direction.dot(yl.crossVectors(Nn,yl));if(l<0)return null;const c=o*this.direction.dot(pu.cross(Nn));if(c<0||l+c>a)return null;const h=-o*Nn.dot(mu);return h<0?null:this.at(h/a,s)}applyMatrix4(t){return this.origin.applyMatrix4(t),this.direction.transformDirection(t),this}equals(t){return t.origin.equals(this.origin)&&t.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}const Si=new it,nn=new it,gu=new it,rn=new it,ms=new it,gs=new it,Km=new it,xu=new it,yu=new it,_u=new it;class sn{constructor(t=new it,e=new it,n=new it){this.a=t,this.b=e,this.c=n}static getNormal(t,e,n,r){r.subVectors(n,e),Si.subVectors(t,e),r.cross(Si);const s=r.lengthSq();return s>0?r.multiplyScalar(1/Math.sqrt(s)):r.set(0,0,0)}static getBarycoord(t,e,n,r,s){Si.subVectors(r,e),nn.subVectors(n,e),gu.subVectors(t,e);const a=Si.dot(Si),o=Si.dot(nn),l=Si.dot(gu),c=nn.dot(nn),h=nn.dot(gu),u=a*c-o*o;if(u===0)return s.set(-2,-1,-1);const d=1/u,f=(c*l-o*h)*d,p=(a*h-o*l)*d;return s.set(1-f-p,p,f)}static containsPoint(t,e,n,r){return this.getBarycoord(t,e,n,r,rn),rn.x>=0&&rn.y>=0&&rn.x+rn.y<=1}static getUV(t,e,n,r,s,a,o,l){return this.getBarycoord(t,e,n,r,rn),l.set(0,0),l.addScaledVector(s,rn.x),l.addScaledVector(a,rn.y),l.addScaledVector(o,rn.z),l}static isFrontFacing(t,e,n,r){return Si.subVectors(n,e),nn.subVectors(t,e),Si.cross(nn).dot(r)<0}set(t,e,n){return this.a.copy(t),this.b.copy(e),this.c.copy(n),this}setFromPointsAndIndices(t,e,n,r){return this.a.copy(t[e]),this.b.copy(t[n]),this.c.copy(t[r]),this}setFromAttributeAndIndices(t,e,n,r){return this.a.fromBufferAttribute(t,e),this.b.fromBufferAttribute(t,n),this.c.fromBufferAttribute(t,r),this}clone(){return new this.constructor().copy(this)}copy(t){return this.a.copy(t.a),this.b.copy(t.b),this.c.copy(t.c),this}getArea(){return Si.subVectors(this.c,this.b),nn.subVectors(this.a,this.b),Si.cross(nn).length()*.5}getMidpoint(t){return t.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(t){return sn.getNormal(this.a,this.b,this.c,t)}getPlane(t){return t.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(t,e){return sn.getBarycoord(t,this.a,this.b,this.c,e)}getUV(t,e,n,r,s){return sn.getUV(t,this.a,this.b,this.c,e,n,r,s)}containsPoint(t){return sn.containsPoint(t,this.a,this.b,this.c)}isFrontFacing(t){return sn.isFrontFacing(this.a,this.b,this.c,t)}intersectsBox(t){return t.intersectsTriangle(this)}closestPointToPoint(t,e){const n=this.a,r=this.b,s=this.c;let a,o;ms.subVectors(r,n),gs.subVectors(s,n),xu.subVectors(t,n);const l=ms.dot(xu),c=gs.dot(xu);if(l<=0&&c<=0)return e.copy(n);yu.subVectors(t,r);const h=ms.dot(yu),u=gs.dot(yu);if(h>=0&&u<=h)return e.copy(r);const d=l*u-h*c;if(d<=0&&l>=0&&h<=0)return a=l/(l-h),e.copy(n).addScaledVector(ms,a);_u.subVectors(t,s);const f=ms.dot(_u),p=gs.dot(_u);if(p>=0&&f<=p)return e.copy(s);const x=f*c-l*p;if(x<=0&&c>=0&&p<=0)return o=c/(c-p),e.copy(n).addScaledVector(gs,o);const y=h*p-f*u;if(y<=0&&u-h>=0&&f-p>=0)return Km.subVectors(s,r),o=(u-h)/(u-h+(f-p)),e.copy(r).addScaledVector(Km,o);const g=1/(y+x+d);return a=x*g,o=d*g,e.copy(n).addScaledVector(ms,a).addScaledVector(gs,o)}equals(t){return t.a.equals(this.a)&&t.b.equals(this.b)&&t.c.equals(this.c)}}class vu{constructor(t=0,e=0,n=0,r=1){vu.prototype.isVector4=!0,this.x=t,this.y=e,this.z=n,this.w=r}get width(){return this.z}set width(t){this.z=t}get height(){return this.w}set height(t){this.w=t}set(t,e,n,r){return this.x=t,this.y=e,this.z=n,this.w=r,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this.w=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setW(t){return this.w=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;case 3:this.w=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=t.w!==void 0?t.w:1,this}add(t,e){return e!==void 0?(console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this.z+=t.z,this.w+=t.w,this)}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this.w+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this.w=t.w+e.w,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this.w+=t.w*e,this}sub(t,e){return e!==void 0?(console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this.z-=t.z,this.w-=t.w,this)}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this.w-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this.w=t.w-e.w,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this.w*=t.w,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this.w*=t,this}applyMatrix4(t){const e=this.x,n=this.y,r=this.z,s=this.w,a=t.elements;return this.x=a[0]*e+a[4]*n+a[8]*r+a[12]*s,this.y=a[1]*e+a[5]*n+a[9]*r+a[13]*s,this.z=a[2]*e+a[6]*n+a[10]*r+a[14]*s,this.w=a[3]*e+a[7]*n+a[11]*r+a[15]*s,this}divideScalar(t){return this.multiplyScalar(1/t)}setAxisAngleFromQuaternion(t){this.w=2*Math.acos(t.w);const e=Math.sqrt(1-t.w*t.w);return e<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=t.x/e,this.y=t.y/e,this.z=t.z/e),this}setAxisAngleFromRotationMatrix(t){let e,n,r,s;const a=.01,o=.1,l=t.elements,c=l[0],h=l[4],u=l[8],d=l[1],f=l[5],p=l[9],x=l[2],y=l[6],g=l[10];if(Math.abs(h-d)<a&&Math.abs(u-x)<a&&Math.abs(p-y)<a){if(Math.abs(h+d)<o&&Math.abs(u+x)<o&&Math.abs(p+y)<o&&Math.abs(c+f+g-3)<o)return this.set(1,0,0,0),this;e=Math.PI;const E=(c+1)/2,w=(f+1)/2,S=(g+1)/2,_=(h+d)/4,T=(u+x)/4,B=(p+y)/4;return E>w&&E>S?E<a?(n=0,r=.707106781,s=.707106781):(n=Math.sqrt(E),r=_/n,s=T/n):w>S?w<a?(n=.707106781,r=0,s=.707106781):(r=Math.sqrt(w),n=_/r,s=B/r):S<a?(n=.707106781,r=.707106781,s=0):(s=Math.sqrt(S),n=T/s,r=B/s),this.set(n,r,s,e),this}let m=Math.sqrt((y-p)*(y-p)+(u-x)*(u-x)+(d-h)*(d-h));return Math.abs(m)<.001&&(m=1),this.x=(y-p)/m,this.y=(u-x)/m,this.z=(d-h)/m,this.w=Math.acos((c+f+g-1)/2),this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this.w=Math.min(this.w,t.w),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this.w=Math.max(this.w,t.w),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this.w=Math.max(t.w,Math.min(e.w,this.w)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this.w=Math.max(t,Math.min(e,this.w)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this.w+=(t.w-this.w)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this.z=t.z+(e.z-t.z)*n,this.w=t.w+(e.w-t.w)*n,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z&&t.w===this.w}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this.w=t[e+3],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t[e+3]=this.w,t}fromBufferAttribute(t,e,n){return n!==void 0&&console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this.w=t.getW(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}const ue=new it,_l=new pe;class an{constructor(t,e,n){if(Array.isArray(t))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,this.name="",this.array=t,this.itemSize=e,this.count=t!==void 0?t.length/e:0,this.normalized=n===!0,this.usage=Um,this.updateRange={offset:0,count:-1},this.version=0}onUploadCallback(){}set needsUpdate(t){t===!0&&this.version++}setUsage(t){return this.usage=t,this}copy(t){return this.name=t.name,this.array=new t.array.constructor(t.array),this.itemSize=t.itemSize,this.count=t.count,this.normalized=t.normalized,this.usage=t.usage,this}copyAt(t,e,n){t*=this.itemSize,n*=e.itemSize;for(let r=0,s=this.itemSize;r<s;r++)this.array[t+r]=e.array[n+r];return this}copyArray(t){return this.array.set(t),this}copyColorsArray(t){const e=this.array;let n=0;for(let r=0,s=t.length;r<s;r++){let a=t[r];a===void 0&&(console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined",r),a=new nr),e[n++]=a.r,e[n++]=a.g,e[n++]=a.b}return this}copyVector2sArray(t){const e=this.array;let n=0;for(let r=0,s=t.length;r<s;r++){let a=t[r];a===void 0&&(console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined",r),a=new pe),e[n++]=a.x,e[n++]=a.y}return this}copyVector3sArray(t){const e=this.array;let n=0;for(let r=0,s=t.length;r<s;r++){let a=t[r];a===void 0&&(console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined",r),a=new it),e[n++]=a.x,e[n++]=a.y,e[n++]=a.z}return this}copyVector4sArray(t){const e=this.array;let n=0;for(let r=0,s=t.length;r<s;r++){let a=t[r];a===void 0&&(console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined",r),a=new vu),e[n++]=a.x,e[n++]=a.y,e[n++]=a.z,e[n++]=a.w}return this}applyMatrix3(t){if(this.itemSize===2)for(let e=0,n=this.count;e<n;e++)_l.fromBufferAttribute(this,e),_l.applyMatrix3(t),this.setXY(e,_l.x,_l.y);else if(this.itemSize===3)for(let e=0,n=this.count;e<n;e++)ue.fromBufferAttribute(this,e),ue.applyMatrix3(t),this.setXYZ(e,ue.x,ue.y,ue.z);return this}applyMatrix4(t){for(let e=0,n=this.count;e<n;e++)ue.fromBufferAttribute(this,e),ue.applyMatrix4(t),this.setXYZ(e,ue.x,ue.y,ue.z);return this}applyNormalMatrix(t){for(let e=0,n=this.count;e<n;e++)ue.fromBufferAttribute(this,e),ue.applyNormalMatrix(t),this.setXYZ(e,ue.x,ue.y,ue.z);return this}transformDirection(t){for(let e=0,n=this.count;e<n;e++)ue.fromBufferAttribute(this,e),ue.transformDirection(t),this.setXYZ(e,ue.x,ue.y,ue.z);return this}set(t,e=0){return this.array.set(t,e),this}getX(t){return this.array[t*this.itemSize]}setX(t,e){return this.array[t*this.itemSize]=e,this}getY(t){return this.array[t*this.itemSize+1]}setY(t,e){return this.array[t*this.itemSize+1]=e,this}getZ(t){return this.array[t*this.itemSize+2]}setZ(t,e){return this.array[t*this.itemSize+2]=e,this}getW(t){return this.array[t*this.itemSize+3]}setW(t,e){return this.array[t*this.itemSize+3]=e,this}setXY(t,e,n){return t*=this.itemSize,this.array[t+0]=e,this.array[t+1]=n,this}setXYZ(t,e,n,r){return t*=this.itemSize,this.array[t+0]=e,this.array[t+1]=n,this.array[t+2]=r,this}setXYZW(t,e,n,r,s){return t*=this.itemSize,this.array[t+0]=e,this.array[t+1]=n,this.array[t+2]=r,this.array[t+3]=s,this}onUpload(t){return this.onUploadCallback=t,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const t={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return this.name!==""&&(t.name=this.name),this.usage!==Um&&(t.usage=this.usage),(this.updateRange.offset!==0||this.updateRange.count!==-1)&&(t.updateRange=this.updateRange),t}}class F2 extends an{constructor(t,e,n){super(new Uint16Array(t),e,n)}}class I2 extends an{constructor(t,e,n){super(new Uint32Array(t),e,n)}}class xs extends an{constructor(t,e,n){super(new Float32Array(t),e,n)}}let z2=0;const ci=new li,Mu=new Mi,ys=new it,ei=new us,za=new us,Me=new it;class _s extends cl{constructor(){super();this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:z2++}),this.uuid=La(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(t){return Array.isArray(t)?this.index=new(S2(t)?I2:F2)(t,1):this.index=t,this}getAttribute(t){return this.attributes[t]}setAttribute(t,e){return this.attributes[t]=e,this}deleteAttribute(t){return delete this.attributes[t],this}hasAttribute(t){return this.attributes[t]!==void 0}addGroup(t,e,n=0){this.groups.push({start:t,count:e,materialIndex:n})}clearGroups(){this.groups=[]}setDrawRange(t,e){this.drawRange.start=t,this.drawRange.count=e}applyMatrix4(t){const e=this.attributes.position;e!==void 0&&(e.applyMatrix4(t),e.needsUpdate=!0);const n=this.attributes.normal;if(n!==void 0){const s=new Pa().getNormalMatrix(t);n.applyNormalMatrix(s),n.needsUpdate=!0}const r=this.attributes.tangent;return r!==void 0&&(r.transformDirection(t),r.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(t){return ci.makeRotationFromQuaternion(t),this.applyMatrix4(ci),this}rotateX(t){return ci.makeRotationX(t),this.applyMatrix4(ci),this}rotateY(t){return ci.makeRotationY(t),this.applyMatrix4(ci),this}rotateZ(t){return ci.makeRotationZ(t),this.applyMatrix4(ci),this}translate(t,e,n){return ci.makeTranslation(t,e,n),this.applyMatrix4(ci),this}scale(t,e,n){return ci.makeScale(t,e,n),this.applyMatrix4(ci),this}lookAt(t){return Mu.lookAt(t),Mu.updateMatrix(),this.applyMatrix4(Mu.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(ys).negate(),this.translate(ys.x,ys.y,ys.z),this}setFromPoints(t){const e=[];for(let n=0,r=t.length;n<r;n++){const s=t[n];e.push(s.x,s.y,s.z||0)}return this.setAttribute("position",new xs(e,3)),this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new us);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingBox.set(new it(-1/0,-1/0,-1/0),new it(1/0,1/0,1/0));return}if(t!==void 0){if(this.boundingBox.setFromBufferAttribute(t),e)for(let n=0,r=e.length;n<r;n++){const s=e[n];ei.setFromBufferAttribute(s),this.morphTargetsRelative?(Me.addVectors(this.boundingBox.min,ei.min),this.boundingBox.expandByPoint(Me),Me.addVectors(this.boundingBox.max,ei.max),this.boundingBox.expandByPoint(Me)):(this.boundingBox.expandByPoint(ei.min),this.boundingBox.expandByPoint(ei.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new du);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingSphere.set(new it,1/0);return}if(t){const n=this.boundingSphere.center;if(ei.setFromBufferAttribute(t),e)for(let s=0,a=e.length;s<a;s++){const o=e[s];za.setFromBufferAttribute(o),this.morphTargetsRelative?(Me.addVectors(ei.min,za.min),ei.expandByPoint(Me),Me.addVectors(ei.max,za.max),ei.expandByPoint(Me)):(ei.expandByPoint(za.min),ei.expandByPoint(za.max))}ei.getCenter(n);let r=0;for(let s=0,a=t.count;s<a;s++)Me.fromBufferAttribute(t,s),r=Math.max(r,n.distanceToSquared(Me));if(e)for(let s=0,a=e.length;s<a;s++){const o=e[s],l=this.morphTargetsRelative;for(let c=0,h=o.count;c<h;c++)Me.fromBufferAttribute(o,c),l&&(ys.fromBufferAttribute(t,c),Me.add(ys)),r=Math.max(r,n.distanceToSquared(Me))}this.boundingSphere.radius=Math.sqrt(r),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const t=this.index,e=this.attributes;if(t===null||e.position===void 0||e.normal===void 0||e.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const n=t.array,r=e.position.array,s=e.normal.array,a=e.uv.array,o=r.length/3;this.hasAttribute("tangent")===!1&&this.setAttribute("tangent",new an(new Float32Array(4*o),4));const l=this.getAttribute("tangent").array,c=[],h=[];for(let G=0;G<o;G++)c[G]=new it,h[G]=new it;const u=new it,d=new it,f=new it,p=new pe,x=new pe,y=new pe,g=new it,m=new it;function E(G,D,V){u.fromArray(r,G*3),d.fromArray(r,D*3),f.fromArray(r,V*3),p.fromArray(a,G*2),x.fromArray(a,D*2),y.fromArray(a,V*2),d.sub(u),f.sub(u),x.sub(p),y.sub(p);const R=1/(x.x*y.y-y.x*x.y);!isFinite(R)||(g.copy(d).multiplyScalar(y.y).addScaledVector(f,-x.y).multiplyScalar(R),m.copy(f).multiplyScalar(x.x).addScaledVector(d,-y.x).multiplyScalar(R),c[G].add(g),c[D].add(g),c[V].add(g),h[G].add(m),h[D].add(m),h[V].add(m))}let w=this.groups;w.length===0&&(w=[{start:0,count:n.length}]);for(let G=0,D=w.length;G<D;++G){const V=w[G],R=V.start,L=V.count;for(let P=R,F=R+L;P<F;P+=3)E(n[P+0],n[P+1],n[P+2])}const S=new it,_=new it,T=new it,B=new it;function N(G){T.fromArray(s,G*3),B.copy(T);const D=c[G];S.copy(D),S.sub(T.multiplyScalar(T.dot(D))).normalize(),_.crossVectors(B,D);const R=_.dot(h[G])<0?-1:1;l[G*4]=S.x,l[G*4+1]=S.y,l[G*4+2]=S.z,l[G*4+3]=R}for(let G=0,D=w.length;G<D;++G){const V=w[G],R=V.start,L=V.count;for(let P=R,F=R+L;P<F;P+=3)N(n[P+0]),N(n[P+1]),N(n[P+2])}}computeVertexNormals(){const t=this.index,e=this.getAttribute("position");if(e!==void 0){let n=this.getAttribute("normal");if(n===void 0)n=new an(new Float32Array(e.count*3),3),this.setAttribute("normal",n);else for(let d=0,f=n.count;d<f;d++)n.setXYZ(d,0,0,0);const r=new it,s=new it,a=new it,o=new it,l=new it,c=new it,h=new it,u=new it;if(t)for(let d=0,f=t.count;d<f;d+=3){const p=t.getX(d+0),x=t.getX(d+1),y=t.getX(d+2);r.fromBufferAttribute(e,p),s.fromBufferAttribute(e,x),a.fromBufferAttribute(e,y),h.subVectors(a,s),u.subVectors(r,s),h.cross(u),o.fromBufferAttribute(n,p),l.fromBufferAttribute(n,x),c.fromBufferAttribute(n,y),o.add(h),l.add(h),c.add(h),n.setXYZ(p,o.x,o.y,o.z),n.setXYZ(x,l.x,l.y,l.z),n.setXYZ(y,c.x,c.y,c.z)}else for(let d=0,f=e.count;d<f;d+=3)r.fromBufferAttribute(e,d+0),s.fromBufferAttribute(e,d+1),a.fromBufferAttribute(e,d+2),h.subVectors(a,s),u.subVectors(r,s),h.cross(u),n.setXYZ(d+0,h.x,h.y,h.z),n.setXYZ(d+1,h.x,h.y,h.z),n.setXYZ(d+2,h.x,h.y,h.z);this.normalizeNormals(),n.needsUpdate=!0}}merge(t,e){if(!(t&&t.isBufferGeometry)){console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",t);return}e===void 0&&(e=0,console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));const n=this.attributes;for(const r in n){if(t.attributes[r]===void 0)continue;const a=n[r].array,o=t.attributes[r],l=o.array,c=o.itemSize*e,h=Math.min(l.length,a.length-c);for(let u=0,d=c;u<h;u++,d++)a[d]=l[u]}return this}normalizeNormals(){const t=this.attributes.normal;for(let e=0,n=t.count;e<n;e++)Me.fromBufferAttribute(t,e),Me.normalize(),t.setXYZ(e,Me.x,Me.y,Me.z)}toNonIndexed(){function t(o,l){const c=o.array,h=o.itemSize,u=o.normalized,d=new c.constructor(l.length*h);let f=0,p=0;for(let x=0,y=l.length;x<y;x++){o.isInterleavedBufferAttribute?f=l[x]*o.data.stride+o.offset:f=l[x]*h;for(let g=0;g<h;g++)d[p++]=c[f++]}return new an(d,h,u)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const e=new _s,n=this.index.array,r=this.attributes;for(const o in r){const l=r[o],c=t(l,n);e.setAttribute(o,c)}const s=this.morphAttributes;for(const o in s){const l=[],c=s[o];for(let h=0,u=c.length;h<u;h++){const d=c[h],f=t(d,n);l.push(f)}e.morphAttributes[o]=l}e.morphTargetsRelative=this.morphTargetsRelative;const a=this.groups;for(let o=0,l=a.length;o<l;o++){const c=a[o];e.addGroup(c.start,c.count,c.materialIndex)}return e}toJSON(){const t={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(t.uuid=this.uuid,t.type=this.type,this.name!==""&&(t.name=this.name),Object.keys(this.userData).length>0&&(t.userData=this.userData),this.parameters!==void 0){const l=this.parameters;for(const c in l)l[c]!==void 0&&(t[c]=l[c]);return t}t.data={attributes:{}};const e=this.index;e!==null&&(t.data.index={type:e.array.constructor.name,array:Array.prototype.slice.call(e.array)});const n=this.attributes;for(const l in n){const c=n[l];t.data.attributes[l]=c.toJSON(t.data)}const r={};let s=!1;for(const l in this.morphAttributes){const c=this.morphAttributes[l],h=[];for(let u=0,d=c.length;u<d;u++){const f=c[u];h.push(f.toJSON(t.data))}h.length>0&&(r[l]=h,s=!0)}s&&(t.data.morphAttributes=r,t.data.morphTargetsRelative=this.morphTargetsRelative);const a=this.groups;a.length>0&&(t.data.groups=JSON.parse(JSON.stringify(a)));const o=this.boundingSphere;return o!==null&&(t.data.boundingSphere={center:o.center.toArray(),radius:o.radius}),t}clone(){return new this.constructor().copy(this)}copy(t){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const e={};this.name=t.name;const n=t.index;n!==null&&this.setIndex(n.clone(e));const r=t.attributes;for(const c in r){const h=r[c];this.setAttribute(c,h.clone(e))}const s=t.morphAttributes;for(const c in s){const h=[],u=s[c];for(let d=0,f=u.length;d<f;d++)h.push(u[d].clone(e));this.morphAttributes[c]=h}this.morphTargetsRelative=t.morphTargetsRelative;const a=t.groups;for(let c=0,h=a.length;c<h;c++){const u=a[c];this.addGroup(u.start,u.count,u.materialIndex)}const o=t.boundingBox;o!==null&&(this.boundingBox=o.clone());const l=t.boundingSphere;return l!==null&&(this.boundingSphere=l.clone()),this.drawRange.start=t.drawRange.start,this.drawRange.count=t.drawRange.count,this.userData=t.userData,t.parameters!==void 0&&(this.parameters=Object.assign({},t.parameters)),this}dispose(){this.dispatchEvent({type:"dispose"})}}const tg=new li,vs=new Qm,bu=new du,Bn=new it,On=new it,Un=new it,wu=new it,Su=new it,Eu=new it,vl=new it,Ml=new it,bl=new it,wl=new pe,Sl=new pe,El=new pe,Au=new it,Al=new it;class Tu extends Mi{constructor(t=new _s,e=new Fa){super();this.isMesh=!0,this.type="Mesh",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t,e){return super.copy(t,e),t.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=t.morphTargetInfluences.slice()),t.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},t.morphTargetDictionary)),this.material=t.material,this.geometry=t.geometry,this}updateMorphTargets(){const e=this.geometry.morphAttributes,n=Object.keys(e);if(n.length>0){const r=e[n[0]];if(r!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,a=r.length;s<a;s++){const o=r[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[o]=s}}}}raycast(t,e){const n=this.geometry,r=this.material,s=this.matrixWorld;if(r===void 0||(n.boundingSphere===null&&n.computeBoundingSphere(),bu.copy(n.boundingSphere),bu.applyMatrix4(s),t.ray.intersectsSphere(bu)===!1)||(tg.copy(s).invert(),vs.copy(t.ray).applyMatrix4(tg),n.boundingBox!==null&&vs.intersectsBox(n.boundingBox)===!1))return;let a;const o=n.index,l=n.attributes.position,c=n.morphAttributes.position,h=n.morphTargetsRelative,u=n.attributes.uv,d=n.attributes.uv2,f=n.groups,p=n.drawRange;if(o!==null)if(Array.isArray(r))for(let x=0,y=f.length;x<y;x++){const g=f[x],m=r[g.materialIndex],E=Math.max(g.start,p.start),w=Math.min(o.count,Math.min(g.start+g.count,p.start+p.count));for(let S=E,_=w;S<_;S+=3){const T=o.getX(S),B=o.getX(S+1),N=o.getX(S+2);a=Tl(this,m,t,vs,l,c,h,u,d,T,B,N),a&&(a.faceIndex=Math.floor(S/3),a.face.materialIndex=g.materialIndex,e.push(a))}}else{const x=Math.max(0,p.start),y=Math.min(o.count,p.start+p.count);for(let g=x,m=y;g<m;g+=3){const E=o.getX(g),w=o.getX(g+1),S=o.getX(g+2);a=Tl(this,r,t,vs,l,c,h,u,d,E,w,S),a&&(a.faceIndex=Math.floor(g/3),e.push(a))}}else if(l!==void 0)if(Array.isArray(r))for(let x=0,y=f.length;x<y;x++){const g=f[x],m=r[g.materialIndex],E=Math.max(g.start,p.start),w=Math.min(l.count,Math.min(g.start+g.count,p.start+p.count));for(let S=E,_=w;S<_;S+=3){const T=S,B=S+1,N=S+2;a=Tl(this,m,t,vs,l,c,h,u,d,T,B,N),a&&(a.faceIndex=Math.floor(S/3),a.face.materialIndex=g.materialIndex,e.push(a))}}else{const x=Math.max(0,p.start),y=Math.min(l.count,p.start+p.count);for(let g=x,m=y;g<m;g+=3){const E=g,w=g+1,S=g+2;a=Tl(this,r,t,vs,l,c,h,u,d,E,w,S),a&&(a.faceIndex=Math.floor(g/3),e.push(a))}}}}function N2(i,t,e,n,r,s,a,o){let l;if(t.side===n2?l=n.intersectTriangle(a,s,r,!0,o):l=n.intersectTriangle(r,s,a,t.side!==Dm,o),l===null)return null;Al.copy(o),Al.applyMatrix4(i.matrixWorld);const c=e.ray.origin.distanceTo(Al);return c<e.near||c>e.far?null:{distance:c,point:Al.clone(),object:i}}function Tl(i,t,e,n,r,s,a,o,l,c,h,u){Bn.fromBufferAttribute(r,c),On.fromBufferAttribute(r,h),Un.fromBufferAttribute(r,u);const d=i.morphTargetInfluences;if(s&&d){vl.set(0,0,0),Ml.set(0,0,0),bl.set(0,0,0);for(let p=0,x=s.length;p<x;p++){const y=d[p],g=s[p];y!==0&&(wu.fromBufferAttribute(g,c),Su.fromBufferAttribute(g,h),Eu.fromBufferAttribute(g,u),a?(vl.addScaledVector(wu,y),Ml.addScaledVector(Su,y),bl.addScaledVector(Eu,y)):(vl.addScaledVector(wu.sub(Bn),y),Ml.addScaledVector(Su.sub(On),y),bl.addScaledVector(Eu.sub(Un),y)))}Bn.add(vl),On.add(Ml),Un.add(bl)}i.isSkinnedMesh&&(i.boneTransform(c,Bn),i.boneTransform(h,On),i.boneTransform(u,Un));const f=N2(i,t,e,n,Bn,On,Un,Au);if(f){o&&(wl.fromBufferAttribute(o,c),Sl.fromBufferAttribute(o,h),El.fromBufferAttribute(o,u),f.uv=sn.getUV(Au,Bn,On,Un,wl,Sl,El,new pe)),l&&(wl.fromBufferAttribute(l,c),Sl.fromBufferAttribute(l,h),El.fromBufferAttribute(l,u),f.uv2=sn.getUV(Au,Bn,On,Un,wl,Sl,El,new pe));const p={a:c,b:h,c:u,normal:new it,materialIndex:0};sn.getNormal(Bn,On,Un,p.normal),f.face=p}return f}class Lu extends Mi{constructor(){super();this.isGroup=!0,this.type="Group"}}class on extends _s{constructor(t=1,e=1,n=1,r=1,s=1,a=1){super();this.type="BoxGeometry",this.parameters={width:t,height:e,depth:n,widthSegments:r,heightSegments:s,depthSegments:a};const o=this;r=Math.floor(r),s=Math.floor(s),a=Math.floor(a);const l=[],c=[],h=[],u=[];let d=0,f=0;p("z","y","x",-1,-1,n,e,t,a,s,0),p("z","y","x",1,-1,n,e,-t,a,s,1),p("x","z","y",1,1,t,n,e,r,a,2),p("x","z","y",1,-1,t,n,-e,r,a,3),p("x","y","z",1,-1,t,e,n,r,s,4),p("x","y","z",-1,-1,t,e,-n,r,s,5),this.setIndex(l),this.setAttribute("position",new xs(c,3)),this.setAttribute("normal",new xs(h,3)),this.setAttribute("uv",new xs(u,2));function p(x,y,g,m,E,w,S,_,T,B,N){const G=w/T,D=S/B,V=w/2,R=S/2,L=_/2,P=T+1,F=B+1;let W=0,j=0;const Y=new it;for(let Q=0;Q<F;Q++){const K=Q*D-R;for(let st=0;st<P;st++){const ct=st*G-V;Y[x]=ct*m,Y[y]=K*E,Y[g]=L,c.push(Y.x,Y.y,Y.z),Y[x]=0,Y[y]=0,Y[g]=_>0?1:-1,h.push(Y.x,Y.y,Y.z),u.push(st/T),u.push(1-Q/B),W+=1}}for(let Q=0;Q<B;Q++)for(let K=0;K<T;K++){const st=d+K+P*Q,ct=d+K+P*(Q+1),z=d+(K+1)+P*(Q+1),Et=d+(K+1)+P*Q;l.push(st,ct,Et),l.push(ct,z,Et),j+=6}o.addGroup(f,j,N),f+=j,d+=W}}static fromJSON(t){return new on(t.width,t.height,t.depth,t.widthSegments,t.heightSegments,t.depthSegments)}}const Hn={rotation:[0,0,0],translation:[0,0,0],scale:[1,1,1]},B2={ground:Hn,gui:Hn,thirdperson_lefthand:Hn,thirdperson_righthand:Hn,firstperson_lefthand:Hn,firstperson_righthand:Hn,fixed:Hn,head:Hn};function O2(i,t){let e=i.textures[t];for(;e.startsWith("#");){const n=i.textures[e.substring(1,e.length)];if(!n)return;e=n}return e}class U2 extends Mi{constructor(){super(...arguments);this.animationLoop=!1,this.displayOption=B2}applyDisplay(t){const e=this.children[0];if(t==="block")e.rotation.set(0,0,0),e.position.set(0,0,0),e.scale.set(1,1,1);else{if(!this.displayOption.hasOwnProperty(t))throw new Error("Display option is invalid.");const n=this.displayOption[t],r=n.rotation,s=n.translation,a=n.scale;e.rotation.set(r[0]*Math.PI/180,r[1]*Math.PI/180,r[2]*Math.PI/180),e.position.set(s[0],s[1],s[2]),e.scale.set(a[0]===0?1e-5:a[0],a[1]===0?1e-5:a[1],a[2]===0?1e-5:a[2])}}getCenter(){const t=this.children[0],e={minx:0,miny:0,minz:0,maxx:0,maxy:0,maxz:0};for(let n=0;n<t.children.length;n++)t.children[n].children[0].geometry;return new it((e.minx+e.maxx)/2,(e.miny+e.maxy)/2,(e.minz+e.maxz)/2)}}const eg=class{constructor(i,t={}){this.textureRegistry=i,this.option=t,this.loader=new R2,this.cachedMaterial={}}getObject(i,t){const e=this.option,n=this.textureRegistry,r=e.clipUVs||!1;e.modelOnly;const s=new U2,a=new Lu;a.name="wrapper";const o=[eg.TRANSPARENT_MATERIAL],l={},c={};for(const h of Object.keys(i.textures)){const u=O2(i,h);let d=0;if(!u)console.error(`Cannot find texture @${u}`);else{let f=c[u];if(!f){if(u in this.cachedMaterial)f=o.length,o.push(this.cachedMaterial[u]);else if(u in n){const p=n[u],x=this.loader.load(p.url);x.magFilter=Ta,x.minFilter=Om;const y=new P2({map:x,transparent:!0,alphaTest:.5});f=o.length,this.cachedMaterial[u]=y,o.push(y)}}c[u]=f,d=f}l[h]=d}for(const h of i.elements){const u=h.to[0]-h.from[0],d=h.to[1]-h.from[1],f=h.to[2]-h.from[2],p={x:(h.to[0]+h.from[0])/2-8,y:(h.to[1]+h.from[1])/2-8,z:(h.to[2]+h.from[2])/2-8},x=.001,y=new on(u+x,d+x,f+x),g=new Tu(y,o);g.name="block-element",y.clearGroups(),g.position.x=p.x,g.position.y=p.y,g.position.z=p.z;const m=[],E=["east","west","up","down","south","north"],w=S=>[[h.from[2],h.from[1],h.to[2],h.to[1]],[h.from[2],h.from[1],h.to[2],h.to[1]],[h.from[0],h.from[2],h.to[0],h.to[2]],[h.from[0],h.from[2],h.to[0],h.to[2]],[h.from[0],h.from[1],h.to[0],h.to[1]],[h.from[0],h.from[1],h.to[0],h.to[1]]][S];for(let S=0;S<6;S++){const _=h.faces[E[S]];let T=0,B;_?(T=l[_.texture.substring(1,_.texture.length)],B=_.uv||w(S),r&&(B=B.map(L=>L+1e-5<0?0:L-1e-5>16?16:L)),B=B.map(L=>L/16)):B=[0,0,1,1];const[N,G,D,V]=B;let R=[new pe(N,V),new pe(D,V),new pe(N,G),new pe(D,G)];if(_&&_.rotation){const L=_.rotation;[0,90,180,270].indexOf(L)>=0||console.error('The "rotation" property for "'+_+'" face is invalid (got "'+L+'").');for(let P=0;P<L/90;P++)R=[R[1],R[2],R[3],R[0]]}m.push(...R),y.addGroup(S*6,6,T)}if(y.setAttribute("uv",new an(new Float32Array(m.length*2),2).copyVector2sArray(m)),h.rotation){const S={x:h.rotation.origin[0]-8,y:h.rotation.origin[1]-8,z:h.rotation.origin[2]-8},_=h.rotation.axis,T=h.rotation.angle,B=new Lu;B.name="pivot",B.position.x=S.x,B.position.y=S.y,B.position.z=S.z,B.add(g),g.position.x-=S.x,g.position.y-=S.y,g.position.z-=S.z,_==="x"?B.rotateX(T*Math.PI/180):_==="y"?B.rotateY(T*Math.PI/180):_==="z"&&B.rotateZ(T*Math.PI/180),a.add(B)}else{const S=new Lu;S.name="pivot",S.add(g),a.add(S)}}return s.add(a),s}};let ig=eg;ig.TRANSPARENT_MATERIAL=new Fa({transparent:!0,opacity:0,alphaTest:.5});/**
 * @license
 * Copyright 2010-2022 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const ng="142",ln="srgb",lr="srgb-linear",rg=35044;function cr(i,t,e){return Math.max(t,Math.min(e,i))}function H2(i,t){return(i%t+t)%t}function Ru(i,t,e){return(1-e)*i+e*t}class Gn{constructor(t=0,e=0){Gn.prototype.isVector2=!0,this.x=t,this.y=e}get width(){return this.x}set width(t){this.x=t}get height(){return this.y}set height(t){this.y=t}set(t,e){return this.x=t,this.y=e,this}setScalar(t){return this.x=t,this.y=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y)}copy(t){return this.x=t.x,this.y=t.y,this}add(t,e){return e!==void 0?(console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this)}addScalar(t){return this.x+=t,this.y+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this}sub(t,e){return e!==void 0?(console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this)}subScalar(t){return this.x-=t,this.y-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this}multiply(t){return this.x*=t.x,this.y*=t.y,this}multiplyScalar(t){return this.x*=t,this.y*=t,this}divide(t){return this.x/=t.x,this.y/=t.y,this}divideScalar(t){return this.multiplyScalar(1/t)}applyMatrix3(t){const e=this.x,n=this.y,r=t.elements;return this.x=r[0]*e+r[3]*n+r[6],this.y=r[1]*e+r[4]*n+r[7],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,n=this.y-t.y;return e*e+n*n}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this}equals(t){return t.x===this.x&&t.y===this.y}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t}fromBufferAttribute(t,e,n){return n!==void 0&&console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this}rotateAround(t,e){const n=Math.cos(e),r=Math.sin(e),s=this.x-t.x,a=this.y-t.y;return this.x=s*n-a*r+t.x,this.y=s*r+a*n+t.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}function Ll(i){return i<.04045?i*.0773993808:Math.pow(i*.9478672986+.0521327014,2.4)}function Rl(i){return i<.0031308?i*12.92:1.055*Math.pow(i,.41666)-.055}const Cu={[ln]:{[lr]:Ll},[lr]:{[ln]:Rl}},Ei={legacyMode:!0,get workingColorSpace(){return lr},set workingColorSpace(i){console.warn("THREE.ColorManagement: .workingColorSpace is readonly.")},convert:function(i,t,e){if(this.legacyMode||t===e||!t||!e)return i;if(Cu[t]&&Cu[t][e]!==void 0){const n=Cu[t][e];return i.r=n(i.r),i.g=n(i.g),i.b=n(i.b),i}throw new Error("Unsupported color space conversion.")},fromWorkingColorSpace:function(i,t){return this.convert(i,this.workingColorSpace,t)},toWorkingColorSpace:function(i,t){return this.convert(i,t,this.workingColorSpace)}},sg={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},ge={r:0,g:0,b:0},Ai={h:0,s:0,l:0},Cl={h:0,s:0,l:0};function Pu(i,t,e){return e<0&&(e+=1),e>1&&(e-=1),e<1/6?i+(t-i)*6*e:e<1/2?t:e<2/3?i+(t-i)*6*(2/3-e):i}function Pl(i,t){return t.r=i.r,t.g=i.g,t.b=i.b,t}class ag{constructor(t,e,n){return this.isColor=!0,this.r=1,this.g=1,this.b=1,e===void 0&&n===void 0?this.set(t):this.setRGB(t,e,n)}set(t){return t&&t.isColor?this.copy(t):typeof t=="number"?this.setHex(t):typeof t=="string"&&this.setStyle(t),this}setScalar(t){return this.r=t,this.g=t,this.b=t,this}setHex(t,e=ln){return t=Math.floor(t),this.r=(t>>16&255)/255,this.g=(t>>8&255)/255,this.b=(t&255)/255,Ei.toWorkingColorSpace(this,e),this}setRGB(t,e,n,r=lr){return this.r=t,this.g=e,this.b=n,Ei.toWorkingColorSpace(this,r),this}setHSL(t,e,n,r=lr){if(t=H2(t,1),e=cr(e,0,1),n=cr(n,0,1),e===0)this.r=this.g=this.b=n;else{const s=n<=.5?n*(1+e):n+e-n*e,a=2*n-s;this.r=Pu(a,s,t+1/3),this.g=Pu(a,s,t),this.b=Pu(a,s,t-1/3)}return Ei.toWorkingColorSpace(this,r),this}setStyle(t,e=ln){function n(s){s!==void 0&&parseFloat(s)<1&&console.warn("THREE.Color: Alpha component of "+t+" will be ignored.")}let r;if(r=/^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t)){let s;const a=r[1],o=r[2];switch(a){case"rgb":case"rgba":if(s=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return this.r=Math.min(255,parseInt(s[1],10))/255,this.g=Math.min(255,parseInt(s[2],10))/255,this.b=Math.min(255,parseInt(s[3],10))/255,Ei.toWorkingColorSpace(this,e),n(s[4]),this;if(s=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return this.r=Math.min(100,parseInt(s[1],10))/100,this.g=Math.min(100,parseInt(s[2],10))/100,this.b=Math.min(100,parseInt(s[3],10))/100,Ei.toWorkingColorSpace(this,e),n(s[4]),this;break;case"hsl":case"hsla":if(s=/^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)){const l=parseFloat(s[1])/360,c=parseInt(s[2],10)/100,h=parseInt(s[3],10)/100;return n(s[4]),this.setHSL(l,c,h,e)}break}}else if(r=/^\#([A-Fa-f\d]+)$/.exec(t)){const s=r[1],a=s.length;if(a===3)return this.r=parseInt(s.charAt(0)+s.charAt(0),16)/255,this.g=parseInt(s.charAt(1)+s.charAt(1),16)/255,this.b=parseInt(s.charAt(2)+s.charAt(2),16)/255,Ei.toWorkingColorSpace(this,e),this;if(a===6)return this.r=parseInt(s.charAt(0)+s.charAt(1),16)/255,this.g=parseInt(s.charAt(2)+s.charAt(3),16)/255,this.b=parseInt(s.charAt(4)+s.charAt(5),16)/255,Ei.toWorkingColorSpace(this,e),this}return t&&t.length>0?this.setColorName(t,e):this}setColorName(t,e=ln){const n=sg[t.toLowerCase()];return n!==void 0?this.setHex(n,e):console.warn("THREE.Color: Unknown color "+t),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(t){return this.r=t.r,this.g=t.g,this.b=t.b,this}copySRGBToLinear(t){return this.r=Ll(t.r),this.g=Ll(t.g),this.b=Ll(t.b),this}copyLinearToSRGB(t){return this.r=Rl(t.r),this.g=Rl(t.g),this.b=Rl(t.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(t=ln){return Ei.fromWorkingColorSpace(Pl(this,ge),t),cr(ge.r*255,0,255)<<16^cr(ge.g*255,0,255)<<8^cr(ge.b*255,0,255)<<0}getHexString(t=ln){return("000000"+this.getHex(t).toString(16)).slice(-6)}getHSL(t,e=lr){Ei.fromWorkingColorSpace(Pl(this,ge),e);const n=ge.r,r=ge.g,s=ge.b,a=Math.max(n,r,s),o=Math.min(n,r,s);let l,c;const h=(o+a)/2;if(o===a)l=0,c=0;else{const u=a-o;switch(c=h<=.5?u/(a+o):u/(2-a-o),a){case n:l=(r-s)/u+(r<s?6:0);break;case r:l=(s-n)/u+2;break;case s:l=(n-r)/u+4;break}l/=6}return t.h=l,t.s=c,t.l=h,t}getRGB(t,e=lr){return Ei.fromWorkingColorSpace(Pl(this,ge),e),t.r=ge.r,t.g=ge.g,t.b=ge.b,t}getStyle(t=ln){return Ei.fromWorkingColorSpace(Pl(this,ge),t),t!==ln?`color(${t} ${ge.r} ${ge.g} ${ge.b})`:`rgb(${ge.r*255|0},${ge.g*255|0},${ge.b*255|0})`}offsetHSL(t,e,n){return this.getHSL(Ai),Ai.h+=t,Ai.s+=e,Ai.l+=n,this.setHSL(Ai.h,Ai.s,Ai.l),this}add(t){return this.r+=t.r,this.g+=t.g,this.b+=t.b,this}addColors(t,e){return this.r=t.r+e.r,this.g=t.g+e.g,this.b=t.b+e.b,this}addScalar(t){return this.r+=t,this.g+=t,this.b+=t,this}sub(t){return this.r=Math.max(0,this.r-t.r),this.g=Math.max(0,this.g-t.g),this.b=Math.max(0,this.b-t.b),this}multiply(t){return this.r*=t.r,this.g*=t.g,this.b*=t.b,this}multiplyScalar(t){return this.r*=t,this.g*=t,this.b*=t,this}lerp(t,e){return this.r+=(t.r-this.r)*e,this.g+=(t.g-this.g)*e,this.b+=(t.b-this.b)*e,this}lerpColors(t,e,n){return this.r=t.r+(e.r-t.r)*n,this.g=t.g+(e.g-t.g)*n,this.b=t.b+(e.b-t.b)*n,this}lerpHSL(t,e){this.getHSL(Ai),t.getHSL(Cl);const n=Ru(Ai.h,Cl.h,e),r=Ru(Ai.s,Cl.s,e),s=Ru(Ai.l,Cl.l,e);return this.setHSL(n,r,s),this}equals(t){return t.r===this.r&&t.g===this.g&&t.b===this.b}fromArray(t,e=0){return this.r=t[e],this.g=t[e+1],this.b=t[e+2],this}toArray(t=[],e=0){return t[e]=this.r,t[e+1]=this.g,t[e+2]=this.b,t}fromBufferAttribute(t,e){return this.r=t.getX(e),this.g=t.getY(e),this.b=t.getZ(e),t.normalized===!0&&(this.r/=255,this.g/=255,this.b/=255),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}ag.NAMES=sg;class Du{constructor(t=0,e=0,n=0,r=1){Du.prototype.isVector4=!0,this.x=t,this.y=e,this.z=n,this.w=r}get width(){return this.z}set width(t){this.z=t}get height(){return this.w}set height(t){this.w=t}set(t,e,n,r){return this.x=t,this.y=e,this.z=n,this.w=r,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this.w=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setW(t){return this.w=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;case 3:this.w=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=t.w!==void 0?t.w:1,this}add(t,e){return e!==void 0?(console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this.z+=t.z,this.w+=t.w,this)}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this.w+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this.w=t.w+e.w,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this.w+=t.w*e,this}sub(t,e){return e!==void 0?(console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this.z-=t.z,this.w-=t.w,this)}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this.w-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this.w=t.w-e.w,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this.w*=t.w,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this.w*=t,this}applyMatrix4(t){const e=this.x,n=this.y,r=this.z,s=this.w,a=t.elements;return this.x=a[0]*e+a[4]*n+a[8]*r+a[12]*s,this.y=a[1]*e+a[5]*n+a[9]*r+a[13]*s,this.z=a[2]*e+a[6]*n+a[10]*r+a[14]*s,this.w=a[3]*e+a[7]*n+a[11]*r+a[15]*s,this}divideScalar(t){return this.multiplyScalar(1/t)}setAxisAngleFromQuaternion(t){this.w=2*Math.acos(t.w);const e=Math.sqrt(1-t.w*t.w);return e<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=t.x/e,this.y=t.y/e,this.z=t.z/e),this}setAxisAngleFromRotationMatrix(t){let e,n,r,s;const a=.01,o=.1,l=t.elements,c=l[0],h=l[4],u=l[8],d=l[1],f=l[5],p=l[9],x=l[2],y=l[6],g=l[10];if(Math.abs(h-d)<a&&Math.abs(u-x)<a&&Math.abs(p-y)<a){if(Math.abs(h+d)<o&&Math.abs(u+x)<o&&Math.abs(p+y)<o&&Math.abs(c+f+g-3)<o)return this.set(1,0,0,0),this;e=Math.PI;const E=(c+1)/2,w=(f+1)/2,S=(g+1)/2,_=(h+d)/4,T=(u+x)/4,B=(p+y)/4;return E>w&&E>S?E<a?(n=0,r=.707106781,s=.707106781):(n=Math.sqrt(E),r=_/n,s=T/n):w>S?w<a?(n=.707106781,r=0,s=.707106781):(r=Math.sqrt(w),n=_/r,s=B/r):S<a?(n=.707106781,r=.707106781,s=0):(s=Math.sqrt(S),n=T/s,r=B/s),this.set(n,r,s,e),this}let m=Math.sqrt((y-p)*(y-p)+(u-x)*(u-x)+(d-h)*(d-h));return Math.abs(m)<.001&&(m=1),this.x=(y-p)/m,this.y=(u-x)/m,this.z=(d-h)/m,this.w=Math.acos((c+f+g-1)/2),this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this.w=Math.min(this.w,t.w),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this.w=Math.max(this.w,t.w),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this.w=Math.max(t.w,Math.min(e.w,this.w)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this.w=Math.max(t,Math.min(e,this.w)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this.w+=(t.w-this.w)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this.z=t.z+(e.z-t.z)*n,this.w=t.w+(e.w-t.w)*n,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z&&t.w===this.w}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this.w=t[e+3],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t[e+3]=this.w,t}fromBufferAttribute(t,e,n){return n!==void 0&&console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this.w=t.getW(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}class G2{constructor(t=0,e=0,n=0,r=1){this.isQuaternion=!0,this._x=t,this._y=e,this._z=n,this._w=r}static slerp(t,e,n,r){return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."),n.slerpQuaternions(t,e,r)}static slerpFlat(t,e,n,r,s,a,o){let l=n[r+0],c=n[r+1],h=n[r+2],u=n[r+3];const d=s[a+0],f=s[a+1],p=s[a+2],x=s[a+3];if(o===0){t[e+0]=l,t[e+1]=c,t[e+2]=h,t[e+3]=u;return}if(o===1){t[e+0]=d,t[e+1]=f,t[e+2]=p,t[e+3]=x;return}if(u!==x||l!==d||c!==f||h!==p){let y=1-o;const g=l*d+c*f+h*p+u*x,m=g>=0?1:-1,E=1-g*g;if(E>Number.EPSILON){const S=Math.sqrt(E),_=Math.atan2(S,g*m);y=Math.sin(y*_)/S,o=Math.sin(o*_)/S}const w=o*m;if(l=l*y+d*w,c=c*y+f*w,h=h*y+p*w,u=u*y+x*w,y===1-o){const S=1/Math.sqrt(l*l+c*c+h*h+u*u);l*=S,c*=S,h*=S,u*=S}}t[e]=l,t[e+1]=c,t[e+2]=h,t[e+3]=u}static multiplyQuaternionsFlat(t,e,n,r,s,a){const o=n[r],l=n[r+1],c=n[r+2],h=n[r+3],u=s[a],d=s[a+1],f=s[a+2],p=s[a+3];return t[e]=o*p+h*u+l*f-c*d,t[e+1]=l*p+h*d+c*u-o*f,t[e+2]=c*p+h*f+o*d-l*u,t[e+3]=h*p-o*u-l*d-c*f,t}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get w(){return this._w}set w(t){this._w=t,this._onChangeCallback()}set(t,e,n,r){return this._x=t,this._y=e,this._z=n,this._w=r,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(t){return this._x=t.x,this._y=t.y,this._z=t.z,this._w=t.w,this._onChangeCallback(),this}setFromEuler(t,e){if(!(t&&t.isEuler))throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");const n=t._x,r=t._y,s=t._z,a=t._order,o=Math.cos,l=Math.sin,c=o(n/2),h=o(r/2),u=o(s/2),d=l(n/2),f=l(r/2),p=l(s/2);switch(a){case"XYZ":this._x=d*h*u+c*f*p,this._y=c*f*u-d*h*p,this._z=c*h*p+d*f*u,this._w=c*h*u-d*f*p;break;case"YXZ":this._x=d*h*u+c*f*p,this._y=c*f*u-d*h*p,this._z=c*h*p-d*f*u,this._w=c*h*u+d*f*p;break;case"ZXY":this._x=d*h*u-c*f*p,this._y=c*f*u+d*h*p,this._z=c*h*p+d*f*u,this._w=c*h*u-d*f*p;break;case"ZYX":this._x=d*h*u-c*f*p,this._y=c*f*u+d*h*p,this._z=c*h*p-d*f*u,this._w=c*h*u+d*f*p;break;case"YZX":this._x=d*h*u+c*f*p,this._y=c*f*u+d*h*p,this._z=c*h*p-d*f*u,this._w=c*h*u-d*f*p;break;case"XZY":this._x=d*h*u-c*f*p,this._y=c*f*u-d*h*p,this._z=c*h*p+d*f*u,this._w=c*h*u+d*f*p;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+a)}return e!==!1&&this._onChangeCallback(),this}setFromAxisAngle(t,e){const n=e/2,r=Math.sin(n);return this._x=t.x*r,this._y=t.y*r,this._z=t.z*r,this._w=Math.cos(n),this._onChangeCallback(),this}setFromRotationMatrix(t){const e=t.elements,n=e[0],r=e[4],s=e[8],a=e[1],o=e[5],l=e[9],c=e[2],h=e[6],u=e[10],d=n+o+u;if(d>0){const f=.5/Math.sqrt(d+1);this._w=.25/f,this._x=(h-l)*f,this._y=(s-c)*f,this._z=(a-r)*f}else if(n>o&&n>u){const f=2*Math.sqrt(1+n-o-u);this._w=(h-l)/f,this._x=.25*f,this._y=(r+a)/f,this._z=(s+c)/f}else if(o>u){const f=2*Math.sqrt(1+o-n-u);this._w=(s-c)/f,this._x=(r+a)/f,this._y=.25*f,this._z=(l+h)/f}else{const f=2*Math.sqrt(1+u-n-o);this._w=(a-r)/f,this._x=(s+c)/f,this._y=(l+h)/f,this._z=.25*f}return this._onChangeCallback(),this}setFromUnitVectors(t,e){let n=t.dot(e)+1;return n<Number.EPSILON?(n=0,Math.abs(t.x)>Math.abs(t.z)?(this._x=-t.y,this._y=t.x,this._z=0,this._w=n):(this._x=0,this._y=-t.z,this._z=t.y,this._w=n)):(this._x=t.y*e.z-t.z*e.y,this._y=t.z*e.x-t.x*e.z,this._z=t.x*e.y-t.y*e.x,this._w=n),this.normalize()}angleTo(t){return 2*Math.acos(Math.abs(cr(this.dot(t),-1,1)))}rotateTowards(t,e){const n=this.angleTo(t);if(n===0)return this;const r=Math.min(1,e/n);return this.slerp(t,r),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(t){return this._x*t._x+this._y*t._y+this._z*t._z+this._w*t._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let t=this.length();return t===0?(this._x=0,this._y=0,this._z=0,this._w=1):(t=1/t,this._x=this._x*t,this._y=this._y*t,this._z=this._z*t,this._w=this._w*t),this._onChangeCallback(),this}multiply(t,e){return e!==void 0?(console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),this.multiplyQuaternions(t,e)):this.multiplyQuaternions(this,t)}premultiply(t){return this.multiplyQuaternions(t,this)}multiplyQuaternions(t,e){const n=t._x,r=t._y,s=t._z,a=t._w,o=e._x,l=e._y,c=e._z,h=e._w;return this._x=n*h+a*o+r*c-s*l,this._y=r*h+a*l+s*o-n*c,this._z=s*h+a*c+n*l-r*o,this._w=a*h-n*o-r*l-s*c,this._onChangeCallback(),this}slerp(t,e){if(e===0)return this;if(e===1)return this.copy(t);const n=this._x,r=this._y,s=this._z,a=this._w;let o=a*t._w+n*t._x+r*t._y+s*t._z;if(o<0?(this._w=-t._w,this._x=-t._x,this._y=-t._y,this._z=-t._z,o=-o):this.copy(t),o>=1)return this._w=a,this._x=n,this._y=r,this._z=s,this;const l=1-o*o;if(l<=Number.EPSILON){const f=1-e;return this._w=f*a+e*this._w,this._x=f*n+e*this._x,this._y=f*r+e*this._y,this._z=f*s+e*this._z,this.normalize(),this._onChangeCallback(),this}const c=Math.sqrt(l),h=Math.atan2(c,o),u=Math.sin((1-e)*h)/c,d=Math.sin(e*h)/c;return this._w=a*u+this._w*d,this._x=n*u+this._x*d,this._y=r*u+this._y*d,this._z=s*u+this._z*d,this._onChangeCallback(),this}slerpQuaternions(t,e,n){return this.copy(t).slerp(e,n)}random(){const t=Math.random(),e=Math.sqrt(1-t),n=Math.sqrt(t),r=2*Math.PI*Math.random(),s=2*Math.PI*Math.random();return this.set(e*Math.cos(r),n*Math.sin(s),n*Math.cos(s),e*Math.sin(r))}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._w===this._w}fromArray(t,e=0){return this._x=t[e],this._y=t[e+1],this._z=t[e+2],this._w=t[e+3],this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._w,t}fromBufferAttribute(t,e){return this._x=t.getX(e),this._y=t.getY(e),this._z=t.getZ(e),this._w=t.getW(e),this}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class Na{constructor(t=0,e=0,n=0){Na.prototype.isVector3=!0,this.x=t,this.y=e,this.z=n}set(t,e,n){return n===void 0&&(n=this.z),this.x=t,this.y=e,this.z=n,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}add(t,e){return e!==void 0?(console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this.z+=t.z,this)}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this}sub(t,e){return e!==void 0?(console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this.z-=t.z,this)}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this}multiply(t,e){return e!==void 0?(console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(t,e)):(this.x*=t.x,this.y*=t.y,this.z*=t.z,this)}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}multiplyVectors(t,e){return this.x=t.x*e.x,this.y=t.y*e.y,this.z=t.z*e.z,this}applyEuler(t){return t&&t.isEuler||console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),this.applyQuaternion(og.setFromEuler(t))}applyAxisAngle(t,e){return this.applyQuaternion(og.setFromAxisAngle(t,e))}applyMatrix3(t){const e=this.x,n=this.y,r=this.z,s=t.elements;return this.x=s[0]*e+s[3]*n+s[6]*r,this.y=s[1]*e+s[4]*n+s[7]*r,this.z=s[2]*e+s[5]*n+s[8]*r,this}applyNormalMatrix(t){return this.applyMatrix3(t).normalize()}applyMatrix4(t){const e=this.x,n=this.y,r=this.z,s=t.elements,a=1/(s[3]*e+s[7]*n+s[11]*r+s[15]);return this.x=(s[0]*e+s[4]*n+s[8]*r+s[12])*a,this.y=(s[1]*e+s[5]*n+s[9]*r+s[13])*a,this.z=(s[2]*e+s[6]*n+s[10]*r+s[14])*a,this}applyQuaternion(t){const e=this.x,n=this.y,r=this.z,s=t.x,a=t.y,o=t.z,l=t.w,c=l*e+a*r-o*n,h=l*n+o*e-s*r,u=l*r+s*n-a*e,d=-s*e-a*n-o*r;return this.x=c*l+d*-s+h*-o-u*-a,this.y=h*l+d*-a+u*-s-c*-o,this.z=u*l+d*-o+c*-a-h*-s,this}project(t){return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)}unproject(t){return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)}transformDirection(t){const e=this.x,n=this.y,r=this.z,s=t.elements;return this.x=s[0]*e+s[4]*n+s[8]*r,this.y=s[1]*e+s[5]*n+s[9]*r,this.z=s[2]*e+s[6]*n+s[10]*r,this.normalize()}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this}divideScalar(t){return this.multiplyScalar(1/t)}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this.z=t.z+(e.z-t.z)*n,this}cross(t,e){return e!==void 0?(console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(t,e)):this.crossVectors(this,t)}crossVectors(t,e){const n=t.x,r=t.y,s=t.z,a=e.x,o=e.y,l=e.z;return this.x=r*l-s*o,this.y=s*a-n*l,this.z=n*o-r*a,this}projectOnVector(t){const e=t.lengthSq();if(e===0)return this.set(0,0,0);const n=t.dot(this)/e;return this.copy(t).multiplyScalar(n)}projectOnPlane(t){return Fu.copy(this).projectOnVector(t),this.sub(Fu)}reflect(t){return this.sub(Fu.copy(t).multiplyScalar(2*this.dot(t)))}angleTo(t){const e=Math.sqrt(this.lengthSq()*t.lengthSq());if(e===0)return Math.PI/2;const n=this.dot(t)/e;return Math.acos(cr(n,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,n=this.y-t.y,r=this.z-t.z;return e*e+n*n+r*r}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)+Math.abs(this.z-t.z)}setFromSpherical(t){return this.setFromSphericalCoords(t.radius,t.phi,t.theta)}setFromSphericalCoords(t,e,n){const r=Math.sin(e)*t;return this.x=r*Math.sin(n),this.y=Math.cos(e)*t,this.z=r*Math.cos(n),this}setFromCylindrical(t){return this.setFromCylindricalCoords(t.radius,t.theta,t.y)}setFromCylindricalCoords(t,e,n){return this.x=t*Math.sin(e),this.y=n,this.z=t*Math.cos(e),this}setFromMatrixPosition(t){const e=t.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this}setFromMatrixScale(t){const e=this.setFromMatrixColumn(t,0).length(),n=this.setFromMatrixColumn(t,1).length(),r=this.setFromMatrixColumn(t,2).length();return this.x=e,this.y=n,this.z=r,this}setFromMatrixColumn(t,e){return this.fromArray(t.elements,e*4)}setFromMatrix3Column(t,e){return this.fromArray(t.elements,e*3)}setFromEuler(t){return this.x=t._x,this.y=t._y,this.z=t._z,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t}fromBufferAttribute(t,e,n){return n!==void 0&&console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const t=(Math.random()-.5)*2,e=Math.random()*Math.PI*2,n=Math.sqrt(1-t**2);return this.x=n*Math.cos(e),this.y=n*Math.sin(e),this.z=t,this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const Fu=new Na,og=new G2,de=new Na,Dl=new Gn;class k2{constructor(t,e,n){if(Array.isArray(t))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,this.name="",this.array=t,this.itemSize=e,this.count=t!==void 0?t.length/e:0,this.normalized=n===!0,this.usage=rg,this.updateRange={offset:0,count:-1},this.version=0}onUploadCallback(){}set needsUpdate(t){t===!0&&this.version++}setUsage(t){return this.usage=t,this}copy(t){return this.name=t.name,this.array=new t.array.constructor(t.array),this.itemSize=t.itemSize,this.count=t.count,this.normalized=t.normalized,this.usage=t.usage,this}copyAt(t,e,n){t*=this.itemSize,n*=e.itemSize;for(let r=0,s=this.itemSize;r<s;r++)this.array[t+r]=e.array[n+r];return this}copyArray(t){return this.array.set(t),this}copyColorsArray(t){const e=this.array;let n=0;for(let r=0,s=t.length;r<s;r++){let a=t[r];a===void 0&&(console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined",r),a=new ag),e[n++]=a.r,e[n++]=a.g,e[n++]=a.b}return this}copyVector2sArray(t){const e=this.array;let n=0;for(let r=0,s=t.length;r<s;r++){let a=t[r];a===void 0&&(console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined",r),a=new Gn),e[n++]=a.x,e[n++]=a.y}return this}copyVector3sArray(t){const e=this.array;let n=0;for(let r=0,s=t.length;r<s;r++){let a=t[r];a===void 0&&(console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined",r),a=new Na),e[n++]=a.x,e[n++]=a.y,e[n++]=a.z}return this}copyVector4sArray(t){const e=this.array;let n=0;for(let r=0,s=t.length;r<s;r++){let a=t[r];a===void 0&&(console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined",r),a=new Du),e[n++]=a.x,e[n++]=a.y,e[n++]=a.z,e[n++]=a.w}return this}applyMatrix3(t){if(this.itemSize===2)for(let e=0,n=this.count;e<n;e++)Dl.fromBufferAttribute(this,e),Dl.applyMatrix3(t),this.setXY(e,Dl.x,Dl.y);else if(this.itemSize===3)for(let e=0,n=this.count;e<n;e++)de.fromBufferAttribute(this,e),de.applyMatrix3(t),this.setXYZ(e,de.x,de.y,de.z);return this}applyMatrix4(t){for(let e=0,n=this.count;e<n;e++)de.fromBufferAttribute(this,e),de.applyMatrix4(t),this.setXYZ(e,de.x,de.y,de.z);return this}applyNormalMatrix(t){for(let e=0,n=this.count;e<n;e++)de.fromBufferAttribute(this,e),de.applyNormalMatrix(t),this.setXYZ(e,de.x,de.y,de.z);return this}transformDirection(t){for(let e=0,n=this.count;e<n;e++)de.fromBufferAttribute(this,e),de.transformDirection(t),this.setXYZ(e,de.x,de.y,de.z);return this}set(t,e=0){return this.array.set(t,e),this}getX(t){return this.array[t*this.itemSize]}setX(t,e){return this.array[t*this.itemSize]=e,this}getY(t){return this.array[t*this.itemSize+1]}setY(t,e){return this.array[t*this.itemSize+1]=e,this}getZ(t){return this.array[t*this.itemSize+2]}setZ(t,e){return this.array[t*this.itemSize+2]=e,this}getW(t){return this.array[t*this.itemSize+3]}setW(t,e){return this.array[t*this.itemSize+3]=e,this}setXY(t,e,n){return t*=this.itemSize,this.array[t+0]=e,this.array[t+1]=n,this}setXYZ(t,e,n,r){return t*=this.itemSize,this.array[t+0]=e,this.array[t+1]=n,this.array[t+2]=r,this}setXYZW(t,e,n,r,s){return t*=this.itemSize,this.array[t+0]=e,this.array[t+1]=n,this.array[t+2]=r,this.array[t+3]=s,this}onUpload(t){return this.onUploadCallback=t,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const t={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return this.name!==""&&(t.name=this.name),this.usage!==rg&&(t.usage=this.usage),(this.updateRange.offset!==0||this.updateRange.count!==-1)&&(t.updateRange=this.updateRange),t}}const V2="\\[\\]\\.:\\/";""+V2.replace("\\.","");typeof __THREE_DEVTOOLS__!="undefined"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:ng}}));typeof window!="undefined"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=ng);class lg extends lu{constructor(t){super();this.isLineBasicMaterial=!0,this.type="LineBasicMaterial",this.color=new nr(16777215),this.linewidth=1,this.linecap="round",this.linejoin="round",this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.linewidth=t.linewidth,this.linecap=t.linecap,this.linejoin=t.linejoin,this.fog=t.fog,this}}const cg=new it,hg=new it,ug=new li,Iu=new Qm,Fl=new du;class W2 extends Mi{constructor(t=new _s,e=new lg){super();this.isLine=!0,this.type="Line",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t,e){return super.copy(t,e),this.material=t.material,this.geometry=t.geometry,this}computeLineDistances(){const t=this.geometry;if(t.index===null){const e=t.attributes.position,n=[0];for(let r=1,s=e.count;r<s;r++)cg.fromBufferAttribute(e,r-1),hg.fromBufferAttribute(e,r),n[r]=n[r-1],n[r]+=cg.distanceTo(hg);t.setAttribute("lineDistance",new xs(n,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}raycast(t,e){const n=this.geometry,r=this.matrixWorld,s=t.params.Line.threshold,a=n.drawRange;if(n.boundingSphere===null&&n.computeBoundingSphere(),Fl.copy(n.boundingSphere),Fl.applyMatrix4(r),Fl.radius+=s,t.ray.intersectsSphere(Fl)===!1)return;ug.copy(r).invert(),Iu.copy(t.ray).applyMatrix4(ug);const o=s/((this.scale.x+this.scale.y+this.scale.z)/3),l=o*o,c=new it,h=new it,u=new it,d=new it,f=this.isLineSegments?2:1,p=n.index,y=n.attributes.position;if(p!==null){const g=Math.max(0,a.start),m=Math.min(p.count,a.start+a.count);for(let E=g,w=m-1;E<w;E+=f){const S=p.getX(E),_=p.getX(E+1);if(c.fromBufferAttribute(y,S),h.fromBufferAttribute(y,_),Iu.distanceSqToSegment(c,h,d,u)>l)continue;d.applyMatrix4(this.matrixWorld);const B=t.ray.origin.distanceTo(d);B<t.near||B>t.far||e.push({distance:B,point:u.clone().applyMatrix4(this.matrixWorld),index:E,face:null,faceIndex:null,object:this})}}else{const g=Math.max(0,a.start),m=Math.min(y.count,a.start+a.count);for(let E=g,w=m-1;E<w;E+=f){if(c.fromBufferAttribute(y,E),h.fromBufferAttribute(y,E+1),Iu.distanceSqToSegment(c,h,d,u)>l)continue;d.applyMatrix4(this.matrixWorld);const _=t.ray.origin.distanceTo(d);_<t.near||_>t.far||e.push({distance:_,point:u.clone().applyMatrix4(this.matrixWorld),index:E,face:null,faceIndex:null,object:this})}}}updateMorphTargets(){const e=this.geometry.morphAttributes,n=Object.keys(e);if(n.length>0){const r=e[n[0]];if(r!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,a=r.length;s<a;s++){const o=r[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[o]=s}}}}}const dg=new it,fg=new it;class $2 extends W2{constructor(t,e){super(t,e);this.isLineSegments=!0,this.type="LineSegments"}computeLineDistances(){const t=this.geometry;if(t.index===null){const e=t.attributes.position,n=[];for(let r=0,s=e.count;r<s;r+=2)dg.fromBufferAttribute(e,r),fg.fromBufferAttribute(e,r+1),n[r]=r===0?0:n[r-1],n[r+1]=n[r]+dg.distanceTo(fg);t.setAttribute("lineDistance",new xs(n,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}}const Il=new us;class X2 extends $2{constructor(t,e=16776960){const n=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),r=new Float32Array(8*3),s=new _s;s.setIndex(new an(n,1)),s.setAttribute("position",new an(r,3));super(s,new lg({color:e,toneMapped:!1}));this.object=t,this.type="BoxHelper",this.matrixAutoUpdate=!1,this.update()}update(t){if(t!==void 0&&console.warn("THREE.BoxHelper: .update() has no longer arguments."),this.object!==void 0&&Il.setFromObject(this.object),Il.isEmpty())return;const e=Il.min,n=Il.max,r=this.geometry.attributes.position,s=r.array;s[0]=n.x,s[1]=n.y,s[2]=n.z,s[3]=e.x,s[4]=n.y,s[5]=n.z,s[6]=e.x,s[7]=e.y,s[8]=n.z,s[9]=n.x,s[10]=e.y,s[11]=n.z,s[12]=n.x,s[13]=n.y,s[14]=e.z,s[15]=e.x,s[16]=n.y,s[17]=e.z,s[18]=e.x,s[19]=e.y,s[20]=e.z,s[21]=n.x,s[22]=e.y,s[23]=e.z,r.needsUpdate=!0,this.geometry.computeBoundingSphere()}setFromObject(t){return this.object=t,this.update(),this}copy(t,e){return super.copy(t,e),this.object=t.object,this}}class pg extends rr{constructor(t,e,n,r,s,a,o,l,c){super(t,e,n,r,s,a,o,l,c);this.isCanvasTexture=!0,this.needsUpdate=!0}}function q2(i){return{head:{h:0,w:0,d:0,x:0,y:0,z:0,layer:{w:9,h:9,d:9,top:[40,0,48,8],bottom:[48,0,56,8],right:[32,8,40,16],front:[40,8,48,16],left:[48,8,56,16],back:[56,8,64,16]},top:[8,0,16,8],bottom:[24,8,16,0],right:[0,8,8,16],front:[8,8,16,16],left:[16,8,24,16],back:[24,8,32,16]},rightLeg:{h:0,w:0,d:0,x:0,y:0,z:0,layer:{w:4.5,d:4.5,h:13.5,top:[4,48,8,36],bottom:[8,48,12,36],right:[0,36,4,48],front:[4,36,8,48],left:[8,36,12,48],back:[12,36,16,48]},top:[4,16,8,20],bottom:[8,16,12,20],right:[0,20,4,32],front:[4,20,8,32],left:[8,20,12,32],back:[12,20,16,32]},torso:{h:0,w:0,d:0,x:0,y:0,z:0,layer:{w:9,h:13.5,d:4.5,top:[20,48,28,36],bottom:[28,48,36,36],right:[16,36,20,48],front:[20,36,28,48],left:[28,36,32,48],back:[32,36,40,48]},top:[20,16,28,20],bottom:[28,16,36,20],right:[16,20,20,32],front:[20,20,28,32],left:[28,20,32,32],back:[32,20,40,32]},leftArm:{h:0,w:0,d:0,x:0,y:0,z:0,layer:{w:4.5,h:13.5,d:4.5,top:[52,48,56,52],bottom:[56,48,60,52],right:[48,52,52,64],front:[52,52,56,64],left:[56,52,60,64],back:[60,52,64,64]},top:[36,48,i?39:40,52],bottom:[i?39:40,48,i?42:44,52],left:[32,52,36,64],front:[36,52,i?39:40,64],right:[i?39:40,52,i?43:44,64],back:[i?43:44,52,i?46:48,64]},rightArm:{h:0,w:0,d:0,x:0,y:0,z:0,layer:{w:4.5,h:13.5,d:4.5,top:[44,48,48,36],bottom:[48,48,52,36],left:[48,36,52,48],front:[44,36,48,48],right:[40,36,44,48],back:[52,36,64,48]},top:[44,16,i?47:48,20],bottom:[i?47:48,16,i?50:52,20],left:[40,20,44,32],front:[44,20,i?47:48,32],right:[i?47:48,20,i?51:52,32],back:[i?51:52,20,i?54:56,32]},leftLeg:{h:0,w:0,d:0,x:0,y:0,z:0,layer:{w:4.5,d:4.5,h:13.5,top:[4,48,8,52],bottom:[8,48,12,52],right:[0,52,4,64],front:[4,52,8,64],left:[8,52,12,64],back:[12,52,16,64]},top:[20,48,24,52],bottom:[24,48,28,52],right:[16,52,20,64],front:[20,52,24,64],left:[24,52,28,64],back:[28,52,32,64]},cape:{x:0,y:0,z:0,h:0,w:0,d:0,top:[1,0,11,1],bottom:[11,0,21,1],left:[11,1,12,17],front:[12,1,22,17],right:[0,1,1,17],back:[1,1,11,17]}}}const Ms=1/32;function mg(i){function t(n){function r(s){return{h:Math.abs(s.front[1]-s.front[3])*Ms,w:Math.abs(s.front[0]-s.front[2])*Ms,d:Math.abs(s.right[0]-s.right[2])*Ms}}for(const s of Object.values(n))Object.assign(s,r(s)),"layer"in s&&(s.layer.w*=Ms,s.layer.h*=Ms,s.layer.d*=Ms);return n}function e(n){const r=1;return n.head.y=r-n.head.h/2,n.torso.y=n.rightLeg.h+n.torso.h/2,n.rightLeg.x=-n.rightLeg.w/2,n.rightLeg.y=n.rightLeg.h/2,n.leftLeg.x=n.leftLeg.w/2,n.leftLeg.y=n.leftLeg.h/2,n.rightArm.x=-n.torso.w/2-n.rightArm.w/2,n.rightArm.y=n.rightLeg.h+n.torso.h-n.rightArm.h/2,n.leftArm.x=n.torso.w/2+n.leftArm.w/2,n.leftArm.y=n.leftLeg.h+n.torso.h-n.leftArm.h/2,n.cape.y=n.rightLeg.h+n.torso.h/5*2,n.cape.z=-n.torso.d*3/2,n}return e(t(q2(i)))}var zl={steve:mg(!1),alex:mg(!0)};function Y2(i,t){const e=t/64;function n(r,s,a,o,l,c,h,u){s*=e,a*=e,o*=e,l*=e,c*=e,h*=e;const d=r.getImageData(s,a,o,l);if(u)for(let f=0;f<l;f++)for(let p=0;p<o/2;p++){const x=(p+f*o)*4,y=(o-p-1+f*o)*4,g=d.data[x],m=d.data[x+1],E=d.data[x+2],w=d.data[x+3],S=d.data[y],_=d.data[y+1],T=d.data[y+2],B=d.data[y+3];d.data[x]=S,d.data[x+1]=_,d.data[x+2]=T,d.data[x+3]=B,d.data[y]=g,d.data[y+1]=m,d.data[y+2]=E,d.data[y+3]=w}r.putImageData(d,c,h)}n(i,4,16,4,4,20,48,!0),n(i,8,16,4,4,24,48,!0),n(i,0,20,4,12,24,52,!0),n(i,4,20,4,12,20,52,!0),n(i,8,20,4,12,16,52,!0),n(i,12,20,4,12,28,52,!0),n(i,44,16,4,4,36,48,!0),n(i,48,16,4,4,40,48,!0),n(i,40,20,4,12,40,52,!0),n(i,44,20,4,12,36,52,!0),n(i,48,20,4,12,32,52,!0),n(i,52,20,4,12,44,52,!0)}function bs(i,t){const n=i.material.map,r=1/n.image.width,s=1/n.image.height,a=[];function o(h,u,d,f){h*=r,d*=r,u=1-u*s,f=1-f*s,a.push(new Gn(h,u),new Gn(d,u),new Gn(h,f),new Gn(d,f))}const l=["left","right","top","bottom","front","back"];for(let h=0;h<l.length;h++){const u=t[l[h]];o(u[0],u[1],u[2],u[3])}const c=new k2(new Float32Array(a.length*2),2).copyVector2sArray(a);i.geometry.setAttribute("uv",c)}class j2 extends Mi{constructor(t,e,n,r){super();this._slim=!1,this._slim=r,Z2(this,t,e,n,r)}get slim(){return this._slim}set slim(t){if(t!==this._slim){const e=t?zl.alex:zl.steve,n=this.getObjectByName("leftArm"),r=this.getObjectByName("rightArm");n.geometry=new on(e.leftArm.w,e.leftArm.h,e.leftArm.d),bs(n,e.leftArm),r.geometry=new on(e.rightArm.w,e.rightArm.h,e.rightArm.d),bs(r,e.rightArm);const s=this.getObjectByName("leftArmLayer"),a=this.getObjectByName("rightArmLayer");s&&(s.geometry=new on(e.leftArm.layer.w,e.leftArm.layer.h,e.leftArm.layer.d),bs(s,e.leftArm.layer)),a&&(a.geometry=new on(e.rightArm.layer.w,e.rightArm.layer.h,e.rightArm.layer.d),bs(a,e.rightArm.layer))}this._slim=t}}function Z2(i,t,e,n,r){const s=r?zl.alex:zl.steve,a=Object.keys(s);for(const o of a){const l=s[o],c=new Tu(new on(l.w,l.h,l.d),o==="cape"?e:t);c.name=o,l.y&&(c.position.y=l.y),l.x&&(c.position.x=l.x),l.z&&(c.position.z=l.z),o==="cape"&&(c.rotation.x=25*(Math.PI/180)),bs(c,l);const h=new X2(c,new nr(16777215));if(h.name=`${o}Box`,h.visible=!1,c.add(h),"layer"in l){const u=l.layer,d=new Tu(new on(u.w,u.h,u.d),n);d.name=`${o}Layer`,u.y&&(d.position.y=u.y),u.x&&(d.position.x=u.x),u.z&&(d.position.z=u.z),bs(d,u),c.add(d)}i.add(c)}return i}function gg(i){return i instanceof Image?i:new Promise((t,e)=>{const n=new Image;n.crossOrigin="anonymous",n.onload=()=>{t(n)},n.onerror=(r,s,a,o,l)=>{e(l)},i instanceof URL?n.src=i.toString():n.src=i})}class zu{static create(){return new zu}constructor(){const t=document.createElement("canvas");t.width=64,t.height=64;const e=new pg(t);e.magFilter=Ta,e.minFilter=Ta,this.texturePlayer=e,e.name="skinTexture",this.materialPlayer=new Fa({map:e}),this.materialTransparent=new Fa({map:e,transparent:!0,depthWrite:!1,side:Dm});const n=new pg(document.createElement("canvas"));n.magFilter=Ta,n.minFilter=Ta,n.name="capeTexture",this.textureCape=n;const r=new Fa({map:this.textureCape});r.name="capeMaterial",r.visible=!1,this.materialCape=r,this.playerObject3d=new j2(this.materialPlayer,this.materialCape,this.materialTransparent,!1)}async setSkin(t,e=!1){this.playerObject3d.slim=e;const n=this.texturePlayer,r=await gg(t),s=r.width!==r.height,a=n.image,o=a.getContext("2d");a.width=r.width,a.height=r.width,o.clearRect(0,0,r.width,r.width),s?(o.drawImage(r,0,0,r.width,r.width/2),Y2(o,r.width)):o.drawImage(r,0,0,r.width,r.width),n.needsUpdate=!0}async setCape(t){if(t===void 0){this.materialCape.visible=!1;return}this.materialCape.visible=!0;const e=await gg(t),n=this.textureCape;n.image=e,n.needsUpdate=!0}}function Nl(i,t,e){let n=window.innerWidth;if(n!==e)if(n>=1e3){let r=n/4.8;i.width=r,i.height=r,t.setSize(r,r),e=n}else{let r=n/2;i.width=r,i.height=r,t.setSize(r,r),e=n}}function tL(){const{play:i,stop:t}=J2(),{play:e,stop:n}=Q2();return{play(){i(),e()},stop(){t(),n()}}}function J2(){const i="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAA6GSURBVHhe7Z0LcBXVGcfvvRDCK8QoAUqCAURQgpApSMFaW2YUq1U6xOlUrRjHaWm1xcdU+1A64tRWa9tRcaqWaR0VR53pGEa0+GxpayvUlppaDCOvGCEoBA15kAchuc33nfO/uXvubvbcu3uzN9nzmznznd3s3j3Zc77/fnv27NloxCMFBQVxsp9bsoSXwdiRo2RO0H7yhMwJ/rl9O9slS5eyVXHbH7z+2mue/wcv4P9vbW1NqxzqfhdedBEvg7GxkTInaO89KXOCN15/3Zf/OyatIaT4pgDLzr+Al4tGs4lMGGX1YFDfIjx569//xhYKoHq8G1CE4aIAQWEUIOT41gDIIyk1dcQ51Td32SZsZ8gNjAKEHM/XnxVfvpSvZUVj0vspUgkiGvPWBl/Y8lKg19ChjlGAkOO7AjhF/6DlhLj+OynAs+uukTl7rlr3tMwJjAJ4wyhAyPHsPSk9WCPyZM6e9p5umRNEo6IIL9xzPVtdvrr2cbZB9wMMdYwChBzfGgB5PiWKBSiVFeZbEtZjOxVyY+PKg49RgJDjWwOgazulhrYTnHZ92mZJWI/tVCiQSA4moAhqMviLUYCQE8VTKRU83QNu/feI5nWJx20PmwBPB/G7f37zr2ydyHQ8ghOZPqW7rvLyAf+xJ6pfzOh3neoJZPo00iiAMwO3UBuSK79wdF5KItwaiAOZ7KNFQgE2btzIK8CqVavYVl74RbYNbV1s4VmqR3lVgHF5+WyPd4vjlIwXy9VvCM93Kh+AYqFc2B+o5cd4BKB6ULrP61Gx5501g5eJT1raIh9/ekwu9dPc2a2tBE7lUBXBKED2sJxoO5Irnyqd0t6GjyNNrW3892So8tPA9dhesW0ApaWlka1bt0Zqa2vlGuE5lIpG993P9yW/OaXPYSnhOJBNKgOVhco0ECgX9p+Qn8dJnMN4Yj2NWMKopYEgjxrIq6pWXhanhMqfM7WYK508nlJX90lOgCo+ufJ1LwVu5fBKSgPAiZ48eTLbXABlcWsEWcL15FPlk7ejwlHZySlDslbxILrikq9wS8Q1kbyNTvj9t9/Eyy1dovBNnaLBlhWKa+iuT6zytumGc9nGJojKikoL4i2H2fZKu/LRf7EFcyeOZ/vBMXENn36KOA5O3j3rH40cPnw4smzZMl5W71KwPfZHOVu6xHJTJ5vE+vpmsX7zy3+kkxzvuybysq634bzNKMqP5OeNtFQ+6OjoiHT39jv6ydjoSEdPtyU+OdgqCqY7yjcpJiDjuYGkKEAueb5KFsvm6URS5Sd7OlV8cuVTxVMCCEg94rnyiYQCqJ7R70F6CnC0sVHmBG9t+JHMCc5bfZ/MCSYWF8ucwE0BcHzV00FifZM4uWUUUPSRUID2XrZlMgCoPya22/zKluQTKQ6icXLxFLS8uMDW65MrXKpMAjrnUII0FUC7fLr4chegVr4OmewzCNCJzfjk6lQ+gXUZKIGn8tmRUABE9qqnQwGkw3CkTtTsP8AW9//z589nW//++2xffvhWtuCSNQ+wLZszh+27777LFv0BFTOnscVx4NHHOqQHy3IlytkhPLqvAGwQ2WOkUYoCyPVFY9j0LQsLMKLpyU2pFWbHwoUL+QfPn1PGCoDKr371T1r7L1q0KD61eHKk4cjHvLxjxw6t/QBGYgHd8letFPWN8+FbP8Do/HxOU047LbJ12za5th9aR3/DdsMNqvyeEbJ1aXKoUQTEQRK9aPlybgpj5DN6ujYRbj1pHzRYFeDBBx9k+4cNG9jeW7WILfjxk/9m+7XVq9necsstbKEA00uEArj15KnlxP4oV//+YhnQk0gCYxHUJ5LqenV/1bMQA5QW9EX2fd7/2vYdvF6XReeKuyaUX40BqlZaPbyhTZQr0/I7/f++KQB4+OmnI8VTpkSix49aEq2jvw03qPI7Iukp2heWnCdzwZNQABV4GoDHOVH9HeHxuv0AlY8JRXACHg3UZw9AfaYA0NKB6jEAnuc2thH720XriKPAm9vfkrlU4PlOYxlRDrfyq+XQLT/A/r4pQHzcRE49PT2cVLAe2w0nKKonB6FE+aamppTKpXV264PGtUBlZWX2Liapq6uTOSvHjx9nW1BQ4OmfdlIoXXbLu5JMqa+v91T+3l7ZG6Qwd+5ctoihcL7ylQB5z549WW00vscAhqGFaQA5xu7fXMuJYhun+MZPTAMIOdoxwF0/e4SXjza1s63dvY/t4w/9gK1KtmOAX6/6vMwJvr/xHzJnBTHAmtt/xba5W3QBHth/iC2YNnMq28I80Znz8C9vYzvYMUD9777F9swbn2S7d+9eEwMYsodpADnG7O8+xYmUAeqQTUwDCDlRt/t8RKLr7n2U7acyBnhPxgBqoLp1s9gOOEWyaN1nzp7N1gknL1DfJsbbwipukbRXL3v1lVdkLj3a2lIHjNoxfrwYJwFmK+fLa4wwZBWg5OIbLMmQGdH36uoHdhEXag98KHOC21YNPMMH2PIXMQbx5tXfZLupupotWFlZyRYeiqeDeCropADqdlCAhoMH2YISOcAUv5/6NNHaI6c+DcV2g60As2bNkjnB/v37h78CFET7ny0k51V0tzP0E21/+7mMFKBHPtXTZYTydBCsuPP3bAdSAPJGGnpN4+1p9A2NDtr00mb+O1h52QoeLUTvEkw59ZTI+4ca2Wt1FUBVDizjla7ao8Jj1e0GWwHOOOMMmRPU1dWFMwbo6hIVQCTnDekRuAJceZd45++/tTvZggVz57ElDyXPhgLc81vRQzZypHU27ZMnxbj8td+uSigAKQUUYKDfJ9QxkViGAmAUsrrdxueeYZsuhw5ZeyJVUC68rwAlqKioYAtCEQMQdi9Z0qNT9fEpYbetwR7XfoBsA090UwCCvBEKMG7cOLYAfemkAMnvEugqgPq+gZMCqNu5zWvoxF6XcQqz5OhplXlX3sEW/1coYoCW46LzKR0y2SeMRBcsWJCRAqQbeNlJNVE2VUTjTh5KjOztjEw7rZDz8Dz1LgAKsKbqarbUAGiYdq4owGevXce2vV00TBzXCZR77NixbP/zlNj/nKvuZNvbK96LCIUCJL9po0u6Y/SzBVU8Kt8Lfv2OSs4rgJOHOikAuObrV7HNtgLg/QhdTsi5knVRz1tLS4vMCUJzF2DIDjHykEwSeU5yAup6JLvfoJQpH330kSUB8nxKNe/9jxN5vur9dtCdQ/Jbvk6o29n9rwMlr/j9e0YBQk50/vz5Wm5YU1Mjc4Ly8nKZ0yMvT1xLVSbJSR/27N7NFqjX6MQ1+azlbFvarLd5E8aLaPn00ils1/9CjOlzAuMQ8Pvo49ftCcSzgMYjR9jq4jV2kjODJNi3b58oUIYYBQg50b7rcLy4uJjn3yFoGpbGxkbX67Madbuh9tyB5RdfzNZNAS64rIrtgYPiffpmRQEKpQJMy1ABMh0PEJQCoH7MXYDBE4ErwIwZ/TNrDkRF+Tlsp1cgBrBO8TFhvOj4Ob30M2zdFEBltkPfuxN436CoqIitLl4VAP0AUC4TAxg8MWQU4KYfyjd7uoTnf7hfPE+HJ0ybITy/MF8oQboKkCljxojjoRxu4FmALurvqz2JRgEMBoPBYDAYDAaDwWAwGAx60HsBQbwbENRxDVZMT2DISfQj76z7wOKN82ZMt/Qxu/0d6Hq119m3DP4wZBWgqKgoTkkuGjJkyHpha2urpfK9zkcYVkwMEHKGndfcfHVlvHx6aWT1z9cPyv/W0NDASuQ0HkAdV1FSUpJWufD7IN393RgyCrDhjpu0r/f07d5cYd68eZySyaXYJfD5AXTvBu793vVxmvjhoWeqB8Wz/cKpsnPl4xFDRgHMrB/ZIee9iTyIvIWu7bTspgCDHQO4YacAufTpmJxXAJwsqlRdcikGoPKrSf7JkA4UA0AFDP5hYoCQY+TIIxUVFWmpktc3g2pqanytM9MTGHKi27Zts7TgpUuX2rYw9ds3sVjMdrvnn3/e1iPUN4MKC8WsX07HU7mu8nL+3SeqX+Ttf/LAU5bj/PTWa331jFxl5syZlv/b97eDqUGojYJeH5PZBOo6u/0MuU/i3cAj8j33SZMm2b4bqHq8+jTODad3A52UZKgw2DGAmSXM4Cvaraenp8fS0keMGDGkPdcvzF2AwUBQLEHIRYNPnH322XFKctF3jAKEnJy/jruNV9i5U8wCmq27DBwfs3YDzPSB9RA/fLkEy15n8Mg2RgFCjmkAPrPnkSpONEZQd96gIDENIOTkfBO9bs19fDGdO1t8L29ikbjm3n3njWxzLQbYtf4bbM+8UXzbyOu3fbONUYCQYxqAz5DnUyJFGArdIqYBhJysXZ/U+3en8f/qdstWWD8Fj0C6XMYApyIGuEPEALo4eaNupK7GAOmCmVXx3QQcN+gYwShAyEl5M8jJU73OH6Aex4lnX9oic4JC5evZmXLply6QOSu6nq0+lUuXzs5Ott3d1u8SBd1TaBQg5ETx5k1QtvWNh7SUwenr45mCr58vXvMYWzf8UgCMB0AM4HVEj1diOpWUTSvLYQiImE4lZdPKcrCH26XhSq48KzAKEHK0Kimbtv3t5wJtBAur7pY5e9B/oMYA6XovYgD1ix+6sYXT2ECMSVSXnVDHFBoFCDlalZRNG3YFMHcBhkAJfI6goNHtCRw1SnwxFHhVgFhM9MGZZwGGQAm09RHqmHdcc+Fh8Dy/n63j99VrshN+9QSqCuD0VXUVr8cHKXcB0hpCSlR9n/+KK66wVQXd+QGcXhFvbm6WOQGej69du5atE1CAd955hy3ou9+VucwISgHwNBDHH+wYQJ1fIEUBzPwA4SKq+56/Ohu3qgjUonXmGQB+fXsY4Pi630DG8RcvXszWjWwpwGDHAOrXx00MEHK0rz/Zmh9AV4GMApi7AEMWSPFiBHd9LdQXD3cjaAVQp3J3QrfHEMdTTx+Op/YoZvsuAP0su3btsj2OUYBQE4n8H03C9wrZ3P5CAAAAAElFTkSuQmCC",t=document.getElementById("player-canvas"),e=new Lm({canvas:t,antialias:!0,alpha:!0}),n=new tu,r=new zu;t.getBoundingClientRect();const s=new Qe(45,1,.5,100);s.position.z=3,s.lookAt(new Z(0,0,0));const a=r.playerObject3d;a.translateY(-.5),r.setSkin(i,!1),n.add(a);{const c=new Vr(s,t);c.target=new Z(0,0,0),c.enablePan=!1,c.enableKeys=!1,c.autoRotate=!0,c.autoRotateSpeed=4}let o=window.innerWidth;Nl(t,e,0);let l=!1;return{play(){l||(l=!0,requestAnimationFrame(function c(h){!l||(requestAnimationFrame(c),Nl(t,e,o),e.render(n,s))}))},stop(){!l||(l=!1)}}}function Q2(){const t=Uu(Ou({},{display:{gui:{rotation:[30,225,0],translation:[0,0,0],scale:[.625,.625,.625]},ground:{rotation:[0,0,0],translation:[0,3,0],scale:[.25,.25,.25]},fixed:{rotation:[0,0,0],translation:[0,0,0],scale:[.5,.5,.5]},thirdperson_righthand:{rotation:[75,45,0],translation:[0,2.5,0],scale:[.375,.375,.375]},firstperson_righthand:{rotation:[0,45,0],translation:[0,0,0],scale:[.4,.4,.4]},firstperson_lefthand:{rotation:[0,225,0],translation:[0,0,0],scale:[.4,.4,.4]}}}),{textures:{particle:"block/dirt",bottom:"block/dirt",top:"block/grass_block_top",side:"block/grass_block_side",overlay:"block/grass_block_side_overlay"},elements:[{from:[0,0,0],to:[16,16,16],faces:{down:{uv:[0,0,16,16],texture:"#bottom",cullface:"down"},up:{uv:[0,0,16,16],texture:"#top",cullface:"up",tintindex:0},north:{uv:[0,0,16,16],texture:"#side",cullface:"north"},south:{uv:[0,0,16,16],texture:"#side",cullface:"south"},west:{uv:[0,0,16,16],texture:"#side",cullface:"west"},east:{uv:[0,0,16,16],texture:"#side",cullface:"east"}}},{from:[0,0,0],to:[16,16,16],faces:{north:{uv:[0,0,16,16],texture:"#overlay",tintindex:0,cullface:"north"},south:{uv:[0,0,16,16],texture:"#overlay",tintindex:0,cullface:"south"},west:{uv:[0,0,16,16],texture:"#overlay",tintindex:0,cullface:"west"},east:{uv:[0,0,16,16],texture:"#overlay",tintindex:0,cullface:"east"}}}]}),e={"block/dirt":{url:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAA0UlEQVR42nWSsQ1CMQxEvQ4rINFR0SOBxAgpaRgA/Q3YhelAF+mi9+/nF1YS2zn7zq7v+/H7tEu31/XYbea7nw6ruM/SRYlM0HtZluEzIO+KycporsI3qzGHeSW01tpwsJukkl0MAAcV0GdyJ6AKpa/cVlZyq9SG9yFicpR4TKDipOmzMjnH525m/g6QTp5uOT8zNt2D5J68SaVyPORsYPtJxVrVjBcraHSkwDH3TUxnguyZu1pRkD1v541wpjHb0MokKkz+WWgDkDtgkfbm7wJ/9oUoq3qXqFkAAAAASUVORK5CYII="},"block/grass_block_top":{url:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAB90lEQVR42j2Tx87qUAyEzyOz+em9915F750NAiQ2IPFgvvpGyl2EJCe2p3hw3W7Xfr+fdTody+fzuhqNhiUSCatWqzabzazf71u5XLZCoWClUsn2+735fD6r1Wrmer2eCheLhQ0GAxuNRpZMJnVPp9MadDwebbfbCQQw6hlWqVTMrddrTYrFYpbNZoVQLBat2WzqguF8PrfD4WDX61WNgUBAIM/n05zf77dcLieKMGi1WkJnYLvdFoNMJiMQviMPZGRQ41arlQqYzv1yudjtdhMLnt/vt/39/QmRpvP5bPF4XN/lAWjD4dCCwaB0plIpmYY34/FYlHmmAQDqeK7X65LnmDaZTGy73UoztClEEvTxhSGPx0OMkAgTT47jh4LpdCptDIlGo7bZbNRMoWce7KhnY952HNOgiqOn00koFNIEs/v9rnNWCjsMZ53kA/YOBD6+Xi+Zwo7xhCaMAxnaNIOIdobCBCAHOtMYhA8Mgw2FIH2/XwuFQtKNNzRi4n8P0AldIkyo+MAZiISKd55hFolEhI5+MoDRjj1TBB0OWCuU0RoOh3XGO3eaSCVMYUWfo5GYkkiQKGII5+R+uVxKCjXIZQNI4J3A6b9AEVo9iqSNkNCI0wSJC0Mx0ls5LBxUSR5T0cz+2YI3ADM/n4+yQTP+kBXqMf8fm1m5bOHB3EYAAAAASUVORK5CYII="},"block/grass_block_side":{url:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABX0lEQVQ4y3VSSUuDQQydXyN48OhCse4LVg+KFhcUaxXrMqJiFbwoIvKBIBQFexFcEHexrlAQix68+KOeJJCPNG0PmWSyvJdkxqXfYtj46MPaaw9mrxpZlp86MXlaC//Qhq2vIY4v3LUgdR3F/G0zps7r0Z+pwtJjO9z6ey8n7ufHsJMbwO7LIEaj1Zi7aULyooGBjn6mkSkkmISKKZ/AFu9b4Q4+J7jg5M9j5jLCDHRfyXWxpg63C3EcfieR/U2xbzhbg8RZHduODu89X0hWn7tDm4Q6IE3tkt6MR8IY2e7Yx9ggnd8b54D4dLIQSW4IIEnk1GC6UIOJTUKEjg7tDIKgKEHi2tZEzibrTnQ35fwMYJ1aS8u2WMecXYrdshU7itOMdmYBFr8eRXblys2lGejp9Aj6mfkjWacFqSTSVdEIJOmRjpLFyRiyF/1azibpDev5LVEJgP0DsqRK7y8E/2kQKqQTbHIJAAAAAElFTkSuQmCC"},"block/grass_block_side_overlay":{url:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAeElEQVQ4T+2NsQrAIAxE/WtHUdxUUARXZwcXfzDtXRFa6Cd4IPHlLokaY0jOWVprEmOUzajo4fXeyahrLbHW8g9PwXgPIqBugZ1zZATBtVbWnQ8hiOKWWwh672mAsWwv2tfmnOxprZ/rfyqlfAxjDDml9D9wdHREXc8PflIHcVV8AAAAAElFTkSuQmCC"}},n=document.getElementById("block-canvas"),r=n.getBoundingClientRect(),s=new Qe(60,1,1,1e3);s.position.x=16,s.position.x=16,s.position.x=32;const a=new tu,o=new Lm({canvas:n,antialias:!0,alpha:!0});o.setSize(r.width,r.height),a.add(new Cm(16777215,.97));const c=new ig(e).getObject(t);a.add(c);const h=new Vr(s,o.domElement);h.enableDamping=!0,h.dampingFactor=.2,h.zoomSpeed=1.4,h.rotateSpeed=.6,h.enableKeys=!1;let u=window.innerWidth;Nl(n,o,0);let d=!1;return{play(){d||(d=!0,requestAnimationFrame(function f(p){!d||(requestAnimationFrame(f),Nl(n,o,u),o.render(a,s))}))},stop(){!d||(d=!1)}}}export{tL as setupAll,Q2 as setupBlock,J2 as setupPlayer};
